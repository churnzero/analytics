/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@churnzero/clientlibs/dist/main/classes/ActivityMonitor.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/classes/ActivityMonitor.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActivityMonitor = void 0;
var ActivityMonitor = (function () {
    function ActivityMonitor(windowRef, ErrorLogger, idleTimeoutMsOveride) {
        this.windowRef = windowRef;
        this.ErrorLogger = ErrorLogger;
        this.idleTimeoutMs = 15 * 60 * 1000;
        this.visibilityCheckIntervalMs = 500;
        this.currentIdleTimeMs = 0;
        this.active = false;
        this.idleTimeoutExpired = false;
        this.onActiveCallbacks = [];
        this.onIdleCallbacks = [];
        this.externalActiveChecks = [];
        this.setIdleDebounce = null;
        this.isHalted = false;
        if (idleTimeoutMsOveride) {
            this.idleTimeoutMs = idleTimeoutMsOveride;
        }
    }
    ActivityMonitor.prototype.Start = function () {
        this.onStart();
    };
    ActivityMonitor.prototype.Stop = function () {
        this.onHalt();
    };
    ActivityMonitor.prototype.isActive = function () {
        return this.active;
    };
    ActivityMonitor.prototype.addIdleCallback = function (callback) {
        this.onIdleCallbacks.push(callback);
    };
    ActivityMonitor.prototype.addActiveCallback = function (callback) {
        this.onActiveCallbacks.push(callback);
    };
    ActivityMonitor.prototype.addIdlePrecheck = function (callback) {
        this.externalActiveChecks.push(callback);
    };
    ActivityMonitor.prototype.onStart = function () {
        var _this = this;
        this.setEventNames();
        this.initEvents();
        this.triggerUserActive('onStart');
        this.visibilityCheckInterval = this.windowRef.setInterval(function () {
            try {
                _this.checkIdleTimeout();
            }
            catch (ex) {
            }
        }, this.visibilityCheckIntervalMs);
        this.isHalted = false;
    };
    ActivityMonitor.prototype.onHalt = function () {
        console.log('Halting - Activity Monitor');
        this.isHalted = true;
        this.clearIdleDebounce();
        if (this.visibilityCheckInterval) {
            this.windowRef.clearInterval(this.visibilityCheckInterval);
            this.visibilityCheckInterval = null;
        }
        this.triggerUserIdle('Halting');
        if (this.startId) {
            this.startId.remove();
            this.startId = null;
        }
        if (this.haltId) {
            this.haltId.remove();
            this.haltId = null;
        }
        if (this.visibilityAPIFunction) {
            this.windowRef.document.removeEventListener(this.visibilityChangeEventName, this.visibilityAPIFunction);
            this.visibilityAPIFunction = null;
        }
        if (this.windowBlurFunction) {
            this.windowRef.removeEventListener('blur', this.windowBlurFunction);
            this.windowBlurFunction = null;
        }
        if (this.windowFocusFunction) {
            this.windowRef.removeEventListener('focus', this.windowFocusFunction);
            this.windowFocusFunction = null;
        }
        if (this.resetIdleCountdownFunction) {
            this.windowRef.document.removeEventListener('mousemove', this.resetIdleCountdownFunction);
            this.windowRef.document.removeEventListener('keyup', this.resetIdleCountdownFunction);
            this.windowRef.document.removeEventListener('touchstart', this.resetIdleCountdownFunction);
            this.windowRef.removeEventListener('scroll', this.resetIdleCountdownFunction);
            this.resetIdleCountdownFunction = null;
        }
    };
    ActivityMonitor.prototype.checkIdleTimeout = function () {
        var overTimeLimit = this.currentIdleTimeMs > this.idleTimeoutMs;
        if (this.idleTimeoutExpired === false && overTimeLimit) {
            this.idleTimeoutExpired = true;
            this.triggerUserIdle('Idle Timeout');
        }
        else {
            if (overTimeLimit && this.active && this.setIdleDebounce === null) {
                this.triggerUserIdle('still active and over idle time');
            }
            this.currentIdleTimeMs += this.visibilityCheckIntervalMs;
        }
    };
    ActivityMonitor.prototype.setEventNames = function () {
        if (typeof this.windowRef.document.hidden !== 'undefined') {
            this.hiddenPropName = 'hidden';
            this.visibilityChangeEventName = 'visibilitychange';
        }
        else if (typeof this.windowRef.document.msHidden !== 'undefined') {
            this.hiddenPropName = 'msHidden';
            this.visibilityChangeEventName = 'msvisibilitychange';
        }
        else if (typeof this.windowRef.document.webkitHidden !== 'undefined') {
            this.hiddenPropName = 'webkitHidden';
            this.visibilityChangeEventName = 'webkitvisibilitychange';
        }
    };
    ActivityMonitor.prototype.initEvents = function () {
        var _this = this;
        this.visibilityAPIFunction = function () {
            var _a;
            try {
                if (_this.windowRef.document[_this.hiddenPropName]) {
                    _this.triggerUserIdle('Document Visibility API');
                }
                else {
                    _this.triggerUserActive('Document Visibility API');
                }
            }
            catch (ex) {
                (_a = _this.ErrorLogger) === null || _a === void 0 ? void 0 : _a.report('ActivityMonitor.visibilityAPIFunction', ex);
            }
        };
        this.windowRef.document.addEventListener(this.visibilityChangeEventName, this.visibilityAPIFunction, false);
        this.windowBlurFunction = function (e) {
            var _a;
            try {
                if (!_this.isIframeActive()) {
                    _this.triggerUserIdle('Window Blur');
                }
            }
            catch (ex) {
                (_a = _this.ErrorLogger) === null || _a === void 0 ? void 0 : _a.report('ActivityMonitor.windowBlurFunction', ex);
            }
        };
        this.windowRef.addEventListener('blur', this.windowBlurFunction);
        this.windowFocusFunction = function () {
            var _a;
            try {
                _this.triggerUserActive('Window Focus');
            }
            catch (ex) {
                (_a = _this.ErrorLogger) === null || _a === void 0 ? void 0 : _a.report('ActivityMonitor.windowFocusFunction', ex);
            }
        };
        this.windowRef.addEventListener('focus', this.windowFocusFunction);
        this.resetIdleCountdownFunction = function (e) {
            var _a;
            try {
                _this.resetIdleCountdown(e);
            }
            catch (ex) {
                (_a = _this.ErrorLogger) === null || _a === void 0 ? void 0 : _a.report('ActivityMonitor.resetIdleCountdownFunction', ex);
            }
        };
        this.windowRef.document.addEventListener('mousemove', this.resetIdleCountdownFunction);
        this.windowRef.document.addEventListener('keyup', this.resetIdleCountdownFunction);
        this.windowRef.document.addEventListener('touchstart', this.resetIdleCountdownFunction);
        this.windowRef.addEventListener('scroll', this.resetIdleCountdownFunction);
    };
    ActivityMonitor.prototype.triggerUserActive = function (src) {
        var _a, _b;
        this.clearIdleDebounce();
        if (this.active)
            return;
        console.log('User became active', src);
        for (var i = 0; i < this.onActiveCallbacks.length; i++) {
            (_b = (_a = this.onActiveCallbacks)[i]) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
        this.active = true;
    };
    ActivityMonitor.prototype.triggerUserIdle = function (src) {
        var _this = this;
        console.log("attempting to set user idle... w/ " + (src || 'unknown'));
        if (!this.active) {
            console.log('not triggering idle because we are already inactive');
            return;
        }
        this.clearIdleDebounce();
        this.setIdleDebounce = this.windowRef.setTimeout(function () {
            var _a, _b, _c, _d, _e, _f;
            var activeCheckLength = (_b = (_a = _this.externalActiveChecks) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
            var shouldAllowIdle = true;
            for (var i = 0; i < activeCheckLength && shouldAllowIdle; i++) {
                try {
                    if (((_d = (_c = _this.externalActiveChecks)[i]) === null || _d === void 0 ? void 0 : _d.call(_c)) === true)
                        shouldAllowIdle = false;
                }
                catch (error) {
                }
            }
            if (!shouldAllowIdle) {
                _this.clearIdleDebounce();
                return;
            }
            console.log('User gone idle', src);
            for (var i = 0; i < _this.onIdleCallbacks.length; i++) {
                (_f = (_e = _this.onIdleCallbacks)[i]) === null || _f === void 0 ? void 0 : _f.call(_e);
            }
            _this.active = false;
        }, 500);
    };
    ActivityMonitor.prototype.resetIdleCountdown = function (e) {
        if (this.idleTimeoutExpired) {
            this.triggerUserActive(e.type);
        }
        this.idleTimeoutExpired = false;
        this.currentIdleTimeMs = 0;
    };
    ActivityMonitor.prototype.isIframeActive = function () {
        return (this.windowRef.document.activeElement && (this.windowRef.document.activeElement.tagName || '').toUpperCase() === 'IFRAME');
    };
    ActivityMonitor.prototype.clearIdleDebounce = function () {
        this.windowRef.clearTimeout(this.setIdleDebounce);
        this.setIdleDebounce = null;
    };
    return ActivityMonitor;
}());
exports.ActivityMonitor = ActivityMonitor;
//# sourceMappingURL=ActivityMonitor.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/classes/PubSuber.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/classes/PubSuber.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PubSuber = exports.PubSubSubscription = exports.PubSubMessage = void 0;
var core_utils_1 = __webpack_require__(/*! ../utils/core-utils */ "./node_modules/@churnzero/clientlibs/dist/main/utils/core-utils.js");
var PubSubMessage = (function () {
    function PubSubMessage() {
    }
    return PubSubMessage;
}());
exports.PubSubMessage = PubSubMessage;
var PubSubSubscription = (function () {
    function PubSubSubscription() {
    }
    return PubSubSubscription;
}());
exports.PubSubSubscription = PubSubSubscription;
var PubSuber = (function () {
    function PubSuber(ErrorLogger) {
        this.ErrorLogger = ErrorLogger;
        this.sourceId = this.guid();
        this.topics = {};
        this.mirrors = [];
    }
    PubSuber.prototype.guid = function () {
        function s4() {
            return Math.floor((1 + Math.random()) * 0x10000)
                .toString(16)
                .substring(1);
        }
        return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
    };
    PubSuber.prototype.addMirror = function (mirror) {
        var _this = this;
        var len = this.mirrors.push(mirror);
        var index = len - 1;
        return {
            remove: function () {
                delete _this.mirrors[index];
            }
        };
    };
    PubSuber.prototype.subscribe = function (topic, listener) {
        var _this = this;
        if (!core_utils_1.CoreUtils.hasOwnProp(this.topics, topic))
            this.topics[topic] = [];
        var index = this.topics[topic].push(listener) - 1;
        return {
            remove: function () {
                try {
                    delete _this.topics[topic][index];
                }
                catch (ex) {
                    if (!_this.ErrorLogger) {
                        console.error(ex);
                        return;
                    }
                    _this.ErrorLogger.report('PubSuber.remove', ex);
                }
            }
        };
    };
    PubSuber.prototype.publish = function (topic, info, isMirroredEvent, sourceId) {
        if (isMirroredEvent === void 0) { isMirroredEvent = false; }
        if (sourceId === void 0) { sourceId = this.sourceId; }
        var topicExists = core_utils_1.CoreUtils.hasOwnProp(this.topics, topic);
        if (!topicExists && this.mirrors.length === 0)
            return;
        var message = {
            sourceId: this.sourceId,
            topic: topic,
            info: info
        }, self = this;
        var isOtherSource = sourceId !== this.sourceId;
        if (topicExists) {
            this.topics[topic].forEach(function (item, index, array) {
                if (item === null || item === undefined) {
                    return;
                }
                if (!isMirroredEvent || isOtherSource) {
                    try {
                        item(message);
                    }
                    catch (ex) {
                        if (!self.ErrorLogger) {
                            console.error(ex);
                            return;
                        }
                        if (self.ErrorLogger.isFreedScriptError(ex)) {
                            array[index] = undefined;
                        }
                        else {
                            self.ErrorLogger.report('PubSuber.publish.' + topic, ex);
                        }
                    }
                }
            });
        }
        if (!isMirroredEvent && this.mirrors.length) {
            this.mirrors.forEach(function (mirror, index, array) {
                if (mirror === null || mirror === undefined) {
                    return;
                }
                try {
                    mirror(message);
                }
                catch (ex) {
                    if (!self.ErrorLogger) {
                        console.error(ex);
                        return;
                    }
                    if (self.ErrorLogger.isFreedScriptError(ex)) {
                        array[index] = undefined;
                    }
                    else {
                        self.ErrorLogger.report('PubSuber.publishMirrored.' + topic, ex);
                    }
                }
            });
        }
    };
    PubSuber.prototype.publishMirrored = function (message) {
        this.publish(message.topic, message.info, true, message.sourceId);
    };
    PubSuber.removeAll = function (subIds) {
        for (var key in subIds) {
            if (!core_utils_1.CoreUtils.hasOwnProp(subIds, key)) {
                continue;
            }
            if (subIds[key]) {
                subIds[key].remove();
                subIds[key] = null;
            }
        }
    };
    return PubSuber;
}());
exports.PubSuber = PubSuber;
//# sourceMappingURL=PubSuber.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/constants/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/constants/index.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./regexes */ "./node_modules/@churnzero/clientlibs/dist/main/constants/regexes.js"), exports);
__exportStar(__webpack_require__(/*! ./strings */ "./node_modules/@churnzero/clientlibs/dist/main/constants/strings.js"), exports);
__exportStar(__webpack_require__(/*! ./style-config/global-style-config */ "./node_modules/@churnzero/clientlibs/dist/main/constants/style-config/global-style-config.js"), exports);
__exportStar(__webpack_require__(/*! ./style-config/success-center-config-values */ "./node_modules/@churnzero/clientlibs/dist/main/constants/style-config/success-center-config-values.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/constants/regexes.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/constants/regexes.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.urlPathChars = exports.semiColonDelimiter = exports.fullStop = void 0;
var fullStop = '\\z|$', semiColonDelimiter = ';', urlPathChars = '[a-zA-Z0-9\\.\\-_~\\$&\'()*+,;=:@%]*';
exports.fullStop = fullStop;
exports.semiColonDelimiter = semiColonDelimiter;
exports.urlPathChars = urlPathChars;
//# sourceMappingURL=regexes.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/constants/strings.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/constants/strings.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.questionMark = exports.hashBang = exports.hashSymbol = exports.semiColon = exports.colon = exports.ampersand = exports.emptyString = exports.escapedSlash = exports.slash = void 0;
var emptyString = '', slash = '/', escapedSlash = '\\/', ampersand = '&', colon = ':', semiColon = ';', hashSymbol = '#', hashBang = '#!', questionMark = '?';
exports.emptyString = emptyString;
exports.slash = slash;
exports.escapedSlash = escapedSlash;
exports.ampersand = ampersand;
exports.colon = colon;
exports.semiColon = semiColon;
exports.hashSymbol = hashSymbol;
exports.hashBang = hashBang;
exports.questionMark = questionMark;
//# sourceMappingURL=strings.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/constants/style-config/global-style-config.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/constants/style-config/global-style-config.js ***!
  \****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GLOBAL_CHECKLIST_SETTINGS_CONFIG_TENANT_ITEM_NAME = exports.CZ_DEFAULT_CHECKLIST_SETTINGS_CONFIG = exports.CZ_DEFAULT_ANNOUNCEMENT_STYLE_CONFIG = exports.GLOBAL_ANNOUNCEMENTS_STYLE_CONFIG_TENANT_ITEM_NAME = exports.GLOBAL_STYLE_CONFIG_TENANT_ITEM_NAME = exports.CZ_DEFAULT_STYLE_CONFIG = void 0;
var enums_1 = __webpack_require__(/*! ../../enums */ "./node_modules/@churnzero/clientlibs/dist/main/enums.js");
var walkthrough_style_config_1 = __webpack_require__(/*! ../../models/walkthrough/walkthrough-style-config */ "./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-style-config.js");
var announcement_style_config_1 = __webpack_require__(/*! ../../models/announcement/announcement-style-config */ "./node_modules/@churnzero/clientlibs/dist/main/models/announcement/announcement-style-config.js");
var checklist_settings_config_1 = __webpack_require__(/*! ../../models/checklist/checklist-settings-config */ "./node_modules/@churnzero/clientlibs/dist/main/models/checklist/checklist-settings-config.js");
var CZ_DEFAULT_STYLE_CONFIG = new walkthrough_style_config_1.WalkthroughStyleConfig();
exports.CZ_DEFAULT_STYLE_CONFIG = CZ_DEFAULT_STYLE_CONFIG;
CZ_DEFAULT_STYLE_CONFIG.fontSize = 14;
CZ_DEFAULT_STYLE_CONFIG.fontFamily = 'Arial,Helvetica,sans-serif';
CZ_DEFAULT_STYLE_CONFIG.textAlignment = 'center';
CZ_DEFAULT_STYLE_CONFIG.backgroundColor = '#ffffff';
CZ_DEFAULT_STYLE_CONFIG.fontColor = '#000000';
CZ_DEFAULT_STYLE_CONFIG.borderRadius = 5;
CZ_DEFAULT_STYLE_CONFIG.borderWidth = 0;
CZ_DEFAULT_STYLE_CONFIG.borderColor = '#ffffff';
CZ_DEFAULT_STYLE_CONFIG.shouldHideClose = false;
CZ_DEFAULT_STYLE_CONFIG.closeColor = '#000000';
CZ_DEFAULT_STYLE_CONFIG.closeHoverColor = undefined;
CZ_DEFAULT_STYLE_CONFIG.shouldShowStepNumber = false;
CZ_DEFAULT_STYLE_CONFIG.stepNumberPosition = enums_1.StepNumberPosition.TopLeft;
CZ_DEFAULT_STYLE_CONFIG.stepNumberColor = '#000000';
CZ_DEFAULT_STYLE_CONFIG.shouldShowPrevStep = false;
CZ_DEFAULT_STYLE_CONFIG.anchorZIndex = 999997;
CZ_DEFAULT_STYLE_CONFIG.ctaText = 'Got it!';
CZ_DEFAULT_STYLE_CONFIG.ctaFontSize = 14;
CZ_DEFAULT_STYLE_CONFIG.ctaFontFamily = 'Arial,Helvetica,sans-serif';
CZ_DEFAULT_STYLE_CONFIG.ctaAlignment = 'center';
CZ_DEFAULT_STYLE_CONFIG.ctaBackgroundColor = '#cccccc';
CZ_DEFAULT_STYLE_CONFIG.ctaTextColor = '#000000';
CZ_DEFAULT_STYLE_CONFIG.ctaButtonColor = '#ffffff';
CZ_DEFAULT_STYLE_CONFIG.ctaButtonBorderColor = '#ffffff';
CZ_DEFAULT_STYLE_CONFIG.ctaButtonHoverColor = undefined;
CZ_DEFAULT_STYLE_CONFIG.uiFontFamilyIds = undefined;
CZ_DEFAULT_STYLE_CONFIG.popupWidth = enums_1.StyleConfigPopUpWidth.Small;
CZ_DEFAULT_STYLE_CONFIG.sliderWidth = enums_1.StyleConfigSliderWidth.Small;
CZ_DEFAULT_STYLE_CONFIG.tooltipWidth = enums_1.StyleConfigTooltipWidth.Small;
CZ_DEFAULT_STYLE_CONFIG.prevStepText = 'Previous';
CZ_DEFAULT_STYLE_CONFIG.prevStepFontSize = 14;
CZ_DEFAULT_STYLE_CONFIG.prevStepFontFamilyId = 1;
CZ_DEFAULT_STYLE_CONFIG.prevStepAlignment = 'center';
CZ_DEFAULT_STYLE_CONFIG.prevStepTextColor = '#007bff';
CZ_DEFAULT_STYLE_CONFIG.prevStepButtonColor = 'transparent';
CZ_DEFAULT_STYLE_CONFIG.prevStepButtonBorderColor = 'transparent';
CZ_DEFAULT_STYLE_CONFIG.prevStepButtonHoverColor = undefined;
var CZ_DEFAULT_ANNOUNCEMENT_STYLE_CONFIG = new announcement_style_config_1.AnnouncementStyleConfig();
exports.CZ_DEFAULT_ANNOUNCEMENT_STYLE_CONFIG = CZ_DEFAULT_ANNOUNCEMENT_STYLE_CONFIG;
CZ_DEFAULT_ANNOUNCEMENT_STYLE_CONFIG.fontSize = 14;
CZ_DEFAULT_ANNOUNCEMENT_STYLE_CONFIG.fontFamily = 'Arial,Helvetica,sans-serif';
CZ_DEFAULT_ANNOUNCEMENT_STYLE_CONFIG.textAlignment = 'center';
CZ_DEFAULT_ANNOUNCEMENT_STYLE_CONFIG.backgroundColor = '#ffffff';
CZ_DEFAULT_ANNOUNCEMENT_STYLE_CONFIG.fontColor = '#000000';
CZ_DEFAULT_ANNOUNCEMENT_STYLE_CONFIG.borderRadius = 5;
CZ_DEFAULT_ANNOUNCEMENT_STYLE_CONFIG.borderWidth = 0;
CZ_DEFAULT_ANNOUNCEMENT_STYLE_CONFIG.borderColor = '#ffffff';
CZ_DEFAULT_ANNOUNCEMENT_STYLE_CONFIG.closeColor = '#000000';
CZ_DEFAULT_ANNOUNCEMENT_STYLE_CONFIG.closeHoverColor = undefined;
CZ_DEFAULT_ANNOUNCEMENT_STYLE_CONFIG.uiFontFamilyIds = undefined;
CZ_DEFAULT_ANNOUNCEMENT_STYLE_CONFIG.popupWidth = enums_1.StyleConfigPopUpWidth.Small;
CZ_DEFAULT_ANNOUNCEMENT_STYLE_CONFIG.sliderWidth = enums_1.StyleConfigSliderWidth.Small;
var CZ_DEFAULT_CHECKLIST_SETTINGS_CONFIG = new checklist_settings_config_1.ChecklistSettingsConfig();
exports.CZ_DEFAULT_CHECKLIST_SETTINGS_CONFIG = CZ_DEFAULT_CHECKLIST_SETTINGS_CONFIG;
CZ_DEFAULT_CHECKLIST_SETTINGS_CONFIG.launchIconPosition = enums_1.LaunchIconPosition.BottomRight;
CZ_DEFAULT_CHECKLIST_SETTINGS_CONFIG.launchIconType = enums_1.LaunchIconType.Float;
CZ_DEFAULT_CHECKLIST_SETTINGS_CONFIG.titleFontSize = 16;
CZ_DEFAULT_CHECKLIST_SETTINGS_CONFIG.itemFontSize = 14;
CZ_DEFAULT_CHECKLIST_SETTINGS_CONFIG.fontFamilyId = 'Arial';
CZ_DEFAULT_CHECKLIST_SETTINGS_CONFIG.textAlignment = 'left';
CZ_DEFAULT_CHECKLIST_SETTINGS_CONFIG.color = '#000';
CZ_DEFAULT_CHECKLIST_SETTINGS_CONFIG.hyperlinkColor = '#218bc3';
CZ_DEFAULT_CHECKLIST_SETTINGS_CONFIG.backgroundColor = '#fff';
CZ_DEFAULT_CHECKLIST_SETTINGS_CONFIG.markAsCompleteBackgroundColor = '#e8e8e8';
CZ_DEFAULT_CHECKLIST_SETTINGS_CONFIG.markAsCompleteTextColor = '#000';
CZ_DEFAULT_CHECKLIST_SETTINGS_CONFIG.completeButtonBackgroundColor = '#64bd63';
CZ_DEFAULT_CHECKLIST_SETTINGS_CONFIG.completeButtonTextColor = '#fff';
CZ_DEFAULT_CHECKLIST_SETTINGS_CONFIG.completeMessageBackgroundColor = '#b6d7a8';
CZ_DEFAULT_CHECKLIST_SETTINGS_CONFIG.completeMessageTextColor = '#000';
CZ_DEFAULT_CHECKLIST_SETTINGS_CONFIG.launcherBackgroundColor = '#fff';
CZ_DEFAULT_CHECKLIST_SETTINGS_CONFIG.progressRemainingColor = '#dedede';
CZ_DEFAULT_CHECKLIST_SETTINGS_CONFIG.progressCompleteColor = '#218bc3';
CZ_DEFAULT_CHECKLIST_SETTINGS_CONFIG.progressBackgroundColor = '#fff';
CZ_DEFAULT_CHECKLIST_SETTINGS_CONFIG.progressTextColor = '#000';
var GLOBAL_STYLE_CONFIG_TENANT_ITEM_NAME = 'GlobalStyleConfig';
exports.GLOBAL_STYLE_CONFIG_TENANT_ITEM_NAME = GLOBAL_STYLE_CONFIG_TENANT_ITEM_NAME;
var GLOBAL_ANNOUNCEMENTS_STYLE_CONFIG_TENANT_ITEM_NAME = 'AnnouncementsGlobalStyleConfig';
exports.GLOBAL_ANNOUNCEMENTS_STYLE_CONFIG_TENANT_ITEM_NAME = GLOBAL_ANNOUNCEMENTS_STYLE_CONFIG_TENANT_ITEM_NAME;
var GLOBAL_CHECKLIST_SETTINGS_CONFIG_TENANT_ITEM_NAME = 'ChecklistSettingsGlobalConfig';
exports.GLOBAL_CHECKLIST_SETTINGS_CONFIG_TENANT_ITEM_NAME = GLOBAL_CHECKLIST_SETTINGS_CONFIG_TENANT_ITEM_NAME;
//# sourceMappingURL=global-style-config.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/constants/style-config/success-center-config-values.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/constants/style-config/success-center-config-values.js ***!
  \*************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SUCCESS_CENTER_DEFAULT_WIDTH_UNIT = exports.SUCCESS_CENTER_DEFAULT_WIDTH = void 0;
var enums_1 = __webpack_require__(/*! ../../enums */ "./node_modules/@churnzero/clientlibs/dist/main/enums.js");
exports.SUCCESS_CENTER_DEFAULT_WIDTH = 800;
exports.SUCCESS_CENTER_DEFAULT_WIDTH_UNIT = enums_1.WidthUnitType.Pixels;
//# sourceMappingURL=success-center-config-values.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/enums.js":
/*!***************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/enums.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WidthUnitType = exports.InAppOverlayPosition = exports.SuccessCenterLocation = exports.UIPosition = exports.LaunchAvatarType = exports.LaunchTrigger = exports.LaunchIconType = exports.LaunchIconPosition = exports.StyleConfigTooltipWidth = exports.StyleConfigSliderWidth = exports.StyleConfigPopUpWidth = exports.StepNumberPosition = exports.ContainerType = exports.AnchorActionType = exports.WalkthroughTriggerType = exports.WalkthroughActionType = exports.TooltipPosition = exports.AnnouncementPosition = exports.SocketMessageTypes = exports.DevlessEvents = exports.InterfaceCommCodes = exports.FrameCommCodes = exports.ChurnZeroAppEvents = exports.TransportCodes = exports.SelectorTypes = exports.LocationTypes = exports.EventTypes = exports.AnnouncementType = void 0;
var AnnouncementType_1 = __webpack_require__(/*! ./enums/AnnouncementType */ "./node_modules/@churnzero/clientlibs/dist/main/enums/AnnouncementType.js");
Object.defineProperty(exports, "AnnouncementType", ({ enumerable: true, get: function () { return AnnouncementType_1.AnnouncementType; } }));
var EventTypes;
(function (EventTypes) {
    EventTypes[EventTypes["Mapped"] = 1] = "Mapped";
    EventTypes[EventTypes["Unmapped"] = 2] = "Unmapped";
})(EventTypes = exports.EventTypes || (exports.EventTypes = {}));
var LocationTypes;
(function (LocationTypes) {
    LocationTypes[LocationTypes["Site"] = 1] = "Site";
    LocationTypes[LocationTypes["Page"] = 2] = "Page";
})(LocationTypes = exports.LocationTypes || (exports.LocationTypes = {}));
var SelectorTypes;
(function (SelectorTypes) {
    SelectorTypes[SelectorTypes["Suggested"] = 1] = "Suggested";
    SelectorTypes[SelectorTypes["Custom"] = 2] = "Custom";
    SelectorTypes[SelectorTypes["Intermediate"] = 3] = "Intermediate";
})(SelectorTypes = exports.SelectorTypes || (exports.SelectorTypes = {}));
var TransportCodes;
(function (TransportCodes) {
    TransportCodes[TransportCodes["PubSubMirror"] = 1] = "PubSubMirror";
    TransportCodes[TransportCodes["FrameComm"] = 2] = "FrameComm";
    TransportCodes[TransportCodes["WalkthroughClickAudit"] = 3] = "WalkthroughClickAudit";
    TransportCodes[TransportCodes["AnnouncementFrameComm"] = 4] = "AnnouncementFrameComm";
    TransportCodes[TransportCodes["InterfaceComm"] = 5] = "InterfaceComm";
})(TransportCodes = exports.TransportCodes || (exports.TransportCodes = {}));
var ChurnZeroAppEvents;
(function (ChurnZeroAppEvents) {
    ChurnZeroAppEvents[ChurnZeroAppEvents["DIGEST"] = 1] = "DIGEST";
    ChurnZeroAppEvents[ChurnZeroAppEvents["HALT"] = 2] = "HALT";
    ChurnZeroAppEvents[ChurnZeroAppEvents["START"] = 3] = "START";
    ChurnZeroAppEvents[ChurnZeroAppEvents["PanelReady"] = 4] = "PanelReady";
    ChurnZeroAppEvents[ChurnZeroAppEvents["PanelShow"] = 5] = "PanelShow";
    ChurnZeroAppEvents[ChurnZeroAppEvents["PanelHide"] = 6] = "PanelHide";
    ChurnZeroAppEvents[ChurnZeroAppEvents["ChangePollInterval"] = 7] = "ChangePollInterval";
    ChurnZeroAppEvents[ChurnZeroAppEvents["AnnouncementClosed"] = 8] = "AnnouncementClosed";
    ChurnZeroAppEvents[ChurnZeroAppEvents["WalkthroughStart"] = 9] = "WalkthroughStart";
    ChurnZeroAppEvents[ChurnZeroAppEvents["SubframeRegistered"] = 10] = "SubframeRegistered";
    ChurnZeroAppEvents[ChurnZeroAppEvents["JourneyChecklistRefreshed"] = 11] = "JourneyChecklistRefreshed";
    ChurnZeroAppEvents[ChurnZeroAppEvents["PanelLauncherReady"] = 12] = "PanelLauncherReady";
    ChurnZeroAppEvents[ChurnZeroAppEvents["SuccessCenterReady"] = 13] = "SuccessCenterReady";
    ChurnZeroAppEvents[ChurnZeroAppEvents["NewAnnouncement"] = 14] = "NewAnnouncement";
    ChurnZeroAppEvents[ChurnZeroAppEvents["ExpireAnnouncement"] = 15] = "ExpireAnnouncement";
    ChurnZeroAppEvents[ChurnZeroAppEvents["ActivityMonitorActive"] = 16] = "ActivityMonitorActive";
    ChurnZeroAppEvents[ChurnZeroAppEvents["ActivityMonitorIdle"] = 17] = "ActivityMonitorIdle";
    ChurnZeroAppEvents[ChurnZeroAppEvents["ActivityMonitorHalt"] = 18] = "ActivityMonitorHalt";
})(ChurnZeroAppEvents = exports.ChurnZeroAppEvents || (exports.ChurnZeroAppEvents = {}));
var FrameCommCodes;
(function (FrameCommCodes) {
    FrameCommCodes[FrameCommCodes["SubframeBoot"] = 1001] = "SubframeBoot";
    FrameCommCodes[FrameCommCodes["SubframeBootResponse"] = 1002] = "SubframeBootResponse";
    FrameCommCodes[FrameCommCodes["SubFramePassback"] = 1003] = "SubFramePassback";
    FrameCommCodes[FrameCommCodes["MasterFrameComRePublish"] = 1004] = "MasterFrameComRePublish";
    FrameCommCodes[FrameCommCodes["MasterFramePassdown"] = 1005] = "MasterFramePassdown";
})(FrameCommCodes = exports.FrameCommCodes || (exports.FrameCommCodes = {}));
var InterfaceCommCodes;
(function (InterfaceCommCodes) {
    InterfaceCommCodes[InterfaceCommCodes["SuccessCenterToggle"] = 5001] = "SuccessCenterToggle";
    InterfaceCommCodes[InterfaceCommCodes["WalkthroughClickAudit"] = 5002] = "WalkthroughClickAudit";
    InterfaceCommCodes[InterfaceCommCodes["AnnouncementClickAudit"] = 5003] = "AnnouncementClickAudit";
    InterfaceCommCodes[InterfaceCommCodes["NpsAnnouncementLinkClicked"] = 5004] = "NpsAnnouncementLinkClicked";
    InterfaceCommCodes[InterfaceCommCodes["SuccessCenterSetStyles"] = 5005] = "SuccessCenterSetStyles";
    InterfaceCommCodes[InterfaceCommCodes["SuccessCenterSetSocketContext"] = 5006] = "SuccessCenterSetSocketContext";
    InterfaceCommCodes[InterfaceCommCodes["SuccessCenterUpdateUnreadBadge"] = 5007] = "SuccessCenterUpdateUnreadBadge";
    InterfaceCommCodes[InterfaceCommCodes["AnnouncementMarkAsRead"] = 5008] = "AnnouncementMarkAsRead";
})(InterfaceCommCodes = exports.InterfaceCommCodes || (exports.InterfaceCommCodes = {}));
var DevlessEvents;
(function (DevlessEvents) {
    DevlessEvents[DevlessEvents["DevlessInit"] = 2001] = "DevlessInit";
    DevlessEvents[DevlessEvents["DevlessConnectionInfo"] = 2002] = "DevlessConnectionInfo";
    DevlessEvents[DevlessEvents["DevlessShow"] = 2003] = "DevlessShow";
    DevlessEvents[DevlessEvents["DevlessHide"] = 2004] = "DevlessHide";
    DevlessEvents[DevlessEvents["DevlessResize"] = 2005] = "DevlessResize";
    DevlessEvents[DevlessEvents["DevlessIframeResized"] = 2006] = "DevlessIframeResized";
    DevlessEvents[DevlessEvents["DevlessElementExistsCheck"] = 2007] = "DevlessElementExistsCheck";
    DevlessEvents[DevlessEvents["DevlessElementExistsCheckResponse"] = 2008] = "DevlessElementExistsCheckResponse";
    DevlessEvents[DevlessEvents["DevlessCurrentHref"] = 2009] = "DevlessCurrentHref";
    DevlessEvents[DevlessEvents["DevlessCurrentHrefResponse"] = 2010] = "DevlessCurrentHrefResponse";
    DevlessEvents[DevlessEvents["DevlessPush"] = 2011] = "DevlessPush";
    DevlessEvents[DevlessEvents["ElementFinderStart"] = 2012] = "ElementFinderStart";
    DevlessEvents[DevlessEvents["ElementFinderStop"] = 2013] = "ElementFinderStop";
    DevlessEvents[DevlessEvents["ElementFinderElementSelected"] = 2014] = "ElementFinderElementSelected";
    DevlessEvents[DevlessEvents["ElementFinderHoverUpdate"] = 2015] = "ElementFinderHoverUpdate";
    DevlessEvents[DevlessEvents["ElementFinderHighlightElement"] = 2016] = "ElementFinderHighlightElement";
    DevlessEvents[DevlessEvents["ElementFinderElementHighlighted"] = 2017] = "ElementFinderElementHighlighted";
    DevlessEvents[DevlessEvents["EditorSet"] = 2018] = "EditorSet";
    DevlessEvents[DevlessEvents["EditorChanged"] = 2019] = "EditorChanged";
    DevlessEvents[DevlessEvents["WalkthroughStepPreviewClose"] = 2020] = "WalkthroughStepPreviewClose";
})(DevlessEvents = exports.DevlessEvents || (exports.DevlessEvents = {}));
var SocketMessageTypes;
(function (SocketMessageTypes) {
    SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_DISCONNECT"] = -2] = "SOCKETMESSAGETYPE_DISCONNECT";
    SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_INITIAL_CONNECTION"] = -1] = "SOCKETMESSAGETYPE_INITIAL_CONNECTION";
    SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_ANNOUNCEMENT"] = 1] = "SOCKETMESSAGETYPE_ANNOUNCEMENT";
    SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_USER_ACCOUNT_ALERT"] = 5] = "SOCKETMESSAGETYPE_USER_ACCOUNT_ALERT";
    SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_TRACK_EVENT"] = 6] = "SOCKETMESSAGETYPE_TRACK_EVENT";
    SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_SET_ATTRIBUTE"] = 7] = "SOCKETMESSAGETYPE_SET_ATTRIBUTE";
    SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_IS_ACTIVE"] = 8] = "SOCKETMESSAGETYPE_IS_ACTIVE";
    SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_MESSAGE_READ"] = 9] = "SOCKETMESSAGETYPE_MESSAGE_READ";
    SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_MESSAGE_CLICKED"] = 10] = "SOCKETMESSAGETYPE_MESSAGE_CLICKED";
    SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_CHECK_ONLINE"] = 11] = "SOCKETMESSAGETYPE_CHECK_ONLINE";
    SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_CHECK_ONLINE_RESULT"] = 12] = "SOCKETMESSAGETYPE_CHECK_ONLINE_RESULT";
    SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_UPDATE_APP_VERSION"] = 13] = "SOCKETMESSAGETYPE_UPDATE_APP_VERSION";
    SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_EXPIRE_MESSAGE"] = 14] = "SOCKETMESSAGETYPE_EXPIRE_MESSAGE";
    SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_CHECK_EVENT_MAP_CONFIG_VERSION"] = 15] = "SOCKETMESSAGETYPE_CHECK_EVENT_MAP_CONFIG_VERSION";
    SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_REFRESH_EVENT_MAP_CONFIG"] = 16] = "SOCKETMESSAGETYPE_REFRESH_EVENT_MAP_CONFIG";
    SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_TIME_IN_APP"] = 17] = "SOCKETMESSAGETYPE_TIME_IN_APP";
    SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_CheckWalkthroughConfigVersion"] = 18] = "SOCKETMESSAGETYPE_CheckWalkthroughConfigVersion";
    SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_RefreshWalkthroughConfig"] = 19] = "SOCKETMESSAGETYPE_RefreshWalkthroughConfig";
    SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_WalkthroughAction"] = 20] = "SOCKETMESSAGETYPE_WalkthroughAction";
    SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_CheckPageTagConfigVersion"] = 21] = "SOCKETMESSAGETYPE_CheckPageTagConfigVersion";
    SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_RefreshPageTagConfig"] = 22] = "SOCKETMESSAGETYPE_RefreshPageTagConfig";
    SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_CheckChecklistConfigVersion"] = 23] = "SOCKETMESSAGETYPE_CheckChecklistConfigVersion";
    SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_RefreshChecklistConfig"] = 24] = "SOCKETMESSAGETYPE_RefreshChecklistConfig";
    SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_ChecklistItemToggle"] = 25] = "SOCKETMESSAGETYPE_ChecklistItemToggle";
    SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_ChecklistMarkComplete"] = 26] = "SOCKETMESSAGETYPE_ChecklistMarkComplete";
})(SocketMessageTypes = exports.SocketMessageTypes || (exports.SocketMessageTypes = {}));
var AnnouncementPosition;
(function (AnnouncementPosition) {
    AnnouncementPosition[AnnouncementPosition["PanelOnly"] = 1] = "PanelOnly";
    AnnouncementPosition[AnnouncementPosition["PopUp"] = 2] = "PopUp";
    AnnouncementPosition[AnnouncementPosition["SlideBottomCenter"] = 3] = "SlideBottomCenter";
    AnnouncementPosition[AnnouncementPosition["SlideLeftBottom"] = 4] = "SlideLeftBottom";
    AnnouncementPosition[AnnouncementPosition["SlideTopLeft"] = 5] = "SlideTopLeft";
    AnnouncementPosition[AnnouncementPosition["SlideTopCenter"] = 6] = "SlideTopCenter";
    AnnouncementPosition[AnnouncementPosition["SlideTopRight"] = 7] = "SlideTopRight";
    AnnouncementPosition[AnnouncementPosition["SlideBottomLeft"] = 8] = "SlideBottomLeft";
    AnnouncementPosition[AnnouncementPosition["SlideBottomRight"] = 9] = "SlideBottomRight";
    AnnouncementPosition[AnnouncementPosition["SlideLeftTop"] = 10] = "SlideLeftTop";
    AnnouncementPosition[AnnouncementPosition["SlideLeftCenter"] = 11] = "SlideLeftCenter";
    AnnouncementPosition[AnnouncementPosition["SlideRightTop"] = 12] = "SlideRightTop";
    AnnouncementPosition[AnnouncementPosition["SlideRightCenter"] = 13] = "SlideRightCenter";
    AnnouncementPosition[AnnouncementPosition["SlideRightBottom"] = 14] = "SlideRightBottom";
    AnnouncementPosition[AnnouncementPosition["Tooltip"] = 15] = "Tooltip";
})(AnnouncementPosition = exports.AnnouncementPosition || (exports.AnnouncementPosition = {}));
var TooltipPosition;
(function (TooltipPosition) {
    TooltipPosition[TooltipPosition["Auto"] = 1] = "Auto";
    TooltipPosition[TooltipPosition["Top"] = 2] = "Top";
    TooltipPosition[TooltipPosition["Left"] = 3] = "Left";
    TooltipPosition[TooltipPosition["Bottom"] = 4] = "Bottom";
    TooltipPosition[TooltipPosition["Right"] = 5] = "Right";
})(TooltipPosition = exports.TooltipPosition || (exports.TooltipPosition = {}));
var WalkthroughActionType;
(function (WalkthroughActionType) {
    WalkthroughActionType[WalkthroughActionType["Unknown"] = 0] = "Unknown";
    WalkthroughActionType[WalkthroughActionType["WalkthroughStarted"] = 1] = "WalkthroughStarted";
    WalkthroughActionType[WalkthroughActionType["StepStarted"] = 2] = "StepStarted";
    WalkthroughActionType[WalkthroughActionType["StepClicked"] = 3] = "StepClicked";
    WalkthroughActionType[WalkthroughActionType["StepCompleted"] = 4] = "StepCompleted";
    WalkthroughActionType[WalkthroughActionType["StepAbandonded"] = 5] = "StepAbandonded";
    WalkthroughActionType[WalkthroughActionType["WalkthroughCompleted"] = 6] = "WalkthroughCompleted";
    WalkthroughActionType[WalkthroughActionType["WalkthroughAbandoned"] = 7] = "WalkthroughAbandoned";
    WalkthroughActionType[WalkthroughActionType["WalkthroughResumed"] = 8] = "WalkthroughResumed";
    WalkthroughActionType[WalkthroughActionType["StepRevisited"] = 9] = "StepRevisited";
})(WalkthroughActionType = exports.WalkthroughActionType || (exports.WalkthroughActionType = {}));
var WalkthroughTriggerType;
(function (WalkthroughTriggerType) {
    WalkthroughTriggerType[WalkthroughTriggerType["Click"] = 1] = "Click";
    WalkthroughTriggerType[WalkthroughTriggerType["PageVisit"] = 2] = "PageVisit";
    WalkthroughTriggerType[WalkthroughTriggerType["Event"] = 3] = "Event";
    WalkthroughTriggerType[WalkthroughTriggerType["Anchor"] = 4] = "Anchor";
})(WalkthroughTriggerType = exports.WalkthroughTriggerType || (exports.WalkthroughTriggerType = {}));
var AnchorActionType;
(function (AnchorActionType) {
    AnchorActionType[AnchorActionType["Click"] = 1] = "Click";
    AnchorActionType[AnchorActionType["Hover"] = 2] = "Hover";
})(AnchorActionType = exports.AnchorActionType || (exports.AnchorActionType = {}));
var ContainerType;
(function (ContainerType) {
    ContainerType[ContainerType["Body"] = 1] = "Body";
    ContainerType[ContainerType["Parent"] = 2] = "Parent";
})(ContainerType = exports.ContainerType || (exports.ContainerType = {}));
var StepNumberPosition;
(function (StepNumberPosition) {
    StepNumberPosition[StepNumberPosition["TopLeft"] = 0] = "TopLeft";
    StepNumberPosition[StepNumberPosition["TopCenter"] = 1] = "TopCenter";
    StepNumberPosition[StepNumberPosition["TopRight"] = 2] = "TopRight";
    StepNumberPosition[StepNumberPosition["BottomLeft"] = 3] = "BottomLeft";
    StepNumberPosition[StepNumberPosition["BottomCenter"] = 4] = "BottomCenter";
    StepNumberPosition[StepNumberPosition["BottomRight"] = 5] = "BottomRight";
})(StepNumberPosition = exports.StepNumberPosition || (exports.StepNumberPosition = {}));
var StyleConfigPopUpWidth;
(function (StyleConfigPopUpWidth) {
    StyleConfigPopUpWidth[StyleConfigPopUpWidth["Small"] = 340] = "Small";
    StyleConfigPopUpWidth[StyleConfigPopUpWidth["Medium"] = 660] = "Medium";
    StyleConfigPopUpWidth[StyleConfigPopUpWidth["Large"] = 980] = "Large";
})(StyleConfigPopUpWidth = exports.StyleConfigPopUpWidth || (exports.StyleConfigPopUpWidth = {}));
var StyleConfigSliderWidth;
(function (StyleConfigSliderWidth) {
    StyleConfigSliderWidth[StyleConfigSliderWidth["Small"] = 350] = "Small";
    StyleConfigSliderWidth[StyleConfigSliderWidth["Medium"] = 660] = "Medium";
    StyleConfigSliderWidth[StyleConfigSliderWidth["Large"] = 980] = "Large";
})(StyleConfigSliderWidth = exports.StyleConfigSliderWidth || (exports.StyleConfigSliderWidth = {}));
var StyleConfigTooltipWidth;
(function (StyleConfigTooltipWidth) {
    StyleConfigTooltipWidth[StyleConfigTooltipWidth["Small"] = 300] = "Small";
    StyleConfigTooltipWidth[StyleConfigTooltipWidth["Medium"] = 425] = "Medium";
    StyleConfigTooltipWidth[StyleConfigTooltipWidth["Large"] = 550] = "Large";
})(StyleConfigTooltipWidth = exports.StyleConfigTooltipWidth || (exports.StyleConfigTooltipWidth = {}));
var LaunchIconPosition;
(function (LaunchIconPosition) {
    LaunchIconPosition[LaunchIconPosition["TopLeft"] = 0] = "TopLeft";
    LaunchIconPosition[LaunchIconPosition["TopCenter"] = 1] = "TopCenter";
    LaunchIconPosition[LaunchIconPosition["TopRight"] = 2] = "TopRight";
    LaunchIconPosition[LaunchIconPosition["LeftCenter"] = 3] = "LeftCenter";
    LaunchIconPosition[LaunchIconPosition["RightCenter"] = 4] = "RightCenter";
    LaunchIconPosition[LaunchIconPosition["BottomLeft"] = 5] = "BottomLeft";
    LaunchIconPosition[LaunchIconPosition["BottomCenter"] = 6] = "BottomCenter";
    LaunchIconPosition[LaunchIconPosition["BottomRight"] = 7] = "BottomRight";
})(LaunchIconPosition = exports.LaunchIconPosition || (exports.LaunchIconPosition = {}));
var LaunchIconType;
(function (LaunchIconType) {
    LaunchIconType[LaunchIconType["Float"] = 0] = "Float";
    LaunchIconType[LaunchIconType["Tabbed"] = 1] = "Tabbed";
})(LaunchIconType = exports.LaunchIconType || (exports.LaunchIconType = {}));
var LaunchTrigger;
(function (LaunchTrigger) {
    LaunchTrigger[LaunchTrigger["ClickableIcon"] = 1] = "ClickableIcon";
    LaunchTrigger[LaunchTrigger["JavascriptEvent"] = 2] = "JavascriptEvent";
})(LaunchTrigger = exports.LaunchTrigger || (exports.LaunchTrigger = {}));
var LaunchAvatarType;
(function (LaunchAvatarType) {
    LaunchAvatarType[LaunchAvatarType["Custom"] = 1] = "Custom";
    LaunchAvatarType[LaunchAvatarType["Heart"] = 2] = "Heart";
    LaunchAvatarType[LaunchAvatarType["Heartbeat"] = 3] = "Heartbeat";
    LaunchAvatarType[LaunchAvatarType["LightBulb"] = 4] = "LightBulb";
    LaunchAvatarType[LaunchAvatarType["Shield"] = 5] = "Shield";
    LaunchAvatarType[LaunchAvatarType["Info"] = 6] = "Info";
    LaunchAvatarType[LaunchAvatarType["ConciergeBell"] = 7] = "ConciergeBell";
})(LaunchAvatarType = exports.LaunchAvatarType || (exports.LaunchAvatarType = {}));
var UIPosition;
(function (UIPosition) {
    UIPosition[UIPosition["SuccessPanel"] = 1] = "SuccessPanel";
    UIPosition[UIPosition["LaunchIcon"] = 2] = "LaunchIcon";
})(UIPosition = exports.UIPosition || (exports.UIPosition = {}));
var SuccessCenterLocation;
(function (SuccessCenterLocation) {
    SuccessCenterLocation[SuccessCenterLocation["InAppOverlay"] = 1] = "InAppOverlay";
    SuccessCenterLocation[SuccessCenterLocation["NewTab"] = 2] = "NewTab";
})(SuccessCenterLocation = exports.SuccessCenterLocation || (exports.SuccessCenterLocation = {}));
var InAppOverlayPosition;
(function (InAppOverlayPosition) {
    InAppOverlayPosition[InAppOverlayPosition["Right"] = 1] = "Right";
    InAppOverlayPosition[InAppOverlayPosition["Left"] = 2] = "Left";
})(InAppOverlayPosition = exports.InAppOverlayPosition || (exports.InAppOverlayPosition = {}));
var WidthUnitType;
(function (WidthUnitType) {
    WidthUnitType[WidthUnitType["Pixels"] = 1] = "Pixels";
    WidthUnitType[WidthUnitType["Percentage"] = 2] = "Percentage";
})(WidthUnitType = exports.WidthUnitType || (exports.WidthUnitType = {}));
//# sourceMappingURL=enums.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/enums/AnnouncementType.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/enums/AnnouncementType.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnnouncementType = void 0;
var AnnouncementType;
(function (AnnouncementType) {
    AnnouncementType[AnnouncementType["Basic"] = 0] = "Basic";
    AnnouncementType[AnnouncementType["Nps"] = 1] = "Nps";
    AnnouncementType[AnnouncementType["CustomSurvey"] = 2] = "CustomSurvey";
})(AnnouncementType = exports.AnnouncementType || (exports.AnnouncementType = {}));
//# sourceMappingURL=AnnouncementType.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./classes/PubSuber */ "./node_modules/@churnzero/clientlibs/dist/main/classes/PubSuber.js"), exports);
__exportStar(__webpack_require__(/*! ./classes/ActivityMonitor */ "./node_modules/@churnzero/clientlibs/dist/main/classes/ActivityMonitor.js"), exports);
__exportStar(__webpack_require__(/*! ./enums */ "./node_modules/@churnzero/clientlibs/dist/main/enums.js"), exports);
__exportStar(__webpack_require__(/*! ./interfaces/IChecklistBrandingData */ "./node_modules/@churnzero/clientlibs/dist/main/interfaces/IChecklistBrandingData.js"), exports);
__exportStar(__webpack_require__(/*! ./interfaces/IClientSideUrls */ "./node_modules/@churnzero/clientlibs/dist/main/interfaces/IClientSideUrls.js"), exports);
__exportStar(__webpack_require__(/*! ./interfaces/IDigestable */ "./node_modules/@churnzero/clientlibs/dist/main/interfaces/IDigestable.js"), exports);
__exportStar(__webpack_require__(/*! ./interfaces/IParsedUrl */ "./node_modules/@churnzero/clientlibs/dist/main/interfaces/IParsedUrl.js"), exports);
__exportStar(__webpack_require__(/*! ./interfaces/IErrorLogger */ "./node_modules/@churnzero/clientlibs/dist/main/interfaces/IErrorLogger.js"), exports);
__exportStar(__webpack_require__(/*! ./models/announcement/announcement-style-config */ "./node_modules/@churnzero/clientlibs/dist/main/models/announcement/announcement-style-config.js"), exports);
__exportStar(__webpack_require__(/*! ./models/common/style-config */ "./node_modules/@churnzero/clientlibs/dist/main/models/common/style-config.js"), exports);
__exportStar(__webpack_require__(/*! ./models/checklist/checklist-settings-config */ "./node_modules/@churnzero/clientlibs/dist/main/models/checklist/checklist-settings-config.js"), exports);
__exportStar(__webpack_require__(/*! ./models/eventmap/eventmap */ "./node_modules/@churnzero/clientlibs/dist/main/models/eventmap/eventmap.js"), exports);
__exportStar(__webpack_require__(/*! ./models/page-tag/location-options */ "./node_modules/@churnzero/clientlibs/dist/main/models/page-tag/location-options.js"), exports);
__exportStar(__webpack_require__(/*! ./models/page-tag/location-part */ "./node_modules/@churnzero/clientlibs/dist/main/models/page-tag/location-part.js"), exports);
__exportStar(__webpack_require__(/*! ./models/page-tag/page-tag */ "./node_modules/@churnzero/clientlibs/dist/main/models/page-tag/page-tag.js"), exports);
__exportStar(__webpack_require__(/*! ./models/segment/segment */ "./node_modules/@churnzero/clientlibs/dist/main/models/segment/segment.js"), exports);
__exportStar(__webpack_require__(/*! ./models/walkthrough/walkthrough-step-config */ "./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-step-config.js"), exports);
__exportStar(__webpack_require__(/*! ./models/walkthrough/walkthrough-trigger-config/walkthrough-trigger-config */ "./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-trigger-config/walkthrough-trigger-config.js"), exports);
__exportStar(__webpack_require__(/*! ./models/walkthrough/walkthrough-trigger-config/walkthrough-page-visit-trigger-config */ "./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-trigger-config/walkthrough-page-visit-trigger-config.js"), exports);
__exportStar(__webpack_require__(/*! ./models/walkthrough/walkthrough-trigger-config/walkthrough-click-trigger-config */ "./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-trigger-config/walkthrough-click-trigger-config.js"), exports);
__exportStar(__webpack_require__(/*! ./models/walkthrough/walkthrough-trigger-config/walkthrough-anchor-trigger-config */ "./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-trigger-config/walkthrough-anchor-trigger-config.js"), exports);
__exportStar(__webpack_require__(/*! ./models/journey/checklist */ "./node_modules/@churnzero/clientlibs/dist/main/models/journey/checklist.js"), exports);
__exportStar(__webpack_require__(/*! ./models/walkthrough/walkthrough-style-config */ "./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-style-config.js"), exports);
__exportStar(__webpack_require__(/*! ./models/walkthrough/walkthrough-step */ "./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-step.js"), exports);
__exportStar(__webpack_require__(/*! ./models/walkthrough/walkthrough */ "./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough.js"), exports);
__exportStar(__webpack_require__(/*! ./utils/ajax-utils */ "./node_modules/@churnzero/clientlibs/dist/main/utils/ajax-utils.js"), exports);
__exportStar(__webpack_require__(/*! ./utils/core-utils */ "./node_modules/@churnzero/clientlibs/dist/main/utils/core-utils.js"), exports);
__exportStar(__webpack_require__(/*! ./utils/data-type-utils */ "./node_modules/@churnzero/clientlibs/dist/main/utils/data-type-utils.js"), exports);
__exportStar(__webpack_require__(/*! ./utils/iframe-utils */ "./node_modules/@churnzero/clientlibs/dist/main/utils/iframe-utils.js"), exports);
__exportStar(__webpack_require__(/*! ./utils/model-utils */ "./node_modules/@churnzero/clientlibs/dist/main/utils/model-utils.js"), exports);
__exportStar(__webpack_require__(/*! ./utils/style-utils */ "./node_modules/@churnzero/clientlibs/dist/main/utils/style-utils.js"), exports);
__exportStar(__webpack_require__(/*! ./constants/index */ "./node_modules/@churnzero/clientlibs/dist/main/constants/index.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/interfaces/IChecklistBrandingData.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/interfaces/IChecklistBrandingData.js ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=IChecklistBrandingData.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/interfaces/IClientSideUrls.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/interfaces/IClientSideUrls.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=IClientSideUrls.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/interfaces/IDigestable.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/interfaces/IDigestable.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=IDigestable.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/interfaces/IErrorLogger.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/interfaces/IErrorLogger.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=IErrorLogger.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/interfaces/IParsedUrl.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/interfaces/IParsedUrl.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=IParsedUrl.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/models/announcement/announcement-style-config.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/models/announcement/announcement-style-config.js ***!
  \*******************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnnouncementStyleConfig = void 0;
var style_config_1 = __webpack_require__(/*! ../common/style-config */ "./node_modules/@churnzero/clientlibs/dist/main/models/common/style-config.js");
var AnnouncementStyleConfig = (function (_super) {
    __extends(AnnouncementStyleConfig, _super);
    function AnnouncementStyleConfig() {
        return _super.call(this) || this;
    }
    return AnnouncementStyleConfig;
}(style_config_1.StyleConfig));
exports.AnnouncementStyleConfig = AnnouncementStyleConfig;
//# sourceMappingURL=announcement-style-config.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/models/checklist/checklist-settings-config.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/models/checklist/checklist-settings-config.js ***!
  \****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChecklistSettingsConfig = void 0;
var ChecklistSettingsConfig = (function () {
    function ChecklistSettingsConfig() {
    }
    return ChecklistSettingsConfig;
}());
exports.ChecklistSettingsConfig = ChecklistSettingsConfig;
//# sourceMappingURL=checklist-settings-config.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/models/common/style-config.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/models/common/style-config.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StyleConfig = void 0;
var StyleConfig = (function () {
    function StyleConfig() {
    }
    return StyleConfig;
}());
exports.StyleConfig = StyleConfig;
//# sourceMappingURL=style-config.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/models/eventmap/eventmap.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/models/eventmap/eventmap.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventMap = void 0;
var enums_1 = __webpack_require__(/*! ../../enums */ "./node_modules/@churnzero/clientlibs/dist/main/enums.js");
var model_utils_1 = __webpack_require__(/*! ../../utils/model-utils */ "./node_modules/@churnzero/clientlibs/dist/main/utils/model-utils.js");
var EventMap = (function () {
    function EventMap(tenantId) {
        this.disabled = false;
        this.locationTypeId = enums_1.LocationTypes.Site;
        this.location = '*';
        this.selectorTypeId = enums_1.SelectorTypes.Suggested;
        this.descriptionSelectorTypeId = enums_1.SelectorTypes.Suggested;
        this.quantitySelectorTypeId = enums_1.SelectorTypes.Suggested;
        this.tenantId = tenantId;
        this.hidden = false;
        this.excludeChildren = false;
        this.createdDate = '';
        this.updatedDate = '';
    }
    EventMap.fromJSONString = function (input) {
        return EventMap.fromObject(JSON.parse(input));
    };
    EventMap.fromObject = function (input) {
        return model_utils_1.ModelUtils.create(new EventMap(), input);
    };
    return EventMap;
}());
exports.EventMap = EventMap;
//# sourceMappingURL=eventmap.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/models/journey/checklist.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/models/journey/checklist.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JourneyChecklistOptions = void 0;
var JourneyChecklistOptions = (function () {
    function JourneyChecklistOptions() {
        this.isVisible = false;
        this.shouldIncludeLink = false;
        this.url = undefined;
    }
    return JourneyChecklistOptions;
}());
exports.JourneyChecklistOptions = JourneyChecklistOptions;
//# sourceMappingURL=checklist.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/models/page-tag/location-options.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/models/page-tag/location-options.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LocationOptions = void 0;
var LocationOptions = (function () {
    function LocationOptions(_a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.pathParts, pathParts = _c === void 0 ? [] : _c, _d = _b.hashParts, hashParts = _d === void 0 ? [] : _d, _e = _b.searchParts, searchParts = _e === void 0 ? [] : _e, _f = _b.allowChildStates, allowChildStates = _f === void 0 ? true : _f, _g = _b.allowChildPaths, allowChildPaths = _g === void 0 ? true : _g, _h = _b.excludeSearchParts, excludeSearchParts = _h === void 0 ? true : _h;
        this.pathParts = pathParts;
        this.hashParts = hashParts;
        this.searchParts = searchParts;
        this.allowChildStates = allowChildStates;
        if (allowChildStates !== false) {
            this.allowChildStates = true;
        }
        this.allowChildPaths = allowChildPaths;
        if (allowChildPaths !== false) {
            this.allowChildPaths = true;
        }
        this.excludeSearchParts = excludeSearchParts;
        if (excludeSearchParts !== false) {
            this.excludeSearchParts = true;
        }
    }
    LocationOptions.fromJson = function (locationOptionsJson, JsonRef) {
        if (JsonRef === void 0) { JsonRef = JSON; }
        var json;
        try {
            json = JsonRef.parse(locationOptionsJson);
        }
        catch (_a) {
            json = undefined;
        }
        return new LocationOptions(json);
    };
    return LocationOptions;
}());
exports.LocationOptions = LocationOptions;
//# sourceMappingURL=location-options.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/models/page-tag/location-part.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/models/page-tag/location-part.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LocationPart = void 0;
var LocationPart = (function () {
    function LocationPart() {
    }
    return LocationPart;
}());
exports.LocationPart = LocationPart;
//# sourceMappingURL=location-part.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/models/page-tag/page-tag.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/models/page-tag/page-tag.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PageTag = void 0;
var model_utils_1 = __webpack_require__(/*! ../../utils/model-utils */ "./node_modules/@churnzero/clientlibs/dist/main/utils/model-utils.js");
var PageTag = (function () {
    function PageTag(tenantId) {
        this.tenantId = tenantId;
        this.pageName = '';
        this.disabled = false;
        this.shouldFireEvent = true;
        this.eventName = '';
        this.shouldSetModule = false;
        this.moduleName = '';
        this.shouldSetExitModule = true;
        this.exitModuleName = 'Default';
    }
    PageTag.FromObject = function (item) {
        var newTag = model_utils_1.ModelUtils.create(new PageTag(), item);
        if (item.shouldSetExitModule) {
            newTag.shouldSetExitModule = item.shouldSetExitModule;
            newTag.exitModuleName = item.exitModuleName;
        }
        return newTag;
    };
    return PageTag;
}());
exports.PageTag = PageTag;
//# sourceMappingURL=page-tag.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/models/segment/segment.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/models/segment/segment.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Segment = void 0;
var model_utils_1 = __webpack_require__(/*! ../../utils/model-utils */ "./node_modules/@churnzero/clientlibs/dist/main/utils/model-utils.js");
var Segment = (function () {
    function Segment() {
    }
    Segment.fromObject = function (item) {
        return model_utils_1.ModelUtils.create(new Segment(), item);
    };
    return Segment;
}());
exports.Segment = Segment;
//# sourceMappingURL=segment.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-step-config.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-step-config.js ***!
  \****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TooltipStepConfig = exports.SliderStepConfig = exports.PopUpStepConfig = exports.WalkthroughStepConfig = void 0;
var walkthrough_step_1 = __webpack_require__(/*! ./walkthrough-step */ "./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-step.js");
var enums_1 = __webpack_require__(/*! ../../enums */ "./node_modules/@churnzero/clientlibs/dist/main/enums.js");
var WalkthroughStepConfig = (function () {
    function WalkthroughStepConfig() {
        this.backgroundColor = '#FFFFFF';
        this.closeColor = '#000000';
        this.borderRadius = 5;
        this.fontFamily = '';
        this.ctaText = 'Got it!';
        this.ctaButtonColor = '#FFFFFF';
        this.ctaButtonBorderColor = '#000000';
        this.ctaBackgroundColor = '#CCCCCC';
        this.ctaTextColor = '#000000';
        this.ctaAlignment = 'center';
    }
    WalkthroughStepConfig.fromJSONString = function (input, stepType) {
        switch (stepType) {
            case walkthrough_step_1.WalkthroughStepType.Slider:
                return SliderStepConfig.fromJSONString(input);
            case walkthrough_step_1.WalkthroughStepType.PopUp:
                return PopUpStepConfig.fromJSONString(input);
            case walkthrough_step_1.WalkthroughStepType.Tooltip:
                return TooltipStepConfig.fromJSONString(input);
            default:
                return new WalkthroughStepConfig();
        }
    };
    WalkthroughStepConfig.fromObject = function (input, stepType) {
        switch (stepType) {
            case walkthrough_step_1.WalkthroughStepType.Slider:
                return SliderStepConfig.fromObject(input);
            case walkthrough_step_1.WalkthroughStepType.PopUp:
                return PopUpStepConfig.fromObject(input);
            case walkthrough_step_1.WalkthroughStepType.Tooltip:
                return TooltipStepConfig.fromObject(input);
            default:
                return new WalkthroughStepConfig();
        }
    };
    return WalkthroughStepConfig;
}());
exports.WalkthroughStepConfig = WalkthroughStepConfig;
var PopUpStepConfig = (function (_super) {
    __extends(PopUpStepConfig, _super);
    function PopUpStepConfig() {
        var _this = _super.call(this) || this;
        _this.width = '340px';
        return _this;
    }
    PopUpStepConfig.fromJSONString = function (input) {
        return PopUpStepConfig.fromObject(JSON.parse(input));
    };
    PopUpStepConfig.fromObject = function (input) {
        var dest = new PopUpStepConfig();
        if (input) {
            Object.keys(input).forEach(function (k) {
                dest[k] = input[k];
            });
        }
        return dest;
    };
    return PopUpStepConfig;
}(WalkthroughStepConfig));
exports.PopUpStepConfig = PopUpStepConfig;
var SliderStepConfig = (function (_super) {
    __extends(SliderStepConfig, _super);
    function SliderStepConfig() {
        var _this = _super.call(this) || this;
        _this.position = enums_1.AnnouncementPosition.SlideTopCenter;
        return _this;
    }
    SliderStepConfig.fromJSONString = function (input) {
        return SliderStepConfig.fromObject(JSON.parse(input));
    };
    SliderStepConfig.fromObject = function (input) {
        var dest = new SliderStepConfig();
        if (input) {
            Object.keys(input).forEach(function (k) {
                dest[k] = input[k];
            });
        }
        return dest;
    };
    return SliderStepConfig;
}(WalkthroughStepConfig));
exports.SliderStepConfig = SliderStepConfig;
var TooltipStepConfig = (function (_super) {
    __extends(TooltipStepConfig, _super);
    function TooltipStepConfig() {
        var _this = _super.call(this) || this;
        _this.position = enums_1.TooltipPosition.Left;
        _this.container = enums_1.ContainerType.Body;
        return _this;
    }
    TooltipStepConfig.fromJSONString = function (input) {
        return TooltipStepConfig.fromObject(JSON.parse(input));
    };
    TooltipStepConfig.fromObject = function (input) {
        var dest = new TooltipStepConfig();
        if (input) {
            Object.keys(input).forEach(function (k) {
                dest[k] = input[k];
            });
        }
        return dest;
    };
    return TooltipStepConfig;
}(WalkthroughStepConfig));
exports.TooltipStepConfig = TooltipStepConfig;
//# sourceMappingURL=walkthrough-step-config.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-step.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-step.js ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WalkthroughStep = exports.WalkthroughStepType = void 0;
var walkthrough_step_config_1 = __webpack_require__(/*! ./walkthrough-step-config */ "./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-step-config.js");
var data_type_utils_1 = __webpack_require__(/*! ../../utils/data-type-utils */ "./node_modules/@churnzero/clientlibs/dist/main/utils/data-type-utils.js");
var model_utils_1 = __webpack_require__(/*! ../../utils/model-utils */ "./node_modules/@churnzero/clientlibs/dist/main/utils/model-utils.js");
var walkthrough_style_config_1 = __webpack_require__(/*! ./walkthrough-style-config */ "./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-style-config.js");
var WalkthroughStepType;
(function (WalkthroughStepType) {
    WalkthroughStepType[WalkthroughStepType["PopUp"] = 1] = "PopUp";
    WalkthroughStepType[WalkthroughStepType["Slider"] = 2] = "Slider";
    WalkthroughStepType[WalkthroughStepType["Tooltip"] = 3] = "Tooltip";
})(WalkthroughStepType = exports.WalkthroughStepType || (exports.WalkthroughStepType = {}));
var WalkthroughStep = (function () {
    function WalkthroughStep() {
        this.__oid = data_type_utils_1.DataTypeUtils.newGuid();
    }
    Object.defineProperty(WalkthroughStep.prototype, "stepType", {
        get: function () {
            return this.stepTypeId;
        },
        set: function (type) {
            this.stepTypeId = type;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WalkthroughStep.prototype, "stepConfig", {
        get: function () {
            if (data_type_utils_1.DataTypeUtils.isStringNullOrEmpty(this.stepConfigJson)) {
                return undefined;
            }
            if (!this._stepConfig) {
                this._stepConfig = walkthrough_step_config_1.WalkthroughStepConfig.fromJSONString(this.stepConfigJson, this.stepTypeId);
            }
            return this._stepConfig;
        },
        set: function (newOptions) {
            this._stepConfig = newOptions;
            var tj = (newOptions || {})['toJSON'];
            if (tj) {
                newOptions['toJSON'] = undefined;
            }
            this.stepConfigJson = JSON.stringify(newOptions);
            if (tj) {
                newOptions['toJSON'] = tj;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WalkthroughStep.prototype, "styleConfig", {
        get: function () {
            if (this._styleConfig instanceof walkthrough_style_config_1.WalkthroughStyleConfig) {
                return this._styleConfig;
            }
            try {
                var parsed = JSON.parse(this.styleConfigJson);
                this._styleConfig = model_utils_1.ModelUtils.create(new walkthrough_style_config_1.WalkthroughStyleConfig(), parsed);
            }
            catch (exc) {
                this._styleConfig = new walkthrough_style_config_1.WalkthroughStyleConfig();
            }
            return this._styleConfig;
        },
        set: function (config) {
            this._styleConfig = config;
            this.styleConfigJson = JSON.stringify(config);
        },
        enumerable: false,
        configurable: true
    });
    WalkthroughStep.fromJSONString = function (input) {
        return WalkthroughStep.fromObject(JSON.parse(input));
    };
    WalkthroughStep.fromObject = function (input) {
        var dest = model_utils_1.ModelUtils.create(new WalkthroughStep(), input);
        dest.stepConfig = walkthrough_step_config_1.WalkthroughStepConfig.fromObject(dest.stepConfig, dest.stepTypeId);
        return dest;
    };
    return WalkthroughStep;
}());
exports.WalkthroughStep = WalkthroughStep;
//# sourceMappingURL=walkthrough-step.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-style-config.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-style-config.js ***!
  \*****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WalkthroughStyleConfig = void 0;
var style_config_1 = __webpack_require__(/*! ../common/style-config */ "./node_modules/@churnzero/clientlibs/dist/main/models/common/style-config.js");
var WalkthroughStyleConfig = (function (_super) {
    __extends(WalkthroughStyleConfig, _super);
    function WalkthroughStyleConfig() {
        return _super.call(this) || this;
    }
    return WalkthroughStyleConfig;
}(style_config_1.StyleConfig));
exports.WalkthroughStyleConfig = WalkthroughStyleConfig;
//# sourceMappingURL=walkthrough-style-config.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-trigger-config/walkthrough-anchor-trigger-config.js":
/*!*****************************************************************************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-trigger-config/walkthrough-anchor-trigger-config.js ***!
  \*****************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WalkthroughAnchorTriggerConfig = exports.DEFAULT_ANCHOR_ICON_STYLE_CONFIG = exports.AnchorIconStyleConfig = exports.AnchorHoverTextPosition = exports.AnchorSizePreset = exports.AnchorSizeType = exports.AnchorDisplayType = exports.AnchorPositionType = void 0;
var enums_1 = __webpack_require__(/*! ../../../enums */ "./node_modules/@churnzero/clientlibs/dist/main/enums.js");
var model_utils_1 = __webpack_require__(/*! ../../../utils/model-utils */ "./node_modules/@churnzero/clientlibs/dist/main/utils/model-utils.js");
var walkthrough_trigger_config_1 = __webpack_require__(/*! ./walkthrough-trigger-config */ "./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-trigger-config/walkthrough-trigger-config.js");
var walkthrough_click_trigger_config_1 = __webpack_require__(/*! ./walkthrough-click-trigger-config */ "./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-trigger-config/walkthrough-click-trigger-config.js");
var AnchorPositionType;
(function (AnchorPositionType) {
    AnchorPositionType[AnchorPositionType["Inline"] = 1] = "Inline";
    AnchorPositionType[AnchorPositionType["TopRight"] = 2] = "TopRight";
    AnchorPositionType[AnchorPositionType["Right"] = 3] = "Right";
    AnchorPositionType[AnchorPositionType["BottomRight"] = 4] = "BottomRight";
    AnchorPositionType[AnchorPositionType["Bottom"] = 5] = "Bottom";
    AnchorPositionType[AnchorPositionType["BottomLeft"] = 6] = "BottomLeft";
    AnchorPositionType[AnchorPositionType["Left"] = 7] = "Left";
    AnchorPositionType[AnchorPositionType["TopLeft"] = 8] = "TopLeft";
    AnchorPositionType[AnchorPositionType["Top"] = 9] = "Top";
})(AnchorPositionType = exports.AnchorPositionType || (exports.AnchorPositionType = {}));
var AnchorDisplayType;
(function (AnchorDisplayType) {
    AnchorDisplayType[AnchorDisplayType["AlwaysShow"] = 1] = "AlwaysShow";
    AnchorDisplayType[AnchorDisplayType["OnlyOnHover"] = 2] = "OnlyOnHover";
})(AnchorDisplayType = exports.AnchorDisplayType || (exports.AnchorDisplayType = {}));
var AnchorSizeType;
(function (AnchorSizeType) {
    AnchorSizeType[AnchorSizeType["Small"] = 1] = "Small";
    AnchorSizeType[AnchorSizeType["Medium"] = 2] = "Medium";
    AnchorSizeType[AnchorSizeType["Large"] = 3] = "Large";
    AnchorSizeType[AnchorSizeType["Custom"] = 4] = "Custom";
})(AnchorSizeType = exports.AnchorSizeType || (exports.AnchorSizeType = {}));
var AnchorSizePreset;
(function (AnchorSizePreset) {
    AnchorSizePreset[AnchorSizePreset["Small"] = 16] = "Small";
    AnchorSizePreset[AnchorSizePreset["Medium"] = 32] = "Medium";
    AnchorSizePreset[AnchorSizePreset["Large"] = 64] = "Large";
})(AnchorSizePreset = exports.AnchorSizePreset || (exports.AnchorSizePreset = {}));
var AnchorHoverTextPosition;
(function (AnchorHoverTextPosition) {
    AnchorHoverTextPosition[AnchorHoverTextPosition["Right"] = 1] = "Right";
    AnchorHoverTextPosition[AnchorHoverTextPosition["Bottom"] = 2] = "Bottom";
    AnchorHoverTextPosition[AnchorHoverTextPosition["Left"] = 3] = "Left";
    AnchorHoverTextPosition[AnchorHoverTextPosition["Top"] = 4] = "Top";
})(AnchorHoverTextPosition = exports.AnchorHoverTextPosition || (exports.AnchorHoverTextPosition = {}));
var AnchorIconStyleConfig = (function () {
    function AnchorIconStyleConfig() {
    }
    return AnchorIconStyleConfig;
}());
exports.AnchorIconStyleConfig = AnchorIconStyleConfig;
exports.DEFAULT_ANCHOR_ICON_STYLE_CONFIG = model_utils_1.ModelUtils.create(new AnchorIconStyleConfig(), {
    iconColor: '#ffffff',
    iconBackgroundColor: '#000000',
    iconBorderColor: '#ffffff',
    size: AnchorSizePreset.Small,
    sizeTypeId: AnchorSizeType.Small,
    positionTypeId: AnchorPositionType.Inline,
    displayTypeId: AnchorDisplayType.AlwaysShow,
    hoverTextEnabled: true,
    hoverText: 'Click to see more!',
    hoverTextColor: '#ffffff',
    hoverTextBackgroundColor: '#000000',
    hoverTextPositionId: AnchorHoverTextPosition.Right
});
var WalkthroughAnchorTriggerConfig = (function (_super) {
    __extends(WalkthroughAnchorTriggerConfig, _super);
    function WalkthroughAnchorTriggerConfig() {
        var _this = _super.call(this) || this;
        _this.triggerActionId = enums_1.AnchorActionType.Click;
        _this.triggerActionDelay = 0;
        _this.containerType = enums_1.ContainerType.Body;
        _this.iconType = '';
        _this.iconStyleConfig = new AnchorIconStyleConfig();
        return _this;
    }
    WalkthroughAnchorTriggerConfig.fromJSONString = function (input) {
        return walkthrough_click_trigger_config_1.WalkthroughClickTriggerConfig.fromObject(JSON.parse(input));
    };
    WalkthroughAnchorTriggerConfig.fromObject = function (input) {
        return model_utils_1.ModelUtils.create(new walkthrough_click_trigger_config_1.WalkthroughClickTriggerConfig(), input);
    };
    return WalkthroughAnchorTriggerConfig;
}(walkthrough_trigger_config_1.WalkthroughTriggerConfig));
exports.WalkthroughAnchorTriggerConfig = WalkthroughAnchorTriggerConfig;
//# sourceMappingURL=walkthrough-anchor-trigger-config.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-trigger-config/walkthrough-click-trigger-config.js":
/*!****************************************************************************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-trigger-config/walkthrough-click-trigger-config.js ***!
  \****************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WalkthroughClickTriggerConfig = void 0;
var model_utils_1 = __webpack_require__(/*! ../../../utils/model-utils */ "./node_modules/@churnzero/clientlibs/dist/main/utils/model-utils.js");
var walkthrough_trigger_config_1 = __webpack_require__(/*! ./walkthrough-trigger-config */ "./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-trigger-config/walkthrough-trigger-config.js");
var WalkthroughClickTriggerConfig = (function (_super) {
    __extends(WalkthroughClickTriggerConfig, _super);
    function WalkthroughClickTriggerConfig() {
        var _this = _super.call(this) || this;
        _this.excludeChildren = false;
        return _this;
    }
    WalkthroughClickTriggerConfig.fromJSONString = function (input) {
        return WalkthroughClickTriggerConfig.fromObject(JSON.parse(input));
    };
    WalkthroughClickTriggerConfig.fromObject = function (input) {
        return model_utils_1.ModelUtils.create(new WalkthroughClickTriggerConfig(), input);
    };
    return WalkthroughClickTriggerConfig;
}(walkthrough_trigger_config_1.WalkthroughTriggerConfig));
exports.WalkthroughClickTriggerConfig = WalkthroughClickTriggerConfig;
//# sourceMappingURL=walkthrough-click-trigger-config.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-trigger-config/walkthrough-page-visit-trigger-config.js":
/*!*********************************************************************************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-trigger-config/walkthrough-page-visit-trigger-config.js ***!
  \*********************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WalkthroughPageVisitTriggerConfig = void 0;
var model_utils_1 = __webpack_require__(/*! ../../../utils/model-utils */ "./node_modules/@churnzero/clientlibs/dist/main/utils/model-utils.js");
var walkthrough_trigger_config_1 = __webpack_require__(/*! ./walkthrough-trigger-config */ "./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-trigger-config/walkthrough-trigger-config.js");
var WalkthroughPageVisitTriggerConfig = (function (_super) {
    __extends(WalkthroughPageVisitTriggerConfig, _super);
    function WalkthroughPageVisitTriggerConfig() {
        return _super.call(this) || this;
    }
    WalkthroughPageVisitTriggerConfig.fromJSONString = function (input) {
        return WalkthroughPageVisitTriggerConfig.fromObject(JSON.parse(input));
    };
    WalkthroughPageVisitTriggerConfig.fromObject = function (input) {
        return model_utils_1.ModelUtils.create(new WalkthroughPageVisitTriggerConfig(), input);
    };
    return WalkthroughPageVisitTriggerConfig;
}(walkthrough_trigger_config_1.WalkthroughTriggerConfig));
exports.WalkthroughPageVisitTriggerConfig = WalkthroughPageVisitTriggerConfig;
//# sourceMappingURL=walkthrough-page-visit-trigger-config.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-trigger-config/walkthrough-trigger-config.js":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-trigger-config/walkthrough-trigger-config.js ***!
  \**********************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WalkthroughTriggerConfig = void 0;
var WalkthroughTriggerConfig = (function () {
    function WalkthroughTriggerConfig() {
    }
    return WalkthroughTriggerConfig;
}());
exports.WalkthroughTriggerConfig = WalkthroughTriggerConfig;
//# sourceMappingURL=walkthrough-trigger-config.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Walkthrough = void 0;
var walkthrough_step_1 = __webpack_require__(/*! ./walkthrough-step */ "./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-step.js");
var walkthrough_style_config_1 = __webpack_require__(/*! ./walkthrough-style-config */ "./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-style-config.js");
var enums_1 = __webpack_require__(/*! ../../enums */ "./node_modules/@churnzero/clientlibs/dist/main/enums.js");
var data_type_utils_1 = __webpack_require__(/*! ../../utils/data-type-utils */ "./node_modules/@churnzero/clientlibs/dist/main/utils/data-type-utils.js");
var model_utils_1 = __webpack_require__(/*! ../../utils/model-utils */ "./node_modules/@churnzero/clientlibs/dist/main/utils/model-utils.js");
var page_tag_1 = __webpack_require__(/*! ../page-tag/page-tag */ "./node_modules/@churnzero/clientlibs/dist/main/models/page-tag/page-tag.js");
var segment_1 = __webpack_require__(/*! ../segment/segment */ "./node_modules/@churnzero/clientlibs/dist/main/models/segment/segment.js");
var walkthrough_page_visit_trigger_config_1 = __webpack_require__(/*! ./walkthrough-trigger-config/walkthrough-page-visit-trigger-config */ "./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-trigger-config/walkthrough-page-visit-trigger-config.js");
var walkthrough_click_trigger_config_1 = __webpack_require__(/*! ./walkthrough-trigger-config/walkthrough-click-trigger-config */ "./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-trigger-config/walkthrough-click-trigger-config.js");
var walkthrough_anchor_trigger_config_1 = __webpack_require__(/*! ./walkthrough-trigger-config/walkthrough-anchor-trigger-config */ "./node_modules/@churnzero/clientlibs/dist/main/models/walkthrough/walkthrough-trigger-config/walkthrough-anchor-trigger-config.js");
var Walkthrough = (function () {
    function Walkthrough() {
        this.__oid = data_type_utils_1.DataTypeUtils.newGuid();
        this.steps = [];
        this.segments = [];
        this.recurrence = true;
        this.disabled = true;
    }
    Object.defineProperty(Walkthrough.prototype, "triggerType", {
        get: function () {
            return this.triggerTypeId;
        },
        set: function (type) {
            this.triggerTypeId = type;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Walkthrough.prototype, "triggerConfig", {
        get: function () {
            if (!this._triggerConfig) {
                switch (this.triggerTypeId) {
                    case enums_1.WalkthroughTriggerType.PageVisit:
                        this._triggerConfig = walkthrough_page_visit_trigger_config_1.WalkthroughPageVisitTriggerConfig.fromJSONString(this.triggerConfigJson);
                        break;
                    case enums_1.WalkthroughTriggerType.Click:
                        this._triggerConfig = walkthrough_click_trigger_config_1.WalkthroughClickTriggerConfig.fromJSONString(this.triggerConfigJson);
                        break;
                    case enums_1.WalkthroughTriggerType.Anchor:
                        this._triggerConfig = walkthrough_anchor_trigger_config_1.WalkthroughAnchorTriggerConfig.fromJSONString(this.triggerConfigJson);
                        break;
                    default:
                        break;
                }
            }
            return this._triggerConfig;
        },
        set: function (newOptions) {
            this._triggerConfig = newOptions;
            var tj = newOptions['toJSON'];
            if (tj) {
                newOptions['toJSON'] = undefined;
            }
            this.triggerConfigJson = JSON.stringify(newOptions);
            if (tj) {
                newOptions['toJSON'] = tj;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Walkthrough.prototype, "styleConfig", {
        get: function () {
            if (this._styleConfig instanceof walkthrough_style_config_1.WalkthroughStyleConfig) {
                return this._styleConfig;
            }
            try {
                var parsed = JSON.parse(this.styleConfigJson);
                this._styleConfig = model_utils_1.ModelUtils.create(new walkthrough_style_config_1.WalkthroughStyleConfig(), parsed);
            }
            catch (exc) {
                this._styleConfig = new walkthrough_style_config_1.WalkthroughStyleConfig();
            }
            return this._styleConfig;
        },
        set: function (config) {
            this._styleConfig = config;
            this.styleConfigJson = JSON.stringify(config);
        },
        enumerable: false,
        configurable: true
    });
    Walkthrough.fromJSONString = function (input) {
        return Walkthrough.fromObject(JSON.parse(input));
    };
    Walkthrough.fromObject = function (input) {
        var dest = model_utils_1.ModelUtils.create(new Walkthrough(), input);
        if (dest.pageTag) {
            dest.pageTag = page_tag_1.PageTag.FromObject(dest.pageTag);
        }
        for (var i = 0; i < dest.steps.length; i++) {
            if (dest.steps[i]) {
                dest.steps[i] = walkthrough_step_1.WalkthroughStep.fromObject(dest.steps[i]);
            }
        }
        var segmentsArray = [];
        for (var i = 0; i < dest.segments.length; i++) {
            segmentsArray.push(segment_1.Segment.fromObject(dest.segments[i]));
        }
        dest.segments = segmentsArray;
        return dest;
    };
    Walkthrough.prototype.toJSON = function () {
        var output = {};
        for (var prop in this) {
            if (Walkthrough.toJSONIgnoreProps.indexOf(prop) !== -1) {
                continue;
            }
            else {
                output[prop] = this[prop];
            }
        }
        return output;
    };
    Walkthrough.toJSONIgnoreProps = ['__oid', '_triggerConfig', 'triggerConfig', '_styleConfig', 'styleConfig'];
    return Walkthrough;
}());
exports.Walkthrough = Walkthrough;
//# sourceMappingURL=walkthrough.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/utils/ajax-utils.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/utils/ajax-utils.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AjaxUtils = exports.RequestOptions = void 0;
var es6_promise_1 = __webpack_require__(/*! es6-promise */ "./node_modules/es6-promise/dist/es6-promise.js");
var RequestOptions = (function () {
    function RequestOptions(options) {
        this.type = 'GET';
        this.contentType = 'application/x-www-form-urlencoded; charset=UTF-8';
        this.withCredentials = false;
        for (var p in this) {
            if (this.hasOwnProperty(p) && options[p] !== undefined) {
                this[p] = options[p];
            }
        }
    }
    return RequestOptions;
}());
exports.RequestOptions = RequestOptions;
var AjaxUtils;
(function (AjaxUtils) {
    function get(url, options) {
        var requestOptions = new RequestOptions(options);
        requestOptions.type = 'GET';
        requestOptions.url = url;
        return makeRequest(requestOptions);
    }
    AjaxUtils.get = get;
    function post(url, data, options) {
        var requestOptions = new RequestOptions(options);
        requestOptions.type = 'POST';
        requestOptions.url = url;
        requestOptions.data = data;
        return makeRequest(requestOptions);
    }
    AjaxUtils.post = post;
    function makeRequest(options) {
        return new es6_promise_1.Promise(function (resolve, reject) {
            var req = new XMLHttpRequest();
            req.open(options.type, options.url, true);
            if (options.withCredentials === true) {
                req.withCredentials = true;
            }
            req.setRequestHeader('Content-Type', options.contentType);
            req.onload = function () {
                if (req.status === 200) {
                    resolve(req.response);
                }
                else {
                    var errorObj = Error(req.statusText);
                    errorObj.status = req.status;
                    reject(errorObj);
                }
            };
            req.onerror = function () {
                reject(Error('Network Error'));
            };
            if (options.data) {
                req.send(options.data);
            }
            else {
                req.send();
            }
        });
    }
    AjaxUtils.makeRequest = makeRequest;
})(AjaxUtils = exports.AjaxUtils || (exports.AjaxUtils = {}));
//# sourceMappingURL=ajax-utils.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/utils/core-utils.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/utils/core-utils.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CoreUtils = void 0;
var location_part_1 = __webpack_require__(/*! ../models/page-tag/location-part */ "./node_modules/@churnzero/clientlibs/dist/main/models/page-tag/location-part.js");
var location_options_1 = __webpack_require__(/*! ../models/page-tag/location-options */ "./node_modules/@churnzero/clientlibs/dist/main/models/page-tag/location-options.js");
var style_utils_1 = __webpack_require__(/*! ./style-utils */ "./node_modules/@churnzero/clientlibs/dist/main/utils/style-utils.js");
var enums_1 = __webpack_require__(/*! ../enums */ "./node_modules/@churnzero/clientlibs/dist/main/enums.js");
var constants_1 = __webpack_require__(/*! ../constants */ "./node_modules/@churnzero/clientlibs/dist/main/constants/index.js");
var CoreUtils;
(function (CoreUtils) {
    function areCookiesEnabled() {
        try {
            document.cookie = 'czcookietest=1; SameSite=Lax';
            var cookiesEnabled = document.cookie.indexOf('czcookietest=') !== -1;
            document.cookie = 'czcookietest=1; expires=Thu, 01-Jan-1970 00:00:01 GMT';
            return cookiesEnabled;
        }
        catch (e) {
            return false;
        }
    }
    CoreUtils.areCookiesEnabled = areCookiesEnabled;
    function createCookie(name, value, days, now) {
        var expires = '';
        if (days) {
            var date = now;
            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
            expires = '; expires=' + date.toUTCString();
        }
        document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value) + expires + '; path=/';
    }
    CoreUtils.createCookie = createCookie;
    function readCookie(name) {
        var nameEQ = encodeURIComponent(name) + '=';
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i];
            while (c.charAt(0) === ' ')
                c = c.substring(1, c.length);
            if (c.indexOf(nameEQ) === 0)
                return decodeURIComponent(c.substring(nameEQ.length, c.length));
        }
        return null;
    }
    CoreUtils.readCookie = readCookie;
    function eraseCookie(name, now) {
        createCookie(name, '', -1, now);
    }
    CoreUtils.eraseCookie = eraseCookie;
    function loadScript(url, callbackfn) {
        var script = document.createElement('script');
        script.setAttribute('type', 'text/javascript');
        script.setAttribute('src', url);
        script.onload = function () {
            return callbackfn();
        };
        document.getElementsByTagName('head')[0].appendChild(script);
    }
    CoreUtils.loadScript = loadScript;
    function refreshScript(src, options) {
        options = options || {};
        var scriptElement = document.createElement('script');
        scriptElement.type = 'text/javascript';
        if (options.onError) {
            scriptElement.onerror = function () {
                return options.onError();
            };
        }
        if (options.onLoad) {
            scriptElement.onload = function () {
                return options.onLoad();
            };
        }
        scriptElement.src = src + (options.includeTimeStamp ? '?' + options.timeStamp : '');
        scriptElement.async = true;
        document.getElementsByTagName('head')[0].appendChild(scriptElement);
    }
    CoreUtils.refreshScript = refreshScript;
    function createElementFromHTML(document, htmlString) {
        var div = document.createElement('div');
        div.innerHTML = htmlString.trim();
        return div.firstChild;
    }
    CoreUtils.createElementFromHTML = createElementFromHTML;
    function getMatchesPrototype() {
        return Element.prototype.matches
            || Element.prototype['matchesSelector']
            || Element.prototype['mozMatchesSelector']
            || Element.prototype['msMatchesSelector']
            || Element.prototype['oMatchesSelector']
            || Element.prototype.webkitMatchesSelector
            || function (s) {
                var matches = (this.document || this.ownerDocument).querySelectorAll(s);
                var i = matches.length;
                while (--i >= 0 && matches.item(i) !== this) {
                }
                return i > -1;
            };
    }
    function closest(el, selector) {
        var matchesFunc = getMatchesPrototype();
        while (el) {
            if (matchesFunc.call(el, selector)) {
                return el;
            }
            el = el.parentElement;
        }
    }
    CoreUtils.closest = closest;
    var FeatureDetection;
    (function (FeatureDetection) {
        function inIframe() {
            try {
                return window !== window.parent;
            }
            catch (e) {
                return true;
            }
        }
        FeatureDetection.inIframe = inIframe;
        function isLegacyIE() {
            return !navigator || !navigator.userAgent || navigator.userAgent.indexOf('MSIE') >= 0;
        }
        FeatureDetection.isLegacyIE = isLegacyIE;
        function isXHTML() {
            return document && document.doctype && document.doctype.systemId && (document.doctype.systemId || '').toLowerCase().indexOf('xhtml') > -1;
        }
        FeatureDetection.isXHTML = isXHTML;
        var BrowserInfo = (function () {
            function BrowserInfo() {
            }
            return BrowserInfo;
        }());
        FeatureDetection.BrowserInfo = BrowserInfo;
        function getBrowserInfo() {
            var browserInfo = new BrowserInfo();
            try {
                var unknown = '-';
                var screenSize = '';
                if (screen.width) {
                    var width = (screen.width) ? screen.width : '';
                    var height = (screen.height) ? screen.height : '';
                    screenSize += '' + width + ' x ' + height;
                }
                var nVer = navigator.appVersion;
                var nAgt = navigator.userAgent;
                var browser = navigator.appName;
                var version = '' + parseFloat(navigator.appVersion);
                var majorVersion = parseInt(navigator.appVersion, 10);
                var nameOffset = void 0, verOffset = void 0, ix = void 0;
                if ((verOffset = nAgt.indexOf('Opera')) !== -1) {
                    browser = 'Opera';
                    version = nAgt.substring(verOffset + 6);
                    if ((verOffset = nAgt.indexOf('Version')) !== -1) {
                        version = nAgt.substring(verOffset + 8);
                    }
                }
                if ((verOffset = nAgt.indexOf('OPR')) !== -1) {
                    browser = 'Opera';
                    version = nAgt.substring(verOffset + 4);
                }
                else if ((verOffset = nAgt.indexOf('Edge')) !== -1) {
                    browser = 'Microsoft Edge';
                    version = nAgt.substring(verOffset + 5);
                }
                else if ((verOffset = nAgt.indexOf('MSIE')) !== -1) {
                    browser = 'Microsoft Internet Explorer';
                    version = nAgt.substring(verOffset + 5);
                }
                else if ((verOffset = nAgt.indexOf('Chrome')) !== -1) {
                    browser = 'Chrome';
                    version = nAgt.substring(verOffset + 7);
                }
                else if ((verOffset = nAgt.indexOf('Safari')) !== -1) {
                    browser = 'Safari';
                    version = nAgt.substring(verOffset + 7);
                    if ((verOffset = nAgt.indexOf('Version')) !== -1) {
                        version = nAgt.substring(verOffset + 8);
                    }
                }
                else if ((verOffset = nAgt.indexOf('Firefox')) !== -1) {
                    browser = 'Firefox';
                    version = nAgt.substring(verOffset + 8);
                }
                else if (nAgt.indexOf('Trident/') !== -1) {
                    browser = 'Microsoft Internet Explorer';
                    version = nAgt.substring(nAgt.indexOf('rv:') + 3);
                }
                else if ((nameOffset = nAgt.lastIndexOf(' ') + 1) < (verOffset = nAgt.lastIndexOf('/'))) {
                    browser = nAgt.substring(nameOffset, verOffset);
                    version = nAgt.substring(verOffset + 1);
                    if (browser.toLowerCase() === browser.toUpperCase()) {
                        browser = navigator.appName;
                    }
                }
                if ((ix = version.indexOf(';')) !== -1)
                    version = version.substring(0, ix);
                if ((ix = version.indexOf(' ')) !== -1)
                    version = version.substring(0, ix);
                if ((ix = version.indexOf(')')) !== -1)
                    version = version.substring(0, ix);
                majorVersion = parseInt('' + version, 10);
                if (isNaN(majorVersion)) {
                    version = '' + parseFloat(navigator.appVersion);
                    majorVersion = parseInt(navigator.appVersion, 10);
                }
                var mobile = /Mobile|mini|Fennec|Android|iP(ad|od|hone)/.test(nVer);
                var cookieEnabled = (navigator.cookieEnabled) ? true : false;
                if (typeof navigator.cookieEnabled === 'undefined' && !cookieEnabled) {
                    document.cookie = 'testcookie';
                    cookieEnabled = (document.cookie.indexOf('testcookie') !== -1) ? true : false;
                }
                var os = unknown;
                var clientStrings = [
                    { s: 'Windows 10', r: /(Windows 10.0|Windows NT 10.0)/ },
                    { s: 'Windows 8.1', r: /(Windows 8.1|Windows NT 6.3)/ },
                    { s: 'Windows 8', r: /(Windows 8|Windows NT 6.2)/ },
                    { s: 'Windows 7', r: /(Windows 7|Windows NT 6.1)/ },
                    { s: 'Windows Vista', r: /Windows NT 6.0/ },
                    { s: 'Windows Server 2003', r: /Windows NT 5.2/ },
                    { s: 'Windows XP', r: /(Windows NT 5.1|Windows XP)/ },
                    { s: 'Windows 2000', r: /(Windows NT 5.0|Windows 2000)/ },
                    { s: 'Windows ME', r: /(Win 9x 4.90|Windows ME)/ },
                    { s: 'Windows 98', r: /(Windows 98|Win98)/ },
                    { s: 'Windows 95', r: /(Windows 95|Win95|Windows_95)/ },
                    { s: 'Windows NT 4.0', r: /(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/ },
                    { s: 'Windows CE', r: /Windows CE/ },
                    { s: 'Windows 3.11', r: /Win16/ },
                    { s: 'Android', r: /Android/ },
                    { s: 'Open BSD', r: /OpenBSD/ },
                    { s: 'Sun OS', r: /SunOS/ },
                    { s: 'Linux', r: /(Linux|X11)/ },
                    { s: 'iOS', r: /(iPhone|iPad|iPod)/ },
                    { s: 'Mac OS X', r: /Mac OS X/ },
                    { s: 'Mac OS', r: /(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/ },
                    { s: 'QNX', r: /QNX/ },
                    { s: 'UNIX', r: /UNIX/ },
                    { s: 'BeOS', r: /BeOS/ },
                    { s: 'OS/2', r: /OS\/2/ },
                    {
                        s: 'Search Bot',
                        r: /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask Jeeves\/Teoma|ia_archiver)/
                    }
                ];
                for (var id in clientStrings) {
                    var cs = clientStrings[id];
                    if (cs.r.test(nAgt)) {
                        os = cs.s;
                        break;
                    }
                }
                var osVersion = unknown, osVersionArray = void 0;
                if (/Windows/.test(os)) {
                    osVersionArray = /Windows (.*)/.exec(os);
                    osVersion = osVersionArray[1];
                    os = 'Windows';
                }
                switch (os) {
                    case 'Mac OS X':
                        osVersionArray = /Mac OS X (1[\d][._\d]+)/.exec(nAgt);
                        osVersion = osVersionArray[1];
                        break;
                    case 'Android':
                        osVersionArray = /Android ([._\d]+)/.exec(nAgt);
                        osVersion = osVersionArray[1];
                        break;
                    case 'iOS':
                        osVersionArray = /OS (\d+)_(\d+)_?(\d+)?/.exec(nVer);
                        osVersion = osVersionArray[1] + '.' + osVersionArray[2] + '.' + (osVersionArray[3] | 0);
                        break;
                }
                browserInfo = {
                    screen: screenSize,
                    browser: browser,
                    browserVersion: version,
                    browserMajorVersion: majorVersion,
                    mobile: mobile,
                    os: os,
                    osVersion: osVersion,
                    cookies: cookieEnabled
                };
            }
            catch (e) {
            }
            return browserInfo;
        }
        FeatureDetection.getBrowserInfo = getBrowserInfo;
    })(FeatureDetection = CoreUtils.FeatureDetection || (CoreUtils.FeatureDetection = {}));
    function convertFormSerializedArrayToObject(array) {
        var o = {};
        array.forEach(function (v) {
            o[v.name] = v.value || '';
        });
        return o;
    }
    CoreUtils.convertFormSerializedArrayToObject = convertFormSerializedArrayToObject;
    function expandFlattenedObject(flatObject) {
        var createObject = function (model, name, value) {
            var nameParts = name.split('.'), currentObject = model;
            for (var i = 0; i < nameParts.length; i++) {
                var part = nameParts[i];
                if (i === nameParts.length - 1) {
                    currentObject[part] = value;
                    break;
                }
                if (typeof currentObject[part] === 'undefined') {
                    currentObject[part] = {};
                }
                currentObject = currentObject[part];
            }
        };
        var model = {};
        for (var key in flatObject) {
            createObject(model, key, flatObject[key] || '');
        }
        return model;
    }
    CoreUtils.expandFlattenedObject = expandFlattenedObject;
    function extend(out) {
        var extendsArguments = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            extendsArguments[_i - 1] = arguments[_i];
        }
        out = out || {};
        for (var i = 1; i < arguments.length; i++) {
            if (!arguments[i])
                continue;
            for (var key in arguments[i]) {
                if (arguments[i].hasOwnProperty(key))
                    out[key] = arguments[i][key];
            }
        }
        return out;
    }
    CoreUtils.extend = extend;
    var knownProblemClasses = ['ng-dirty', 'ng-touched', 'ng-untouched', 'ng-submitted', 'ng-pristine', 'ng-valid', 'ng-scope', 'ng-isolate-scope', 'active'];
    function removeKnownClasses(input) {
        if (input && input !== '' && input.length > 0) {
            return input.split(' ').filter(function (el) {
                return knownProblemClasses.indexOf(el.toLowerCase()) === -1;
            }).join(' ');
        }
        return '';
    }
    CoreUtils.removeKnownClasses = removeKnownClasses;
    function convertClassStringToEscapedSelector(input) {
        if (input && input !== '' && input.length > 0) {
            var removeEmpties = function (classString) {
                return classString.length !== 0;
            };
            var classNames = input.split(' ').filter(removeEmpties);
            for (var i = 0; i < classNames.length; i++) {
                classNames[i] = style_utils_1.StyleUtils.cssEscape(classNames[i]);
            }
            return '.' + classNames.filter(removeEmpties).join('.');
        }
        return '';
    }
    CoreUtils.convertClassStringToEscapedSelector = convertClassStringToEscapedSelector;
    function buildFullDomSelector(element) {
        var parents = CoreUtils.getParentsOfElement(element);
        var parentSelectors = [];
        for (var i = 0; i < parents.length; i++) {
            parentSelectors.push(CoreUtils.buildElementSelector(parents[i]));
        }
        parentSelectors = parentSelectors.reverse();
        var selector = parentSelectors
            .concat([CoreUtils.buildElementSelector(element)])
            .join('>');
        return selector;
    }
    CoreUtils.buildFullDomSelector = buildFullDomSelector;
    function buildElementSelector(element) {
        var internalTarget = element, tagName = element.tagName, internalId = (internalTarget.getAttribute('id') || '').trim(), ignoreClassesElements = ['html', 'body'], internalClassNames = '';
        if (internalId !== '') {
            internalId = '#' + internalId;
        }
        if (ignoreClassesElements.indexOf(internalTarget.tagName.toLowerCase()) === -1) {
            try {
                var cleanNames = [];
                for (var i = 0; i < internalTarget.classList.length; i++) {
                    cleanNames.push(internalTarget.classList[i]);
                }
                internalClassNames = (cleanNames.join(' ') || '').trim();
            }
            catch (ex) {
                internalClassNames = (internalTarget.getAttribute('class') || '').trim();
            }
            internalClassNames = removeKnownClasses(internalClassNames);
            internalClassNames = convertClassStringToEscapedSelector(internalClassNames);
        }
        switch (tagName.toLowerCase()) {
            case 'input':
                tagName += "[type=" + internalTarget.getAttribute('type') + "]";
                break;
        }
        return tagName + internalId + internalClassNames;
    }
    CoreUtils.buildElementSelector = buildElementSelector;
    function getTextFromElement(element) {
        var text;
        if (element.length === 0) {
            return text;
        }
        switch (element.get(0).tagName.toLowerCase()) {
            case 'html':
            case 'body':
                break;
            case 'select':
                text = element.val();
                break;
            case 'img':
                text = element.attr('alt');
                break;
            case 'input':
            case 'textarea':
                text = element.val();
                break;
            default:
                text = element.text();
                break;
        }
        return text;
    }
    CoreUtils.getTextFromElement = getTextFromElement;
    function getIntFromElement(element) {
        var text = getTextFromElement(element);
        return getIntFromString(text);
    }
    CoreUtils.getIntFromElement = getIntFromElement;
    function getIntFromString(text) {
        var intText;
        if (!Strings.isNullOrEmpty(text)) {
            intText = parseInt(text.replace(/[^0-9.]/g, ''));
            if (isNaN(intText)) {
                return null;
            }
        }
        return intText;
    }
    CoreUtils.getIntFromString = getIntFromString;
    function isElementInViewport(el) {
        if (!el)
            return false;
        var rect = el.getBoundingClientRect(), vw = (window.innerWidth || document.documentElement.clientWidth), vh = (window.innerHeight || document.documentElement.clientHeight);
        return (rect.top >= 0 &&
            rect.left >= 0 &&
            rect.bottom <= vh &&
            rect.right <= vw);
    }
    CoreUtils.isElementInViewport = isElementInViewport;
    function getParentsOfElement(element) {
        var parents = [];
        var d = element.ownerDocument;
        var p = element.parentNode;
        while (p != d) {
            var o = p;
            parents.push(o);
            p = o.parentNode;
        }
        return parents;
    }
    CoreUtils.getParentsOfElement = getParentsOfElement;
    var Times;
    (function (Times) {
        function formatWithAMPM(date) {
            var hours = date.getHours();
            var ampm = hours >= 12 ? 'pm' : 'am';
            hours = hours % 12;
            hours = hours ? hours : 12;
            var minutes = date.getMinutes();
            var minutesString = minutes < 10 ? '0' + minutes : minutes;
            return hours + ':' + minutesString + ' ' + ampm;
        }
        Times.formatWithAMPM = formatWithAMPM;
    })(Times = CoreUtils.Times || (CoreUtils.Times = {}));
    var Dates;
    (function (Dates) {
        function formatWithSlashes(date) {
            return date.getMonth() + 1 + '/' + date.getDate() + '/' + date.getFullYear();
        }
        Dates.formatWithSlashes = formatWithSlashes;
    })(Dates = CoreUtils.Dates || (CoreUtils.Dates = {}));
    var Strings;
    (function (Strings) {
        function isNullOrEmpty(inputString) {
            return !(typeof inputString === 'string' && inputString.trim().length > 0);
        }
        Strings.isNullOrEmpty = isNullOrEmpty;
        function escapeHtml(str) {
            var entityMap = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                '\'': '&#39;',
                '/': '&#x2F;'
            };
            return String(str).replace(/[&<>''\\/]/g, function (s) {
                return entityMap[s];
            });
        }
        Strings.escapeHtml = escapeHtml;
    })(Strings = CoreUtils.Strings || (CoreUtils.Strings = {}));
    var Numbers;
    (function (Numbers) {
        function isNumeric(n) {
            return !isNaN(parseFloat(n)) && isFinite(n);
        }
        Numbers.isNumeric = isNumeric;
    })(Numbers = CoreUtils.Numbers || (CoreUtils.Numbers = {}));
    var Urls;
    (function (Urls) {
        function parseUrlString(url) {
            var match = url.match(/^(https?:)?\/\/(([^:/?#]*)(?::([0-9]+))?)([/]{0,1}[^?#]*)(\?[^#]*|)(#.*|)$/) || {};
            var parser = {
                href: url,
                protocol: match[1] || ':',
                host: match[2] || '',
                hostname: match[3] || '',
                port: match[4] || '',
                pathname: match[5] || '',
                search: match[6] || '',
                hash: match[7] || ''
            };
            var parts = {
                protocol: parser.protocol,
                host: parser.host,
                hostname: parser.hostname,
                port: parser.port,
                pathname: parser.pathname,
                hash: parser.hash,
                search: parser.search,
                extra: ''
            };
            if (parts.hash && parts.hash.indexOf('?') !== -1) {
                var rawParts = parts.hash.split('?');
                parts.hash = rawParts[0];
                parts.search = '?' + rawParts[1];
            }
            var extraction = extractExtraPartsString(parts.pathname);
            if (parts.pathname !== extraction.replacement) {
                parts.pathname = extraction.replacement;
                parts.extra += extraction.extraPartString;
            }
            extraction = extractExtraPartsString(parts.hash);
            if (parts.hash !== extraction.replacement) {
                parts.hash = extraction.replacement;
                parts.extra += extraction.extraPartString;
            }
            extraction = extractExtraPartsString(parts.search);
            if (parts.search !== extraction.replacement) {
                parts.search = extraction.replacement;
                parts.extra += extraction.extraPartString;
            }
            return parts;
        }
        Urls.parseUrlString = parseUrlString;
        function getChurnZeroScriptSrc(doc) {
            var scriptTag = doc.querySelector('script[src*=\'churnzero.js\']');
            if (scriptTag) {
                var src = scriptTag.getAttribute('src');
                if (src) {
                    src = src.substring(0, src.lastIndexOf('/') + 1);
                    return src;
                }
            }
            return '';
        }
        Urls.getChurnZeroScriptSrc = getChurnZeroScriptSrc;
        function buildClientSideUrls(src) {
            var parsed = CoreUtils.Urls.parseUrlString(src);
            var apiUrl = 'https:', cdnUrl = 'https:', environment = 'p';
            if (parsed.host.indexOf('localhost:53156') >= 0) {
                apiUrl = 'http://localhost:53156/';
                cdnUrl = 'http://localhost:53156/external/';
                environment = 'd';
            }
            else if (parsed.host.indexOf('localhost:53157') >= 0) {
                apiUrl = 'https://analytics.localhost:53157/';
                cdnUrl = 'https://analytics.localhost:53157/external/';
                environment = 'd';
            }
            else if (parsed.host.indexOf('apptest.churnzerolabs.com') >= 0 || parsed.host.indexOf('analyticstest.churnzerolabs.com') >= 0) {
                apiUrl += '//analyticstest.churnzerolabs.com/';
                cdnUrl += '//analyticstest.churnzerolabs.com/external/';
                environment = 't';
            }
            else if (parsed.host.indexOf('appstaging.churnzerolabs.com') >= 0) {
                apiUrl += '//appstaging.churnzerolabs.com/';
                cdnUrl += '//appstaging.churnzerolabs.com/external/';
                environment = 's';
            }
            else if (parsed.host.indexOf('eu1analytics.churnzero.net') >= 0) {
                apiUrl += '//eu1analytics.churnzero.net/';
                cdnUrl += '//eu1analytics.churnzero.net/external/';
            }
            else {
                apiUrl += '//analytics.churnzero.net/';
                cdnUrl += '//analytics.churnzero.net/external/';
            }
            return {
                scriptSrc: src,
                cdn: cdnUrl,
                baseApiUrl: apiUrl,
                sockets: apiUrl + 'api/v1/sockets/',
                environment: environment
            };
        }
        Urls.buildClientSideUrls = buildClientSideUrls;
        function buildQueryStringString(queryString) {
            var queryStringProps = [], queryStringString = '';
            for (var property in queryString) {
                if (queryString.hasOwnProperty(property)) {
                    queryStringProps.push(property + '=' + queryString[property]);
                }
            }
            if (queryStringProps && queryStringProps.length > 0) {
                queryStringString = '?' + queryStringProps.join('&');
            }
            return queryStringString;
        }
        Urls.buildQueryStringString = buildQueryStringString;
        function splitAnchorBookmarkHash(hash) {
            var anchor = constants_1.hashSymbol;
            if (hash.indexOf(constants_1.hashBang) !== -1) {
                anchor = constants_1.hashBang;
            }
            var rawParts = hash.split(anchor);
            return [anchor].concat(rawParts[1]);
        }
        function extractExtraPartsStringFromParts(parts) {
            var lastIndex = parts.length - 1;
            if (lastIndex < 1) {
                return '';
            }
            var extraction = extractExtraPartsString(parts[lastIndex].value);
            parts[lastIndex].value = extraction.replacement;
            return extraction.extraPartString;
        }
        function extractExtraPartsString(value) {
            var returnValue = {
                replacement: value,
                extraPartString: ''
            };
            if (CoreUtils.Strings.isNullOrEmpty(value)) {
                return returnValue;
            }
            var search = new RegExp(constants_1.semiColonDelimiter).exec(value);
            var semiColonIndex = search === null ? -1 : search.index;
            if (semiColonIndex !== -1) {
                returnValue.extraPartString = value.substring(semiColonIndex);
                returnValue.replacement = value.substring(0, semiColonIndex);
            }
            return returnValue;
        }
        function parseUrlToLocationParts(location) {
            var url = CoreUtils.Urls.parseUrlString(location);
            var rawParts;
            var ignores = [constants_1.hashSymbol, constants_1.hashBang, constants_1.emptyString];
            var pathParts = [];
            if (!CoreUtils.Strings.isNullOrEmpty(url.pathname)) {
                rawParts = url.pathname.split(constants_1.slash);
                pathParts = rawParts.map(function (v, i) {
                    var isHidden = ignores.indexOf(v) !== -1;
                    return {
                        value: v,
                        index: i,
                        hidden: isHidden,
                        prefix: isHidden ? constants_1.emptyString : constants_1.slash,
                        include: true
                    };
                });
            }
            var hashParts = [];
            if (!CoreUtils.Strings.isNullOrEmpty(url.hash)) {
                rawParts = url.hash.split(constants_1.slash);
                var isAnchorBookmarkHash_1 = rawParts.length === 1;
                if (isAnchorBookmarkHash_1) {
                    rawParts = splitAnchorBookmarkHash(url.hash);
                }
                hashParts = rawParts.map(function (v, i) {
                    var isHidden = ignores.indexOf(v) !== -1;
                    return {
                        value: v,
                        index: i,
                        hidden: isHidden,
                        prefix: (isHidden || isAnchorBookmarkHash_1) ? constants_1.emptyString : constants_1.slash,
                        include: true
                    };
                });
            }
            var searchParts = [];
            if (!CoreUtils.Strings.isNullOrEmpty(url.search)) {
                rawParts = url.search.split(constants_1.ampersand);
                searchParts = rawParts.map(function (v, i) {
                    var isHidden = ignores.indexOf(v) !== -1;
                    return {
                        value: v,
                        index: i,
                        hidden: isHidden,
                        prefix: isHidden ? constants_1.emptyString : constants_1.ampersand,
                        include: true
                    };
                });
                var lastIndex = searchParts.length - 1, semiColonIndex = (lastIndex == 0 || !searchParts[lastIndex].value) ? -1 : searchParts[lastIndex].value.indexOf(constants_1.semiColon);
                if (semiColonIndex != -1) {
                    var semiColonParts = searchParts[lastIndex].value.substring(semiColonIndex);
                    searchParts[lastIndex].value = searchParts[lastIndex].value.substring(0, semiColonIndex);
                    var lastParts = semiColonParts.split(constants_1.semiColon);
                    searchParts = searchParts.concat(lastParts.map(function (v, i) {
                        var isHidden = ignores.indexOf(v) !== -1;
                        return {
                            value: v,
                            index: searchParts.length + i,
                            hidden: isHidden,
                            prefix: v.length === 0 ? constants_1.semiColon : constants_1.emptyString,
                            include: true
                        };
                    }));
                }
            }
            var extraParts = [];
            if (!CoreUtils.Strings.isNullOrEmpty(url.extra)) {
                rawParts = url.extra.split(new RegExp(constants_1.semiColonDelimiter));
                extraParts = rawParts.map(function (v, i) {
                    var isHidden = ignores.indexOf(v) !== -1;
                    return {
                        value: v,
                        index: i,
                        hidden: isHidden,
                        prefix: constants_1.semiColon,
                        include: true
                    };
                });
            }
            return { pathParts: pathParts, hashParts: hashParts, searchParts: searchParts, extraParts: extraParts };
        }
        Urls.parseUrlToLocationParts = parseUrlToLocationParts;
        function buildRegexFromLocationParts(location, parsedParts) {
            var rawParts;
            var url = CoreUtils.Urls.parseUrlString(location);
            if (!parsedParts) {
                parsedParts = {
                    pathParts: [],
                    hashParts: [],
                    searchParts: [],
                    extraParts: [],
                    allowChildPaths: true,
                    allowChildStates: true,
                    excludeSearchParts: true
                };
            }
            else {
                parsedParts = __assign({}, parsedParts);
            }
            if (!parsedParts.pathParts) {
                parsedParts.pathParts = [];
            }
            if (!parsedParts.hashParts) {
                parsedParts.hashParts = [];
            }
            if (!parsedParts.searchParts) {
                parsedParts.searchParts = [];
            }
            if (!parsedParts.extraParts) {
                parsedParts.extraParts = [];
            }
            if (parsedParts.allowChildPaths !== false) {
                parsedParts.allowChildPaths = true;
            }
            if (parsedParts.allowChildStates !== false) {
                parsedParts.allowChildStates = true;
            }
            if (parsedParts.excludeSearchParts !== false) {
                parsedParts.excludeSearchParts = true;
            }
            if (parsedParts.excludeExtraParts !== false) {
                parsedParts.excludeExtraParts = true;
            }
            if (url.hash && url.hash.indexOf(constants_1.questionMark) !== -1) {
                rawParts = url.hash.split(constants_1.questionMark);
                url.hash = rawParts[0];
                url.search = rawParts[1];
            }
            var makeInvisibleGroup = function (text) {
                return '(?:' + text + ')';
            };
            var mapTransform = function (partsArray, excludedValue, prefixValue, skipFirstPrefix) {
                if (excludedValue === void 0) { excludedValue = '[a-zA-Z0-9\\-_~%]+'; }
                if (prefixValue === void 0) { prefixValue = '\\/'; }
                if (skipFirstPrefix === void 0) { skipFirstPrefix = true; }
                return function (value, index) {
                    var isFirst = index === 0;
                    var replacementInfo = null;
                    (partsArray || []).forEach(function (part) {
                        if (part.index === index && replacementInfo === null) {
                            replacementInfo = part;
                        }
                    });
                    if (replacementInfo === null || replacementInfo.value.trim() === constants_1.emptyString) {
                        return undefined;
                    }
                    var replacementValue = replacementInfo.value;
                    if (isFirst && replacementValue.indexOf('?') === 0) {
                        replacementValue = replacementValue.replace('?', '');
                    }
                    replacementValue = replacementValue.replace(/[[\]\\^$.|?*+(){}#]/g, function (value) {
                        return '\\' + value;
                    });
                    var prefix = '';
                    if (typeof prefixValue === 'function') {
                        prefix = prefixValue(replacementValue, index, replacementInfo);
                    }
                    else {
                        prefix = prefixValue;
                    }
                    if (isFirst && skipFirstPrefix) {
                        prefix = '';
                    }
                    var returnValue = '';
                    if (replacementInfo.include) {
                        returnValue = replacementValue;
                    }
                    else {
                        returnValue = typeof excludedValue === 'function' ? excludedValue(replacementValue) : excludedValue;
                    }
                    return '(?:' + prefix + returnValue + ')' + (replacementInfo.include ? '' : '+');
                };
            };
            var parts;
            if (!CoreUtils.Strings.isNullOrEmpty(url.pathname)) {
                rawParts = url.pathname.split(constants_1.slash);
                parts = rawParts.map(mapTransform(parsedParts.pathParts)).filter(function (value) { return value !== undefined; });
                url.pathname = parts.join('');
            }
            if (!CoreUtils.Strings.isNullOrEmpty(url.hash)) {
                rawParts = url.hash.split(constants_1.slash);
                var isBookmarkAnchorHash_1 = rawParts.length === 1;
                if (isBookmarkAnchorHash_1) {
                    rawParts = splitAnchorBookmarkHash(url.hash);
                }
                if (parsedParts.hashParts && parsedParts.hashParts.length === 1) {
                    var temp = __assign(__assign({}, parsedParts.hashParts[0]), { index: 1, prefix: constants_1.emptyString });
                    var hashPart = new location_part_1.LocationPart();
                    hashPart.index = 0;
                    hashPart.hidden = true;
                    hashPart.include = true;
                    hashPart.prefix = constants_1.emptyString;
                    hashPart.value = constants_1.hashSymbol;
                    parsedParts.hashParts = [hashPart, temp];
                }
                parts = rawParts.map(mapTransform(parsedParts.hashParts, constants_1.urlPathChars, function (value, index, replacementInfo) {
                    if (CoreUtils.hasOwnProp(replacementInfo, 'prefix')) {
                        if (replacementInfo.prefix === constants_1.slash) {
                            return constants_1.escapedSlash;
                        }
                        return replacementInfo.prefix;
                    }
                    return isBookmarkAnchorHash_1 ? constants_1.emptyString : constants_1.escapedSlash;
                })).filter(function (value) { return value !== undefined; });
                url.hash = parts.join(constants_1.emptyString);
            }
            if (!CoreUtils.Strings.isNullOrEmpty(url.search)) {
                rawParts = url.search.split(constants_1.ampersand);
                parts = rawParts.map(mapTransform(parsedParts.searchParts, function (value) {
                    return value.split('=')[0] + "=?[a-zA-Z0-9\\-_~%]*";
                }, function (value, index, replacementInfo) {
                    if (CoreUtils.hasOwnProp(replacementInfo, 'prefix')) {
                        if (replacementInfo.prefix === constants_1.slash) {
                            return constants_1.escapedSlash;
                        }
                        return replacementInfo.prefix;
                    }
                    return constants_1.ampersand;
                })).filter(function (value) { return value !== undefined; });
                url.search = '\\?' + parts.join(constants_1.emptyString);
            }
            if (!CoreUtils.Strings.isNullOrEmpty(url.extra)) {
                rawParts = url.extra.split(new RegExp(constants_1.semiColonDelimiter));
                var allUrlCharsButSemi_1 = constants_1.urlPathChars.replace(constants_1.semiColon, constants_1.emptyString);
                parts = rawParts.map(mapTransform(parsedParts.extraParts, function (value) {
                    var kvp = value.split('='), key = kvp[0];
                    if (key === kvp)
                        return key;
                    return key + "=" + allUrlCharsButSemi_1;
                }, function (value, index, replacementInfo) {
                    if (CoreUtils.hasOwnProp(replacementInfo, 'prefix')) {
                        if (replacementInfo.prefix === constants_1.slash) {
                            return constants_1.escapedSlash;
                        }
                        return replacementInfo.prefix;
                    }
                    return constants_1.semiColon;
                })).filter(function (value) { return value !== undefined; });
                url.extra = parts.join('');
            }
            var modifiedHost = url.host.replace(/(\*|%2A){2}\./g, '(?:[^.]+\\.){0,}');
            modifiedHost = modifiedHost.replace(/(\*|%2A)/g, '[^.]+');
            var fullUrlRegex = (url.protocol !== constants_1.colon ? url.protocol : constants_1.emptyString) + "\\/\\/" + modifiedHost;
            var hasPath = !CoreUtils.Strings.isNullOrEmpty(url.pathname), hasHash = !CoreUtils.Strings.isNullOrEmpty(url.hash), hasSearch = !CoreUtils.Strings.isNullOrEmpty(url.search), hasExtraParts = !CoreUtils.Strings.isNullOrEmpty(url.extra);
            if (hasPath) {
                fullUrlRegex += url.pathname;
            }
            if (parsedParts.allowChildPaths) {
                fullUrlRegex += makeInvisibleGroup('\\/' + constants_1.urlPathChars + '\\/?') + '*';
            }
            else {
                fullUrlRegex += makeInvisibleGroup('\\/?');
            }
            var validHashSymbols = '#!';
            var hashGroup = '';
            if (hasHash) {
                var h = '';
                h = url.hash;
                if (parsedParts.allowChildStates) {
                    h += makeInvisibleGroup('\\/' + constants_1.urlPathChars + '\\/?') + '*';
                }
                else {
                    h += '\\/?';
                }
                hashGroup += h;
            }
            else if (parsedParts.allowChildStates) {
                hashGroup += makeInvisibleGroup('[' + validHashSymbols + '][^?]*') + '?';
            }
            var searchGroup = '';
            if (hasSearch && !parsedParts.excludeSearchParts) {
                searchGroup = url.search + '[^' + validHashSymbols + ']*';
            }
            else if (!hasSearch && !parsedParts.excludeSearchParts) {
            }
            else {
                searchGroup = makeInvisibleGroup('\\?[^' + validHashSymbols + ']*') + (parsedParts.excludeSearchParts ? '?' : '');
            }
            var hasHashGroup = !CoreUtils.Strings.isNullOrEmpty(hashGroup), hasSearchGroup = !CoreUtils.Strings.isNullOrEmpty(searchGroup);
            if (hasHashGroup && hasSearchGroup) {
                fullUrlRegex += '(' + makeInvisibleGroup(makeInvisibleGroup(hashGroup) + makeInvisibleGroup(searchGroup)) + '|' + makeInvisibleGroup(makeInvisibleGroup(searchGroup) + makeInvisibleGroup(hashGroup)) + ')';
            }
            else if (hasHashGroup) {
                fullUrlRegex += hashGroup;
            }
            else if (hasSearchGroup) {
                fullUrlRegex += searchGroup;
            }
            var optionalTrailingSemiColon = makeInvisibleGroup(';?'), additionalExtras = makeInvisibleGroup(';[' + constants_1.urlPathChars.replace(constants_1.semiColon, constants_1.emptyString) + ']*;?');
            if (hasExtraParts && !parsedParts.excludeExtraParts) {
                url.extra += makeInvisibleGroup(optionalTrailingSemiColon + "|" + additionalExtras) + '*';
                fullUrlRegex += url.extra;
            }
            else if (!hasExtraParts && !parsedParts.excludeExtraParts) {
            }
            else {
                fullUrlRegex += makeInvisibleGroup(optionalTrailingSemiColon + "|" + additionalExtras) + '*';
            }
            fullUrlRegex += makeInvisibleGroup(constants_1.fullStop);
            return fullUrlRegex.trim();
        }
        Urls.buildRegexFromLocationParts = buildRegexFromLocationParts;
        function checkUrlAgainstPageTag(url, pageTag) {
            if (CoreUtils.Strings.isNullOrEmpty(url) || CoreUtils.Strings.isNullOrEmpty(pageTag.location)) {
                return false;
            }
            var locationOptions = undefined;
            if (pageTag.locationOptionsJson === null || pageTag.locationOptionsJson === undefined || !pageTag.isCustomLocation) {
                locationOptions = new location_options_1.LocationOptions(CoreUtils.Urls.parseUrlToLocationParts(pageTag.location));
                if (!pageTag.isCustomLocation && !(pageTag.locationOptionsJson === null || pageTag.locationOptionsJson === undefined)) {
                    var parsedOptions = location_options_1.LocationOptions.fromJson(pageTag.locationOptionsJson);
                    locationOptions.allowChildPaths = parsedOptions.allowChildPaths;
                    locationOptions.allowChildStates = parsedOptions.allowChildStates;
                    locationOptions.excludeSearchParts = parsedOptions.excludeSearchParts;
                }
            }
            else {
                locationOptions = location_options_1.LocationOptions.fromJson(pageTag.locationOptionsJson);
            }
            var regExString = CoreUtils.Urls.buildRegexFromLocationParts(pageTag.location, locationOptions);
            var regEx = new RegExp(regExString);
            return regEx.test(url);
        }
        Urls.checkUrlAgainstPageTag = checkUrlAgainstPageTag;
    })(Urls = CoreUtils.Urls || (CoreUtils.Urls = {}));
    function noop() {
    }
    CoreUtils.noop = noop;
    function isObjectDigestible(object) {
        return object.onDigest !== undefined;
    }
    CoreUtils.isObjectDigestible = isObjectDigestible;
    function isObject(val) {
        return val === Object(val);
    }
    CoreUtils.isObject = isObject;
    function isArray(val) {
        return Array.isArray(val);
    }
    CoreUtils.isArray = isArray;
    var primitiveTypes = ['string', 'number', 'bigint', 'boolean', 'undefined', 'symbol', 'null'];
    function isPrimitiveType(value) {
        return primitiveTypes.indexOf(typeof value) > -1;
    }
    CoreUtils.isPrimitiveType = isPrimitiveType;
    function clone(original) {
        if (original === null || original === undefined) {
            return original;
        }
        if (Array.isArray(original)) {
            var temp = { value: original };
            return clone(temp).value;
        }
        var cloned;
        if (isPrimitiveType(original)) {
            cloned = original;
            return cloned;
        }
        cloned = Object.create(original);
        Object.keys(original).forEach(function (k) {
            cloned[k] = original[k];
        });
        for (var attribute in cloned) {
            if (cloned[attribute] instanceof Date) {
                var copy = new Date();
                copy.setTime(cloned[attribute].getTime());
                cloned[attribute] = copy;
            }
            else if (Array.isArray(cloned[attribute])) {
                var copy = cloned[attribute].map(function (item) { return clone(item); });
                cloned[attribute] = copy;
            }
            else if (typeof cloned[attribute] === 'object') {
                cloned[attribute] = clone(cloned[attribute]);
            }
        }
        return cloned;
    }
    CoreUtils.clone = clone;
    function numKeys(val) {
        var res = 0;
        for (var k in val) {
            if (val.hasOwnProperty(k))
                res++;
        }
        return res;
    }
    CoreUtils.numKeys = numKeys;
    function isString(x) {
        return Object.prototype.toString.call(x) === '[object String]';
    }
    CoreUtils.isString = isString;
    function isNullOrUndefined(x) {
        return typeof x === 'undefined' || x === null;
    }
    CoreUtils.isNullOrUndefined = isNullOrUndefined;
    function buildEventMapSelector(e) {
        var selector = e.selector;
        if (!selector || selector.length === 0 || selector[selector.length - 1] === '*' || (e.selectorTypeId === enums_1.SelectorTypes.Custom && e.excludeChildren) || (e.selectorTypeId === enums_1.SelectorTypes.Intermediate && e.excludeChildren)) {
            return selector;
        }
        return selector + ', ' + selector + ' *';
    }
    CoreUtils.buildEventMapSelector = buildEventMapSelector;
    function concatEventMapSelectors(eventMaps) {
        return eventMaps.map(buildEventMapSelector).filter(function (selector) {
            return selector && selector.length > 0;
        }).join(', ');
    }
    CoreUtils.concatEventMapSelectors = concatEventMapSelectors;
    function concatWalkthroughSelectors(walkthroughs) {
        return walkthroughs.map(function (e) {
            return buildEventMapSelector(e.triggerConfig);
        }).filter(function (selector) {
            return selector && selector.length > 0;
        }).join(', ');
    }
    CoreUtils.concatWalkthroughSelectors = concatWalkthroughSelectors;
    function sortArrayBy(propertyName) {
        return function (a, b) {
            if (a[propertyName] < b[propertyName])
                return -1;
            if (a[propertyName] > b[propertyName])
                return 1;
            return 0;
        };
    }
    CoreUtils.sortArrayBy = sortArrayBy;
    function hasOwnProp(thisArg, prop) {
        return Object.prototype.hasOwnProperty.call(thisArg, prop);
    }
    CoreUtils.hasOwnProp = hasOwnProp;
    function debounce(func, waitMs) {
        if (waitMs === void 0) { waitMs = 100; }
        var timeout;
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var toCall = function () {
                timeout = null;
                func.apply(void 0, args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(toCall, waitMs);
        };
    }
    CoreUtils.debounce = debounce;
})(CoreUtils = exports.CoreUtils || (exports.CoreUtils = {}));
//# sourceMappingURL=core-utils.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/utils/data-type-utils.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/utils/data-type-utils.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataTypeUtils = void 0;
var DataTypeUtils = (function () {
    function DataTypeUtils() {
    }
    DataTypeUtils.newGuid = function () {
        var s4 = function () {
            return Math.floor((1 + Math.random()) * 0x10000)
                .toString(16)
                .substring(1);
        };
        return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
            s4() + '-' + s4() + s4() + s4();
    };
    DataTypeUtils.isStringNullOrEmpty = function (input) {
        return !(typeof input === 'string' && input.trim().length > 0);
    };
    return DataTypeUtils;
}());
exports.DataTypeUtils = DataTypeUtils;
//# sourceMappingURL=data-type-utils.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/utils/iframe-utils.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/utils/iframe-utils.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.iFrameUtils = void 0;
var iFrameUtils;
(function (iFrameUtils) {
    var transportSalt = 'CZTPM';
    var transportKey = '30DDF99A-B7F0-4DB2-BCEC-AA5DD0A4561B';
    var TransportMessage = (function () {
        function TransportMessage() {
        }
        return TransportMessage;
    }());
    iFrameUtils.TransportMessage = TransportMessage;
    function attachTransportMessageListener(windowRef, origin, callback, JSONRef, onError) {
        var unwind = function (e) {
            try {
                if (!origin) {
                    return;
                }
                var o_1 = e.origin;
                if (origin !== '*') {
                    var allowedOrigins = origin.split(',');
                    var matchFound_1 = false;
                    allowedOrigins.forEach(function (os) {
                        if (!matchFound_1 && os === o_1) {
                            matchFound_1 = true;
                        }
                    });
                    if (!matchFound_1) {
                        console.log('!*!- Allowed Origins Violated (a, r)', origin, o_1);
                        return;
                    }
                }
                var transportMessage = void 0;
                if (Object.prototype.toString.call(e.data) === '[object String]' && e.data.indexOf(transportSalt) === 0) {
                    var message = e.data.substr(transportSalt.length);
                    if (!message) {
                        return;
                    }
                    var unscrambled = scramble(message, transportKey, true);
                    if (!unscrambled) {
                        return;
                    }
                    transportMessage = (JSONRef || JSON).parse(unscrambled);
                }
                else {
                    console.log('e.data not intended for CZ', e.data);
                    return;
                }
                if (transportMessage && transportMessage.hasOwnProperty('code') && transportMessage.hasOwnProperty('data')) {
                    callback(transportMessage, e);
                }
            }
            catch (ex) {
                if (typeof onError === 'function')
                    onError(ex, e);
            }
        };
        if (windowRef.addEventListener) {
            windowRef.addEventListener('message', unwind, false);
        }
        else if (windowRef.attachEvent) {
            windowRef.attachEvent('onmessage', unwind);
        }
        return unwind;
    }
    iFrameUtils.attachTransportMessageListener = attachTransportMessageListener;
    function buildTransportMessage(code, data) {
        return {
            code: code,
            data: data
        };
    }
    iFrameUtils.buildTransportMessage = buildTransportMessage;
    function scramble(text, key, reverse) {
        var bound = 0x10000;
        return String.fromCharCode.apply(null, text.split('').map(function (v, i) {
            var rotation = key[i % key.length].charCodeAt();
            if (reverse)
                rotation = -rotation;
            return (v.charCodeAt() + rotation + bound) % bound;
        }));
    }
    function encrypt(text) {
        return transportSalt + scramble(text, transportKey, false);
    }
    iFrameUtils.encrypt = encrypt;
    function getElementBorderHeight(element) {
        var bTop = parseInt(element.style.borderTopWidth, 10) || 0, bBottom = parseInt(element.style.borderBottomWidth, 10) || 0;
        return bTop + bBottom;
    }
    function setFrameHeightBySourceAtInterval(sourceElement, targetFrame, timeoutMs, onShownCallback, onResizeCallback) {
        var win = targetFrame.contentWindow;
        var currentHeight = 0, sizeAdjustTimeout, isVisible = false;
        targetFrame.style.visibility = 'hidden';
        var resizeInterval = win.setInterval(function () {
            var br = sourceElement.getBoundingClientRect(), borderHeight = getElementBorderHeight(targetFrame), newHeight = br.height + borderHeight;
            if (newHeight <= currentHeight) {
                return;
            }
            win.clearInterval(sizeAdjustTimeout);
            currentHeight = newHeight;
            targetFrame.style.height = currentHeight + "px";
            onResizeCallback === null || onResizeCallback === void 0 ? void 0 : onResizeCallback();
            if (isVisible) {
                return;
            }
            sizeAdjustTimeout = win.setTimeout(function () {
                targetFrame.style.removeProperty('visibility');
                isVisible = true;
                onShownCallback === null || onShownCallback === void 0 ? void 0 : onShownCallback();
            }, 200);
        }, timeoutMs);
        return function () {
            win.clearTimeout(sizeAdjustTimeout);
            win.clearTimeout(resizeInterval);
        };
    }
    iFrameUtils.setFrameHeightBySourceAtInterval = setFrameHeightBySourceAtInterval;
    function getFrameResizeObserver(targetFrame, onShownCallback, onResizeCallback) {
        var win = targetFrame.contentWindow;
        targetFrame.style.visibility = 'hidden';
        var computedFrameHeight = 0, sizeAdjustTimeout, isVisible = false;
        return new ResizeObserver(function (entries) {
            var entryLen = entries.length;
            for (var i = 0; i < entryLen; i++) {
                var entry = entries[i], borderHeight = getElementBorderHeight(targetFrame);
                var height = entry.contentRect.height + borderHeight;
                if (height <= computedFrameHeight) {
                    continue;
                }
                win.clearInterval(sizeAdjustTimeout);
                computedFrameHeight = height;
                targetFrame.style.height = computedFrameHeight + "px";
                onResizeCallback === null || onResizeCallback === void 0 ? void 0 : onResizeCallback();
                if (isVisible) {
                    continue;
                }
                sizeAdjustTimeout = win.setTimeout(function () {
                    targetFrame.style.removeProperty('visibility');
                    isVisible = true;
                    onShownCallback === null || onShownCallback === void 0 ? void 0 : onShownCallback();
                }, 200);
            }
        });
    }
    iFrameUtils.getFrameResizeObserver = getFrameResizeObserver;
})(iFrameUtils = exports.iFrameUtils || (exports.iFrameUtils = {}));
//# sourceMappingURL=iframe-utils.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/utils/model-utils.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/utils/model-utils.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ModelUtils = void 0;
var core_utils_1 = __webpack_require__(/*! ./core-utils */ "./node_modules/@churnzero/clientlibs/dist/main/utils/core-utils.js");
var ModelUtils = (function () {
    function ModelUtils() {
    }
    ModelUtils.getNonMutatedValue = function (target, val) {
        var objectType = Object.prototype.toString.call(val);
        if (objectType === '[object Object]' && 'assign' in Object)
            return Object.assign({}, val);
        if (objectType === '[object Array]')
            return [].concat(val);
        if (objectType === '[object Function]') {
            return val.bind(target);
        }
        return val;
    };
    ModelUtils.assignDefined = function (target) {
        var sources = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            sources[_i - 1] = arguments[_i];
        }
        var sl = sources.length;
        for (var i = 0; i < sl; i++) {
            var source = sources[i];
            for (var prop in source) {
                if (!core_utils_1.CoreUtils.hasOwnProp(target, prop)) {
                    continue;
                }
                var val = source[prop];
                if (typeof val === 'undefined') {
                    continue;
                }
                target[prop] = ModelUtils.getNonMutatedValue(target, val);
            }
        }
        return target;
    };
    ModelUtils.create = function (dest, input, strict) {
        if (strict === void 0) { strict = false; }
        if (input) {
            Object.keys(input).forEach(function (k) {
                if (strict && !core_utils_1.CoreUtils.hasOwnProp(dest, k)) {
                    return;
                }
                var val = input[k];
                dest[k] = ModelUtils.getNonMutatedValue(dest, val);
            });
        }
        return dest;
    };
    return ModelUtils;
}());
exports.ModelUtils = ModelUtils;
//# sourceMappingURL=model-utils.js.map

/***/ }),

/***/ "./node_modules/@churnzero/clientlibs/dist/main/utils/style-utils.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@churnzero/clientlibs/dist/main/utils/style-utils.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StyleUtils = void 0;
var core_utils_1 = __webpack_require__(/*! ./core-utils */ "./node_modules/@churnzero/clientlibs/dist/main/utils/core-utils.js");
var StyleUtils;
(function (StyleUtils) {
    function appendStyle(styleString) {
        return function (i, s) {
            return (s || '') + (styleString || '');
        };
    }
    StyleUtils.appendStyle = appendStyle;
    function replaceStyleValue(oldValue, newValue) {
        return function (i, s) {
            return (s || '').replace(new RegExp(oldValue, 'g'), newValue);
        };
    }
    StyleUtils.replaceStyleValue = replaceStyleValue;
    function whichTransitionEvent() {
        var t;
        var el = document.createElement('fakeelement');
        var transitions = {
            'transition': 'transitionend',
            'OTransition': 'oTransitionEnd',
            'MozTransition': 'transitionend',
            'WebkitTransition': 'webkitTransitionEnd'
        };
        for (t in transitions) {
            if (el.style[t] !== undefined) {
                return transitions[t];
            }
        }
    }
    StyleUtils.whichTransitionEvent = whichTransitionEvent;
    function camelCaseToDash(myStr) {
        return !myStr ? null : myStr.replace(/([A-Z])/g, function (g) {
            return '-' + g[0].toLowerCase();
        });
    }
    StyleUtils.camelCaseToDash = camelCaseToDash;
    function isInViewport(el) {
        return core_utils_1.CoreUtils.isElementInViewport(el);
    }
    StyleUtils.isInViewport = isInViewport;
    function cssEscape(value) {
        if (arguments.length == 0) {
            return '';
        }
        var string = String(value);
        var length = string.length;
        var index = -1;
        var codeUnit;
        var result = '';
        var firstCodeUnit = string.charCodeAt(0);
        while (++index < length) {
            codeUnit = string.charCodeAt(index);
            if (codeUnit == 0x0000) {
                result += '\uFFFD';
                continue;
            }
            if ((codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
                (index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
                (index == 1 &&
                    codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
                    firstCodeUnit == 0x002D)) {
                result += '\\' + codeUnit.toString(16) + ' ';
                continue;
            }
            if (index == 0 &&
                length == 1 &&
                codeUnit == 0x002D) {
                result += '\\' + string.charAt(index);
                continue;
            }
            if (codeUnit >= 0x0080 ||
                codeUnit == 0x002D ||
                codeUnit == 0x005F ||
                codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
                codeUnit >= 0x0041 && codeUnit <= 0x005A ||
                codeUnit >= 0x0061 && codeUnit <= 0x007A) {
                result += string.charAt(index);
                continue;
            }
            result += '\\' + string.charAt(index);
        }
        return result;
    }
    StyleUtils.cssEscape = cssEscape;
    function wrapInRule(selector, rules) {
        return selector + " { " + rules.join(' ') + " }";
    }
    StyleUtils.wrapInRule = wrapInRule;
    function mapBrandingItemToCSSProps(brandingItem) {
        var rules = [];
        for (var k in brandingItem) {
            if (!core_utils_1.CoreUtils.hasOwnProp(brandingItem, k))
                continue;
            var rule = brandingItem[k];
            if ((rule || '').toString().trim().length === 0)
                continue;
            var ruleToUse = typeof rule === 'number' ? rule + "px" : rule;
            rules.push(StyleUtils.camelCaseToDash(k) + ':' + ruleToUse + ' !important;');
        }
        return rules;
    }
    StyleUtils.mapBrandingItemToCSSProps = mapBrandingItemToCSSProps;
    function inheritValue(to, property, from) {
        if (!to || !from || !property) {
            return;
        }
        to[property] = to[property] || from[property];
    }
    StyleUtils.inheritValue = inheritValue;
    StyleUtils.froalaViewerStyle = 'html{margin:0px;height:auto;}body{height:auto;padding:10px;background:transparent;color:#000000;position:relative;z-index: 2;-webkit-user-select:auto;margin:0px;overflow:hidden;min-height:20px;}body:after{content:\'\';display:block;clear:both;}body::-moz-selection{background:#b5d6fd;color:#000;}body::selection{background:#b5d6fd;color:#000;}body, body:focus{outline: transparent solid 0px;}body{background: transparent; position: relative; z-index: 2; user-select: auto;}body a{user-select: auto;}body.fr-disabled{user-select: none;}body [contenteditable=\'true\']{outline: transparent solid 0px;}body img{cursor: pointer;}body table td.fr-selected-cell, body table th.fr-selected-cell{border: 1px double rgb(30, 136, 229);}body table tr{user-select: none;}body table td, body table th{user-select: text;}body .fr-no-selection table td, body .fr-no-selection table th{user-select: none;}body .fr-video{user-select: none;}body .fr-video::after{position: absolute; content: \'\'; z-index: 1; top: 0px; left: 0px; right: 0px; bottom: 0px; cursor: pointer; display: block; background: transparent;}body .fr-video.fr-active > *{z-index: 2; position: relative;}body .fr-video > *{box-sizing: content-box; max-width: 100%; border: none;}body{overflow-wrap: break-word;}body span[style~=\'color:\'] a{color: inherit;}body strong{font-weight: 700;}body table{border: none; border-collapse: collapse; empty-cells: show; max-width: 100%;}body table td{min-width: 5px;}body table.fr-dashed-borders td, body table.fr-dashed-borders th{border-style: dashed;}body table.fr-alternate-rows tbody tr:nth-child(2n){background: rgb(245, 245, 245);}body table td, body table th{border: 1px solid rgb(221, 221, 221);}body table td:empty, body table th:empty{height: 20px;}body table td.fr-highlighted, body table th.fr-highlighted{border: 1px double red;}body table td.fr-thick, body table th.fr-thick{border-width: 2px;}body table th{background: rgb(230, 230, 230);}body hr{clear: both; user-select: none; break-after: page;}body .fr-file{position: relative;}body .fr-file::after{position: relative; content: \'📎\'; font-weight: 400;}body pre{white-space: pre-wrap; overflow-wrap: break-word; overflow: visible;}body[dir=\'rtl\'] blockquote{border-left: none; border-right: 2px solid rgb(94, 53, 177); margin-right: 0px; padding-right: 5px; padding-left: 0px;}body[dir=\'rtl\'] blockquote blockquote{border-color: rgb(0, 188, 212);}body[dir=\'rtl\'] blockquote blockquote blockquote{border-color: rgb(67, 160, 71);}body blockquote{border-left: 2px solid rgb(94, 53, 177); margin-left: 0px; padding-left: 5px; color: rgb(94, 53, 177);}body blockquote blockquote{border-color: rgb(0, 188, 212); color: rgb(0, 188, 212);}body blockquote blockquote blockquote{border-color: rgb(67, 160, 71); color: rgb(67, 160, 71);}body span.fr-emoticon{font-weight: 400; font-family: \'Apple Color Emoji\', \'Segoe UI Emoji\', NotoColorEmoji, \'Segoe UI Symbol\', \'Android Emoji\', EmojiSymbols; display: inline; line-height: 0;}body span.fr-emoticon.fr-emoticon-img{font-size: inherit; height: 1em; width: 1em; min-height: 20px; min-width: 20px; display: inline-block; margin: -0.1em 0.1em 0.1em; line-height: 1; vertical-align: middle; background-repeat: no-repeat !important;}body .fr-text-gray{color: rgb(170, 170, 170) !important;}body .fr-text-bordered{border-top: 1px solid rgb(34, 34, 34); border-bottom: 1px solid rgb(34, 34, 34); padding: 10px 0px;}body .fr-text-spaced{letter-spacing: 1px;}body .fr-text-uppercase{text-transform: uppercase;}body .fr-class-highlighted{background-color: rgb(255, 255, 0);}body .fr-class-code{border-color: rgb(204, 204, 204); border-radius: 2px; background: rgb(245, 245, 245); padding: 10px; font-family: \'Courier New\', Courier, monospace;}body .fr-class-transparency{opacity: 0.5;}body img{position: relative; max-width: 100%;}body img.fr-dib{margin: 5px auto; display: block; float: none; vertical-align: top;}body img.fr-dib.fr-fil{margin-left: 0px; text-align: left;}body img.fr-dib.fr-fir{margin-right: 0px; text-align: right;}body img.fr-dii{display: inline-block; float: none; vertical-align: bottom; margin-left: 5px; margin-right: 5px; max-width: calc(100% - 10px);}body img.fr-dii.fr-fil{float: left; margin: 5px 5px 5px 0px; max-width: calc(100% - 5px);}body img.fr-dii.fr-fir{float: right; margin: 5px 0px 5px 5px; max-width: calc(100% - 5px);}body span.fr-img-caption{position: relative; max-width: 100%;}body span.fr-img-caption.fr-dib{margin: 5px auto; display: block; float: none; vertical-align: top;}body span.fr-img-caption.fr-dib.fr-fil{margin-left: 0px; text-align: left;}body span.fr-img-caption.fr-dib.fr-fir{margin-right: 0px; text-align: right;}body span.fr-img-caption.fr-dii{display: inline-block; float: none; vertical-align: bottom; margin-left: 5px; margin-right: 5px; max-width: calc(100% - 10px);}body span.fr-img-caption.fr-dii.fr-fil{float: left; margin: 5px 5px 5px 0px; max-width: calc(100% - 5px);}body span.fr-img-caption.fr-dii.fr-fir{float: right; margin: 5px 0px 5px 5px; max-width: calc(100% - 5px);}body .fr-video{text-align: center; position: relative;}body .fr-video.fr-rv{padding-bottom: 56.25%; padding-top: 30px; height: 0px; overflow: hidden;}body .fr-video.fr-rv > iframe, body .fr-video.fr-rv embed, body .fr-video.fr-rv object{top: 0px; left: 0px; width: 100%; height: 100%; position: absolute !important;}body .fr-video > *{box-sizing: content-box; max-width: 100%; border: none;}body .fr-video.fr-dvb{display: block; clear: both;}body .fr-video.fr-dvb.fr-fvl{text-align: left;}body .fr-video.fr-dvb.fr-fvr{text-align: right;}body .fr-video.fr-dvi{display: inline-block;}body .fr-video.fr-dvi.fr-fvl{float: left;}body .fr-video.fr-dvi.fr-fvr{float: right;}body a.fr-strong{font-weight: 700;}body a.fr-green{color: green;}body .fr-img-caption{text-align: center;}body .fr-img-caption .fr-img-wrap{padding: 0px; display: inline-block; margin: auto; text-align: center; width: 100%;}body .fr-img-caption .fr-img-wrap img{display: block; margin: auto; width: 100%;}body .fr-img-caption .fr-img-wrap > span{margin: auto; display: block; padding: 5px 5px 10px; font-size: 14px; font-weight: 400; box-sizing: border-box; opacity: 0.9; width: 100%; text-align: center;}body button.fr-rounded, body input.fr-rounded, body textarea.fr-rounded{border-radius: 10px; background-clip: padding-box;}body button.fr-large, body input.fr-large, body textarea.fr-large{font-size: 24px;}';
})(StyleUtils = exports.StyleUtils || (exports.StyleUtils = {}));
//# sourceMappingURL=style-utils.js.map

/***/ }),

/***/ "./node_modules/es6-promise/dist/es6-promise.js":
/*!******************************************************!*\
  !*** ./node_modules/es6-promise/dist/es6-promise.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.5+7f2b526d
 */

(function (global, factory) {
	 true ? module.exports = factory() :
	0;
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  var type = typeof x;
  return x !== null && (type === 'object' || type === 'function');
}

function isFunction(x) {
  return typeof x === 'function';
}



var _isArray = void 0;
if (Array.isArray) {
  _isArray = Array.isArray;
} else {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
}

var isArray = _isArray;

var len = 0;
var vertxNext = void 0;
var customSchedulerFn = void 0;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  if (typeof vertxNext !== 'undefined') {
    return function () {
      vertxNext(flush);
    };
  }

  return useSetTimeout();
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var vertx = Function('return this')().require('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = void 0;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && "function" === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;


  if (_state) {
    var callback = arguments[_state - 1];
    asap(function () {
      return invokeCallback(_state, child, callback, parent._result);
    });
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve$1(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(2);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

var TRY_CATCH_ERROR = { error: null };

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function getThen(promise) {
  try {
    return promise.then;
  } catch (error) {
    TRY_CATCH_ERROR.error = error;
    return TRY_CATCH_ERROR;
  }
}

function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
  try {
    then$$1.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then$$1) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then$$1, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return resolve(promise, value);
    }, function (reason) {
      return reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$1) {
  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$1 === TRY_CATCH_ERROR) {
      reject(promise, TRY_CATCH_ERROR.error);
      TRY_CATCH_ERROR.error = null;
    } else if (then$$1 === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$1)) {
      handleForeignThenable(promise, maybeThenable, then$$1);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function resolve(promise, value) {
  if (promise === value) {
    reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    handleMaybeThenable(promise, value, getThen(value));
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;


  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = void 0,
      callback = void 0,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function tryCatch(callback, detail) {
  try {
    return callback(detail);
  } catch (e) {
    TRY_CATCH_ERROR.error = e;
    return TRY_CATCH_ERROR;
  }
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = void 0,
      error = void 0,
      succeeded = void 0,
      failed = void 0;

  if (hasCallback) {
    value = tryCatch(callback, detail);

    if (value === TRY_CATCH_ERROR) {
      failed = true;
      error = value.error;
      value.error = null;
    } else {
      succeeded = true;
    }

    if (promise === value) {
      reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
    succeeded = true;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
    resolve(promise, value);
  } else if (failed) {
    reject(promise, error);
  } else if (settled === FULFILLED) {
    fulfill(promise, value);
  } else if (settled === REJECTED) {
    reject(promise, value);
  }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      resolve(promise, value);
    }, function rejectPromise(reason) {
      reject(promise, reason);
    });
  } catch (e) {
    reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
}

var Enumerator = function () {
  function Enumerator(Constructor, input) {
    this._instanceConstructor = Constructor;
    this.promise = new Constructor(noop);

    if (!this.promise[PROMISE_ID]) {
      makePromise(this.promise);
    }

    if (isArray(input)) {
      this.length = input.length;
      this._remaining = input.length;

      this._result = new Array(this.length);

      if (this.length === 0) {
        fulfill(this.promise, this._result);
      } else {
        this.length = this.length || 0;
        this._enumerate(input);
        if (this._remaining === 0) {
          fulfill(this.promise, this._result);
        }
      }
    } else {
      reject(this.promise, validationError());
    }
  }

  Enumerator.prototype._enumerate = function _enumerate(input) {
    for (var i = 0; this._state === PENDING && i < input.length; i++) {
      this._eachEntry(input[i], i);
    }
  };

  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
    var c = this._instanceConstructor;
    var resolve$$1 = c.resolve;


    if (resolve$$1 === resolve$1) {
      var _then = getThen(entry);

      if (_then === then && entry._state !== PENDING) {
        this._settledAt(entry._state, i, entry._result);
      } else if (typeof _then !== 'function') {
        this._remaining--;
        this._result[i] = entry;
      } else if (c === Promise$1) {
        var promise = new c(noop);
        handleMaybeThenable(promise, entry, _then);
        this._willSettleAt(promise, i);
      } else {
        this._willSettleAt(new c(function (resolve$$1) {
          return resolve$$1(entry);
        }), i);
      }
    } else {
      this._willSettleAt(resolve$$1(entry), i);
    }
  };

  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
    var promise = this.promise;


    if (promise._state === PENDING) {
      this._remaining--;

      if (state === REJECTED) {
        reject(promise, value);
      } else {
        this._result[i] = value;
      }
    }

    if (this._remaining === 0) {
      fulfill(promise, this._result);
    }
  };

  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
    var enumerator = this;

    subscribe(promise, undefined, function (value) {
      return enumerator._settledAt(FULFILLED, i, value);
    }, function (reason) {
      return enumerator._settledAt(REJECTED, i, reason);
    });
  };

  return Enumerator;
}();

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries) {
  return new Enumerator(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject$1(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {Function} resolver
  Useful for tooling.
  @constructor
*/

var Promise$1 = function () {
  function Promise(resolver) {
    this[PROMISE_ID] = nextId();
    this._result = this._state = undefined;
    this._subscribers = [];

    if (noop !== resolver) {
      typeof resolver !== 'function' && needsResolver();
      this instanceof Promise ? initializePromise(this, resolver) : needsNew();
    }
  }

  /**
  The primary way of interacting with a promise is through its `then` method,
  which registers callbacks to receive either a promise's eventual value or the
  reason why the promise cannot be fulfilled.
   ```js
  findUser().then(function(user){
    // user is available
  }, function(reason){
    // user is unavailable, and you are given the reason why
  });
  ```
   Chaining
  --------
   The return value of `then` is itself a promise.  This second, 'downstream'
  promise is resolved with the return value of the first promise's fulfillment
  or rejection handler, or rejected if the handler throws an exception.
   ```js
  findUser().then(function (user) {
    return user.name;
  }, function (reason) {
    return 'default name';
  }).then(function (userName) {
    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
    // will be `'default name'`
  });
   findUser().then(function (user) {
    throw new Error('Found user, but still unhappy');
  }, function (reason) {
    throw new Error('`findUser` rejected and we're unhappy');
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
  });
  ```
  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
   ```js
  findUser().then(function (user) {
    throw new PedagogicalException('Upstream error');
  }).then(function (value) {
    // never reached
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // The `PedgagocialException` is propagated all the way down to here
  });
  ```
   Assimilation
  ------------
   Sometimes the value you want to propagate to a downstream promise can only be
  retrieved asynchronously. This can be achieved by returning a promise in the
  fulfillment or rejection handler. The downstream promise will then be pending
  until the returned promise is settled. This is called *assimilation*.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // The user's comments are now available
  });
  ```
   If the assimliated promise rejects, then the downstream promise will also reject.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // If `findCommentsByAuthor` fulfills, we'll have the value here
  }, function (reason) {
    // If `findCommentsByAuthor` rejects, we'll have the reason here
  });
  ```
   Simple Example
  --------------
   Synchronous Example
   ```javascript
  let result;
   try {
    result = findResult();
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
  findResult(function(result, err){
    if (err) {
      // failure
    } else {
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findResult().then(function(result){
    // success
  }, function(reason){
    // failure
  });
  ```
   Advanced Example
  --------------
   Synchronous Example
   ```javascript
  let author, books;
   try {
    author = findAuthor();
    books  = findBooksByAuthor(author);
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
   function foundBooks(books) {
   }
   function failure(reason) {
   }
   findAuthor(function(author, err){
    if (err) {
      failure(err);
      // failure
    } else {
      try {
        findBoooksByAuthor(author, function(books, err) {
          if (err) {
            failure(err);
          } else {
            try {
              foundBooks(books);
            } catch(reason) {
              failure(reason);
            }
          }
        });
      } catch(error) {
        failure(err);
      }
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findAuthor().
    then(findBooksByAuthor).
    then(function(books){
      // found books
  }).catch(function(reason){
    // something went wrong
  });
  ```
   @method then
  @param {Function} onFulfilled
  @param {Function} onRejected
  Useful for tooling.
  @return {Promise}
  */

  /**
  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
  as the catch block of a try/catch statement.
  ```js
  function findAuthor(){
  throw new Error('couldn't find that author');
  }
  // synchronous
  try {
  findAuthor();
  } catch(reason) {
  // something went wrong
  }
  // async with promises
  findAuthor().catch(function(reason){
  // something went wrong
  });
  ```
  @method catch
  @param {Function} onRejection
  Useful for tooling.
  @return {Promise}
  */


  Promise.prototype.catch = function _catch(onRejection) {
    return this.then(null, onRejection);
  };

  /**
    `finally` will be invoked regardless of the promise's fate just as native
    try/catch/finally behaves
  
    Synchronous example:
  
    ```js
    findAuthor() {
      if (Math.random() > 0.5) {
        throw new Error();
      }
      return new Author();
    }
  
    try {
      return findAuthor(); // succeed or fail
    } catch(error) {
      return findOtherAuther();
    } finally {
      // always runs
      // doesn't affect the return value
    }
    ```
  
    Asynchronous example:
  
    ```js
    findAuthor().catch(function(reason){
      return findOtherAuther();
    }).finally(function(){
      // author was either found, or not
    });
    ```
  
    @method finally
    @param {Function} callback
    @return {Promise}
  */


  Promise.prototype.finally = function _finally(callback) {
    var promise = this;
    var constructor = promise.constructor;

    if (isFunction(callback)) {
      return promise.then(function (value) {
        return constructor.resolve(callback()).then(function () {
          return value;
        });
      }, function (reason) {
        return constructor.resolve(callback()).then(function () {
          throw reason;
        });
      });
    }

    return promise.then(callback, callback);
  };

  return Promise;
}();

Promise$1.prototype.then = then;
Promise$1.all = all;
Promise$1.race = race;
Promise$1.resolve = resolve$1;
Promise$1.reject = reject$1;
Promise$1._setScheduler = setScheduler;
Promise$1._setAsap = setAsap;
Promise$1._asap = asap;

/*global self*/
function polyfill() {
  var local = void 0;

  if (typeof __webpack_require__.g !== 'undefined') {
    local = __webpack_require__.g;
  } else if (typeof self !== 'undefined') {
    local = self;
  } else {
    try {
      local = Function('return this')();
    } catch (e) {
      throw new Error('polyfill failed because global object is unavailable in this environment');
    }
  }

  var P = local.Promise;

  if (P) {
    var promiseToString = null;
    try {
      promiseToString = Object.prototype.toString.call(P.resolve());
    } catch (e) {
      // silently ignored
    }

    if (promiseToString === '[object Promise]' && !P.cast) {
      return;
    }
  }

  local.Promise = Promise$1;
}

// Strange compat..
Promise$1.polyfill = polyfill;
Promise$1.Promise = Promise$1;

return Promise$1;

})));



//# sourceMappingURL=es6-promise.map


/***/ }),

/***/ "./src/templateCache/announcementNpsTemplate.html":
/*!********************************************************!*\
  !*** ./src/templateCache/announcementNpsTemplate.html ***!
  \********************************************************/
/***/ (function(module) {

// Module
var code = "<div class=\"cz-announcement cz-sidebar-note cz-hover-click \" style=\"display: block !important;\" data-message-id=\"{{id}}\" data-info-message=\"{{showInfoMessageString}}\"\r\n     id=\"cz-sidebar-note-{{sequence}}\">\r\n    <div align=\"center\" class=\"cz-nps-container\">\r\n        <div style=\"{{NpsLogoStyle}}\">\r\n            <div style=\"width: 33.3%; padding: 0 15px;\">\r\n                <img src=\"{{NpsLogoUrl}}\" !inline style=\"display: block; max-width: 100%; height: auto\">\r\n            </div>\r\n        </div>\r\n        <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"table\">\r\n            <!-- QUESTION -->\r\n            <tr>\r\n                <td align=\"center\" class=\"survey\">\r\n                    <table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\"\r\n                           class=\"questiontextcontainer\">\r\n                        <tr>\r\n                            <td align=\"center\" class=\"questiontext\" dir=\"ltr\">{{NpsQuestion}}</td>\r\n                        </tr>\r\n                    </table>\r\n                </td>\r\n            </tr>\r\n        </table>\r\n        <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"table\" style=\"width: inherit\">\r\n            <!-- LABELS -->\r\n            <tr class=\"{{LabelsContainerClass}}\">\r\n                <td width=\"9\"></td>\r\n                <td class=\"labels\">\r\n                    <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\r\n                        <tr>\r\n                            <td class=\"left\" align=\"left\" width=\"50%\" style=\"padding-right: 20px!important;\">{{NpsLowScoreText}}</td>\r\n                            <td class=\"right\" align=\"right\" width=\"50%\" style=\"padding-left: 20px!important;\">{{NpsHighScoreText}}</td>\r\n                        </tr>\r\n                    </table>\r\n                </td>\r\n                <td width=\"9\"></td>\r\n            </tr>\r\n\r\n            <!-- SCORES -->\r\n            <tr>\r\n                <td width=\"9\"></td>\r\n                <td class=\"scores {{AdditionalScoresClass}}\">\r\n                    <!-- 10 -->\r\n                    {{Buttons}}\r\n\r\n                </td>\r\n                <td width=\"9\"></td>\r\n            </tr>\r\n        </table>\r\n\r\n    </div>\r\n    <span class=\"cz-announcement-timestamp\">{{at}}</span>\r\n</div>\r\n";
// Exports
module.exports = code;

/***/ }),

/***/ "./src/templateCache/announcementNpsTemplatePanel.html":
/*!*************************************************************!*\
  !*** ./src/templateCache/announcementNpsTemplatePanel.html ***!
  \*************************************************************/
/***/ (function(module) {

// Module
var code = "<div class=\"cz-announcement cz-sidebar-note cz-hover-click \" style=\"display: block !important;\" data-message-id=\"{{id}}\" id=\"cz-sidebar-note-{{sequence}}\"\r\n     data-info-message=\"{{showInfoMessageString}}\">\r\n    <p>\r\n        <a class=\"cz-nps-click\" data-nps-url=\"{{npsUrl}}\" data-nps-wide=\"{{wide}}\" data-show-new-window=\"{{showNewWindow}}\">{{npsQuestion}}</a>\r\n    </p>\r\n    <span class=\"cz-announcement-timestamp\">{{at}}</span>\r\n</div>\r\n";
// Exports
module.exports = code;

/***/ }),

/***/ "./src/templateCache/announcementSliderTemplate.html":
/*!***********************************************************!*\
  !*** ./src/templateCache/announcementSliderTemplate.html ***!
  \***********************************************************/
/***/ (function(module) {

// Module
var code = "<div class=\"cz-slide-announcement {{announcementPositionClass}}\">\r\n    <span class=\"{{closeClass}}\"><i class=\"czi czi-times\"></i></span>\r\n    {{messageHtml}}\r\n</div>\r\n";
// Exports
module.exports = code;

/***/ }),

/***/ "./src/templateCache/announcementSurveyButtonSpacerTemplate.html":
/*!***********************************************************************!*\
  !*** ./src/templateCache/announcementSurveyButtonSpacerTemplate.html ***!
  \***********************************************************************/
/***/ (function(module) {

// Module
var code = "<!-- spacer (nbsp) -->\r\n<table align=\"right\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"spacer\">\r\n    <tr>\r\n        <td width=\"5\" height=\"44\">&nbsp;</td>\r\n    </tr>\r\n</table>";
// Exports
module.exports = code;

/***/ }),

/***/ "./src/templateCache/announcementSurveyButtonTemplate.html":
/*!*****************************************************************!*\
  !*** ./src/templateCache/announcementSurveyButtonTemplate.html ***!
  \*****************************************************************/
/***/ (function(module) {

// Module
var code = "<table align=\"right\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"score\"\r\n        style=\"min-width:42px\" height=\"44\">\r\n    <tr>\r\n        <td align=\"center\" \r\n            valign=\"middle\"\r\n            style=\"{{Style}}\" \r\n            height=\"40\"\r\n        >\r\n            <a class=\"cz-nps-click\" data-nps-url=\"{{Url}}\" data-nps-wide=\"{{Wide}}\">\r\n                <span style=\"{{TextStyle}}\">{{Label}}</span>\r\n            </a>\r\n        </td>\r\n    </tr>\r\n</table>";
// Exports
module.exports = code;

/***/ }),

/***/ "./src/templateCache/announcementSurveyCustomTemplate.html":
/*!*****************************************************************!*\
  !*** ./src/templateCache/announcementSurveyCustomTemplate.html ***!
  \*****************************************************************/
/***/ (function(module) {

// Module
var code = "<div class=\"cz-announcement cz-sidebar-note cz-hover-click \" style=\"display: block !important;\" data-message-id=\"{{id}}\" data-info-message=\"{{showInfoMessageString}}\"\r\n     id=\"cz-sidebar-note-{{sequence}}\" data-nps-url=\"{{NpsUrl}}\" data-show-new-window=\"{{showNewWindow}}\" data-nps-wide=\"{{wide}}\">\r\n    <div>\r\n        {{Content}}\r\n    </div>\r\n    <span class=\"cz-announcement-timestamp\">{{at}}</span>\r\n</div>\r\n";
// Exports
module.exports = code;

/***/ }),

/***/ "./src/templateCache/announcementTemplate.html":
/*!*****************************************************!*\
  !*** ./src/templateCache/announcementTemplate.html ***!
  \*****************************************************/
/***/ (function(module) {

// Module
var code = "<div class=\"cz-announcement cz-sidebar-note cz-hover-click cz-click-audit\" style=\"display: block !important;\" data-message-id=\"{{id}}\" id=\"cz-sidebar-note-{{sequence}}\"  data-info-message=\"{{showInfoMessageString}}\">\r\n    {{messageContent}}\r\n<span class=\"cz-announcement-timestamp\">{{at}}</span>\r\n</div>\r\n";
// Exports
module.exports = code;

/***/ }),

/***/ "./src/templateCache/avatarImageTemplate.html":
/*!****************************************************!*\
  !*** ./src/templateCache/avatarImageTemplate.html ***!
  \****************************************************/
/***/ (function(module) {

// Module
var code = "<span class=\"cz-avatar\">\r\n    <img !inline class=\"cz-avatar-img\" src=\"{{avatarSrc}}\" alt=\"...\">\r\n</span>\r\n";
// Exports
module.exports = code;

/***/ }),

/***/ "./src/templateCache/avatarInitialsTemplate.html":
/*!*******************************************************!*\
  !*** ./src/templateCache/avatarInitialsTemplate.html ***!
  \*******************************************************/
/***/ (function(module) {

// Module
var code = "<span class=\"cz-avatar\">\r\n    <span class=\"cz-avatar-name\">{{avatarSrc}}</span>\r\n</span>\r\n";
// Exports
module.exports = code;

/***/ }),

/***/ "./src/templateCache/messageBubbleTemplate.html":
/*!******************************************************!*\
  !*** ./src/templateCache/messageBubbleTemplate.html ***!
  \******************************************************/
/***/ (function(module) {

// Module
var code = "<div class=\"cz-alert-message-text\">\r\n{{message}}\r\n</div>\r\n";
// Exports
module.exports = code;

/***/ }),

/***/ "./src/templateCache/popoverContainerTemplate.html":
/*!*********************************************************!*\
  !*** ./src/templateCache/popoverContainerTemplate.html ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Imports
var ___HTML_LOADER_GET_SOURCE_FROM_IMPORT___ = __webpack_require__(/*! ../../node_modules/html-loader/dist/runtime/getUrl.js */ "./node_modules/html-loader/dist/runtime/getUrl.js");
var ___HTML_LOADER_IMPORT_0___ = __webpack_require__(/*! ../img/close_popup.png */ "./src/img/close_popup.png");
// Module
var ___HTML_LOADER_REPLACEMENT_0___ = ___HTML_LOADER_GET_SOURCE_FROM_IMPORT___(___HTML_LOADER_IMPORT_0___);
var code = "<div id=\"cz_transBG\" class=\"cz-transBG\">\r\n    <div id=\"cz_popover\" class=\"cz-popover\">\r\n        <span class=\"cz-popover-close cz-close-popover-trigger\">\r\n            <img src=\"" + ___HTML_LOADER_REPLACEMENT_0___ + "\" style=\"display:none !important;\" inline/>\r\n        </span>\r\n        <div id=\"cz_popover_content\"></div>\r\n    </div>\r\n</div>\r\n";
// Exports
module.exports = code;

/***/ }),

/***/ "./node_modules/html-loader/dist/runtime/getUrl.js":
/*!*********************************************************!*\
  !*** ./node_modules/html-loader/dist/runtime/getUrl.js ***!
  \*********************************************************/
/***/ (function(module) {

"use strict";


module.exports = function (url, options) {
  if (!options) {
    // eslint-disable-next-line no-param-reassign
    options = {};
  }

  if (!url) {
    return url;
  } // eslint-disable-next-line no-underscore-dangle, no-param-reassign


  url = String(url.__esModule ? url.default : url);

  if (options.hash) {
    // eslint-disable-next-line no-param-reassign
    url += options.hash;
  }

  if (options.maybeNeedQuotes && /[\t\n\f\r "'=<>`]/.test(url)) {
    return "\"".concat(url, "\"");
  }

  return url;
};

/***/ }),

/***/ "./src/scss/csm_panel_styles.scss":
/*!****************************************!*\
  !*** ./src/scss/csm_panel_styles.scss ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/constants/inline-styles/in-app-content-container-styles.css":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/constants/inline-styles/in-app-content-container-styles.css ***!
  \***************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (".cz-in-app-page-container {\r\n    display: flex;\r\n    flex-direction: column;\r\n    position: relative;\r\n    min-height: 150px;\r\n}\r\n\r\n.cz-in-app-content-container {\r\n    padding: 20px;\r\n    flex-grow: 1;\r\n}\r\n\r\n.cz-close-in-app {\r\n    margin: 7px 10px 0 0;\r\n    position: absolute;\r\n    top: 0;\r\n    right: 0;\r\n    cursor: pointer;\r\n    font-size: 14px;\r\n    font-weight: 700;\r\n    color: transparent;\r\n    text-shadow: 0 0 0 #000;\r\n}\r\n\r\n/***** THIS IS FOR A HOTFIX! REMOVE THESE SOOOON! *****/\r\n.buttonLinkContainer {\r\n    text-align: center;\r\n}\r\n.buttonLink {\r\n    border-radius: 0.3em;\r\n    margin: 0 1em;\r\n    padding: 0.5em;\r\n    display: inline-block;\r\n    text-decoration: none;\r\n}\r\n.buttonLink:hover {\r\n    text-decoration: none;\r\n}\r\n\r\n.fr-no-border {\r\n    border-style: hidden !important;\r\n}\r\n");

/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/constants/inline-styles/survey-content-container-styles.css":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/constants/inline-styles/survey-content-container-styles.css ***!
  \***************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("*, ::before, ::after {\r\n    box-sizing: border-box;\r\n}\r\n\r\n#cz_in_app_content_body {\r\n    overflow-x: hidden\r\n}\r\n\r\n.cz-in-app-content-container {\r\n    padding: 10px;\r\n}\r\n\r\n.cz-in-app-content-container .cz-announcement .cz-announcement-timestamp {\r\n    display: none !important;\r\n}\r\n\r\n.cz-announcement .cz-nps-container .questiontextcontainer .questiontext,\r\n.cz-announcement .cz-nps-container .labels table td.left,\r\n.cz-announcement .cz-nps-container .labels table td.right {\r\n    color: inherit !important;\r\n}\r\n\r\n.cz-nps-container [class*=\" cz-survey-face-\"]:before, .cz-nps-container [class^=cz-survey-face-]:before{\r\n    line-height: inherit !important;\r\n}\r\n");

/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/constants/inline-styles/wt-content-container-styles.css":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/constants/inline-styles/wt-content-container-styles.css ***!
  \***********************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (".cz-walk-page-container {\r\n    display: flex;\r\n    flex-direction: column;\r\n    position: relative;\r\n    min-height: 150px;\r\n}\r\n\r\n.cz-walk-content-container {\r\n    padding: 20px;\r\n    flex-grow: 1;\r\n}\r\n\r\n.cz-close-walk {\r\n    margin: 7px 10px 0 0;\r\n    position: absolute;\r\n    top: 0;\r\n    right: 0;\r\n    cursor: pointer;\r\n    font-size: 14px;\r\n    font-weight: 700;\r\n    color: transparent;\r\n    text-shadow: 0 0 0 #000;\r\n}\r\n\r\n.buttonLinkContainer {\r\n    text-align: center;\r\n}\r\n.buttonLink {\r\n    border-radius: 0.3em;\r\n    margin: 0 1em;\r\n    padding: 0.5em;\r\n    display: inline-block;\r\n    text-decoration: none;\r\n}\r\n.buttonLink:hover {\r\n    text-decoration: none;\r\n}\r\n");

/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/constants/inline-styles/wt-cta-container-styles.css":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/constants/inline-styles/wt-cta-container-styles.css ***!
  \*******************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (".cz-walk-cta-container {\r\n    position: relative;\r\n    padding: 20px 10px;\r\n    width: 100%;\r\n    border-width: thin;\r\n    border-style: solid;\r\n    box-sizing: border-box;\r\n    margin-top: auto;\r\n}\r\n\r\n.cz-walk-cta-container .cz-walk-cta-button {\r\n    border-radius: 3px;\r\n    border-style: solid;\r\n    border-width: thin;\r\n    padding: 5px 10px;\r\n    box-shadow: none;\r\n    cursor: pointer\r\n}\r\n\r\n.has-top-step-number .cz-walk-content-container {\r\n    padding-top: 35px;\r\n}\r\n\r\n.has-top-right-step-number .cz-close-walk {\r\n    right: auto;\r\n    left: 0;\r\n    margin: 7px 0 0 10px\r\n}\r\n\r\n.has-bottom-step-number .cz-walk-cta-container {\r\n    padding-bottom: 35px\r\n}\r\n");

/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/constants/inline-styles/wt-popup-styles.css":
/*!***********************************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/constants/inline-styles/wt-popup-styles.css ***!
  \***********************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("#cz_popover.cz-popover #cz_popover_content {\r\n    border-radius: 0 !important;\r\n}\r\n");

/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/constants/inline-styles/wt-step-number-styles.css":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/constants/inline-styles/wt-step-number-styles.css ***!
  \*****************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (".cz-walk-step-number {\r\n    position: absolute;\r\n    z-index: 1;\r\n    font-size: 16px;\r\n    font-weight: 700\r\n}\r\n\r\n.cz-walk-step-number.top-left {\r\n    top: 0;\r\n    left: 0;\r\n    margin: 7px 0 0 10px\r\n}\r\n\r\n.cz-walk-step-number.top-center {\r\n    top: 0;\r\n    left: 50%;\r\n    margin-top: 7px;\r\n    transform: translate3d(-50%, 0, 0)\r\n}\r\n\r\n.cz-walk-step-number.top-right {\r\n    top: 0;\r\n    right: 0;\r\n    margin: 7px 10px 0 0\r\n}\r\n\r\n.cz-walk-step-number.bottom-left {\r\n    bottom: 0;\r\n    left: 0;\r\n    margin: 0 0 7px 10px\r\n}\r\n\r\n.cz-walk-step-number.bottom-center {\r\n    bottom: 0;\r\n    left: 50%;\r\n    margin-bottom: 7px;\r\n    transform: translate3d(-50%, 0, 0)\r\n}\r\n\r\n.cz-walk-step-number.bottom-right {\r\n    bottom: 0;\r\n    right: 0;\r\n    margin: 0 10px 7px 0\r\n}\r\n");

/***/ }),

/***/ "./src/App.ts":
/*!********************!*\
  !*** ./src/App.ts ***!
  \********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* global globalThis */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Created by George on 5/3/2016.
 */
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var errorLogger_1 = __importDefault(__webpack_require__(/*! ./core/errorLogger */ "./src/core/errorLogger.ts"));
__webpack_require__(/*! ./scss/csm_panel_styles.scss */ "./src/scss/csm_panel_styles.scss");
var ChurnZeroExt_1 = __webpack_require__(/*! ./ChurnZeroExt */ "./src/ChurnZeroExt.ts");
//import ChurnZeroApp from '@src/core/_ChurnZeroApp';
if (!clientlibs_1.CoreUtils.FeatureDetection.isLegacyIE()) {
    //the integration code sets window.ChurnZero equal to an array
    // so that window.ChurnZero.push will work even before
    // this script is loaded
    var queue_1 = window['ChurnZero'] || [];
    //once this script has loaded, we want window.ChurnZero
    // to refer to the app itself not the event queue
    window['ChurnZero'] = (0, ChurnZeroExt_1.ChurnZeroExt)(queue_1) || {};
    //window['ChurnZero'] = new ChurnZeroApp() || {};
    //after the app has been configured out of the preload state
    // boot it up.
    try {
        var start = function () {
            window.ChurnZero.boot(queue_1);
        };
        // @ts-expect-error: Always returns false (no overlap)
        if (document.readyState === 'complete' || document.readyState === 'loaded' || document.readyState === 'interactive') {
            start();
        }
        else {
            document.addEventListener('DOMContentLoaded', start);
        }
    }
    catch (e) {
        //report?
        errorLogger_1.default.report('App.Main', e);
    }
}


/***/ }),

/***/ "./src/ChurnZeroExt.ts":
/*!*****************************!*\
  !*** ./src/ChurnZeroExt.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChurnZeroExt = void 0;
var _ChurnZeroApp_1 = __importDefault(__webpack_require__(/*! ./core/_ChurnZeroApp */ "./src/core/_ChurnZeroApp.ts"));
function ChurnZeroExt(previousAppState) {
    var cze = new _ChurnZeroApp_1.default();
    if ((previousAppState === null || previousAppState === void 0 ? void 0 : previousAppState.name) === cze.name) {
        return previousAppState;
    }
    return {
        boot: function (previousAppState) { return cze.boot(previousAppState); },
        push: function (args) { return cze.push(args); },
        halt: function () { return cze.halt(); },
        verify: function () { return cze.verify(); },
        debug: function () { return cze.debug(); },
        getQueue: function () { return cze.getQueue(); },
        currentModule: function () {
            // @ts-expect-error: sessionSvc is private
            return cze.sessionSvc.CurrentModule || 'Unknown';
        },
        name: cze.name,
        version: cze.version,
        templateCache: cze.templateCache
    };
}
exports.ChurnZeroExt = ChurnZeroExt;


/***/ }),

/***/ "./src/constants/inline-styles.constants.ts":
/*!**************************************************!*\
  !*** ./src/constants/inline-styles.constants.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SURVEY_CONTENT_CONTAINER_STYLES = exports.IN_APP_CONTENT_CONTAINER_STYLES = exports.WT_STEP_NUMBER_STYLES = exports.WT_CTA_CONTAINER_STYLES = exports.WT_CONTENT_CONTAINER_STYLES = exports.WT_POPUP_STYLES = void 0;
var in_app_content_container_styles_css_1 = __importDefault(__webpack_require__(/*! !!raw-loader!./inline-styles/in-app-content-container-styles.css */ "./node_modules/raw-loader/dist/cjs.js!./src/constants/inline-styles/in-app-content-container-styles.css"));
var survey_content_container_styles_css_1 = __importDefault(__webpack_require__(/*! !!raw-loader!./inline-styles/survey-content-container-styles.css */ "./node_modules/raw-loader/dist/cjs.js!./src/constants/inline-styles/survey-content-container-styles.css"));
var wt_cta_container_styles_css_1 = __importDefault(__webpack_require__(/*! !!raw-loader!./inline-styles/wt-cta-container-styles.css */ "./node_modules/raw-loader/dist/cjs.js!./src/constants/inline-styles/wt-cta-container-styles.css"));
var wt_step_number_styles_css_1 = __importDefault(__webpack_require__(/*! !!raw-loader!./inline-styles/wt-step-number-styles.css */ "./node_modules/raw-loader/dist/cjs.js!./src/constants/inline-styles/wt-step-number-styles.css"));
var wt_content_container_styles_css_1 = __importDefault(__webpack_require__(/*! !!raw-loader!./inline-styles/wt-content-container-styles.css */ "./node_modules/raw-loader/dist/cjs.js!./src/constants/inline-styles/wt-content-container-styles.css"));
var wt_popup_styles_css_1 = __importDefault(__webpack_require__(/*! !!raw-loader!./inline-styles/wt-popup-styles.css */ "./node_modules/raw-loader/dist/cjs.js!./src/constants/inline-styles/wt-popup-styles.css"));
function cheapMinify(input) {
    return input.replace(/\r\n/g, '');
}
var WT_POPUP_STYLES = cheapMinify(wt_popup_styles_css_1.default);
exports.WT_POPUP_STYLES = WT_POPUP_STYLES;
var WT_CONTENT_CONTAINER_STYLES = cheapMinify(wt_content_container_styles_css_1.default);
exports.WT_CONTENT_CONTAINER_STYLES = WT_CONTENT_CONTAINER_STYLES;
var WT_CTA_CONTAINER_STYLES = cheapMinify(wt_cta_container_styles_css_1.default);
exports.WT_CTA_CONTAINER_STYLES = WT_CTA_CONTAINER_STYLES;
var WT_STEP_NUMBER_STYLES = cheapMinify(wt_step_number_styles_css_1.default);
exports.WT_STEP_NUMBER_STYLES = WT_STEP_NUMBER_STYLES;
var IN_APP_CONTENT_CONTAINER_STYLES = cheapMinify(in_app_content_container_styles_css_1.default);
exports.IN_APP_CONTENT_CONTAINER_STYLES = IN_APP_CONTENT_CONTAINER_STYLES;
var SURVEY_CONTENT_CONTAINER_STYLES = cheapMinify(survey_content_container_styles_css_1.default);
exports.SURVEY_CONTENT_CONTAINER_STYLES = SURVEY_CONTENT_CONTAINER_STYLES;


/***/ }),

/***/ "./src/core/ApplicationMarshal.ts":
/*!****************************************!*\
  !*** ./src/core/ApplicationMarshal.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApplicationMarshal = void 0;
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var DevlessPanel_1 = __importDefault(__webpack_require__(/*! @src/core/DevlessPanel */ "./src/core/DevlessPanel.ts"));
var DevlessPanelLauncher_1 = __importDefault(__webpack_require__(/*! @src/core/launchers/DevlessPanelLauncher */ "./src/core/launchers/DevlessPanelLauncher.ts"));
var errorLogger_1 = __importDefault(__webpack_require__(/*! @src/core/errorLogger */ "./src/core/errorLogger.ts"));
var JourneyChecklistLauncher_1 = __webpack_require__(/*! @src/core/launchers/JourneyChecklistLauncher */ "./src/core/launchers/JourneyChecklistLauncher.ts");
var tenant_service_1 = __webpack_require__(/*! @src/services/tenant.service */ "./src/services/tenant.service.ts");
var SuccessPanelLauncher_1 = __webpack_require__(/*! @src/core/launchers/SuccessPanelLauncher */ "./src/core/launchers/SuccessPanelLauncher.ts");
// Utils
var DOM_utils_1 = __webpack_require__(/*! @src/utils/DOM.utils */ "./src/utils/DOM.utils.ts");
var SuccessCenterLauncher_1 = __webpack_require__(/*! @src/core/launchers/SuccessCenterLauncher */ "./src/core/launchers/SuccessCenterLauncher.ts");
var ApplicationMarshal = /** @class */ (function () {
    function ApplicationMarshal(windowSvc, appSvc, commSvc, sessionSvc, storageSvc, tenantSvc, messageSvc, eventSvc, walkthroughSvc, checklistSvc, templateCache) {
        this.windowSvc = windowSvc;
        this.appSvc = appSvc;
        this.commSvc = commSvc;
        this.sessionSvc = sessionSvc;
        this.storageSvc = storageSvc;
        this.tenantSvc = tenantSvc;
        this.messageSvc = messageSvc;
        this.eventSvc = eventSvc;
        this.walkthroughSvc = walkthroughSvc;
        this.checklistSvc = checklistSvc;
        this.templateCache = templateCache;
        this._subIds = {};
        this._checklistLaunchers = [];
        this._launcherConfigs = {};
        this.onDigest = this.onDigest.bind(this);
        this.onHalt = this.onHalt.bind(this);
        this.handleChecklistLauncherShow = this.handleChecklistLauncherShow.bind(this);
        this.handleChecklistConfigRefresh = this.handleChecklistConfigRefresh.bind(this);
        this.handleWindowResize = this.handleWindowResize.bind(this);
        this.debouncedResize = clientlibs_1.CoreUtils.debounce(this.handleWindowResize, 200);
        this._subIds['digestSub'] = this.appSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.DIGEST, this.onDigest);
        this._subIds['haltSub'] = this.appSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.HALT, this.onHalt);
        this._subIds['checklistRefreshSub'] = this.commSvc.registerListener(clientlibs_1.SocketMessageTypes.SOCKETMESSAGETYPE_RefreshChecklistConfig, this.handleChecklistConfigRefresh);
        this.windowSvc.window.addEventListener('resize', this.debouncedResize);
        this.init();
    }
    Object.defineProperty(ApplicationMarshal.prototype, "DevlessPanel", {
        get: function () {
            return (this && this._devlessPanel) ? this._devlessPanel : undefined;
        },
        enumerable: false,
        configurable: true
    });
    ApplicationMarshal.prototype.stop = function () {
        this.onHalt();
    };
    ApplicationMarshal.prototype.setSilent = function (isSilent) {
        if (isSilent) {
            if (this._successPanel) {
                //shut down panel
                this.unloadSuccessPanel();
            }
            //else !this._successPanel => be silent; panel doesn't exist
            if (this._devlessLauncher) {
                //shut down panel
                this.unloadDevlessLauncher();
            }
            if (this._devlessPanel) {
                this.unloadDevlessPanel();
            }
        }
        else {
            if (!this._successPanel) {
                //startup panel
                this.tryLoadPanel();
            }
            //else this._successPanel => stop being silent; panel already exists
        }
    };
    ApplicationMarshal.prototype.openSuccessPanel = function () {
        if (!this._successPanel)
            return;
        this._successPanel.show(true);
        this._wasPanelOpenRequested = true;
    };
    ApplicationMarshal.prototype.closeSuccessPanel = function () {
        if (!this._successPanel)
            return;
        this._successPanel.hide();
    };
    ApplicationMarshal.prototype.init = function () {
        var _this = this;
        this.loadIndependentFramesStyles(function () {
            var _a = _this.sessionSvc, isSilentMode = _a.IsSilent, isDevlessEnabled = _a.DevlessPanelEnabled, isDevlessPanelOpen = _a.IsDevlessPanelOpen;
            var hasAnyPanelType = false;
            if (!isSilentMode) {
                // If a devless session is NOT active, load up our independent launchers
                !isDevlessEnabled && _this.loadIndependentLaunchers();
                // Try to load an applicable center/panel for the contact
                hasAnyPanelType = _this.tryLoadPanel();
            }
            // If the contact doesn't qualify for any panels, make sure we are still loading any Custom CSS
            var shouldLoadCustomCss = !hasAnyPanelType && !isDevlessEnabled;
            if (shouldLoadCustomCss) {
                _this.loadCustomCss();
            }
            if (!isDevlessEnabled) {
                return;
            }
            // Check for custom devless CSS
            _this.loadDevlessCss();
            // If devless is enabled -- listen for open messages
            if (!_this._subIds['loadDevlessPanelSubId']) {
                _this._subIds['loadDevlessPanelSubId'] = _this.appSvc.pubsub.subscribe(clientlibs_1.DevlessEvents.DevlessShow, function (message) {
                    //load the content panel child object
                    _this.loadDevlessPanel(message.info);
                });
            }
            var noLaunchers = !hasAnyPanelType, isScLauncher = _this._successPanel instanceof SuccessCenterLauncher_1.SuccessCenterLauncher;
            if (noLaunchers || isScLauncher) {
                _this.loadDevlessLauncher(hasAnyPanelType, isDevlessPanelOpen);
                return;
            }
            // If this far, we don't have a devless launcher.
            // However, we still need a check to determine if we should show the devless panel immediately
            if (isDevlessPanelOpen) {
                _this.appSvc.pubsub.publish(clientlibs_1.DevlessEvents.DevlessShow);
            }
        });
    };
    ApplicationMarshal.prototype.onDigest = function () {
        // Make sure we should even bother checking for updated CL configs
        if (this.appSvc.isMain && this.tenantSvc.FeatureEnabled(tenant_service_1.ReleaseGates.JourneyChecklistReleased)) {
            this.checklistSvc.checkForUpdatedConfig();
        }
        for (var i = 0; i < this._checklistLaunchers.length; i++)
            this._checklistLaunchers[i].onDigest();
    };
    ApplicationMarshal.prototype.onHalt = function () {
        clientlibs_1.PubSuber.removeAll(this._subIds);
        this.windowSvc.window.removeEventListener('resize', this.debouncedResize);
        this.unloadDevlessPanel();
        this.unloadSuccessPanel();
        this.unloadDevlessLauncher();
        this.unloadIndependentLaunchers();
        this.unloadCustomCss();
        this.unloadDevlessCss();
    };
    /*** Object Loaders / Unloaders ***/
    /**
     * Tries to load a SuccessCenter or SuccessPanel for a contact
     * @returns Flag indicating whether the connected contact qualifies for either a SuccessCenter OR a SuccessPanel
     */
    ApplicationMarshal.prototype.tryLoadPanel = function () {
        var _this = this;
        var forceV3 = false;
        try {
            forceV3 = (this.appSvc.isDebugging && sessionStorage.getItem('czDebugPanelsV3') === 'true');
        }
        catch (ex) {
            //meh - GD
        }
        var hasSuccessCenters = this.sessionSvc.SuccessCenterEnabled || forceV3, hasSuccessPanels = this.sessionSvc.PanelEnabled;
        var hasAnyPanelType = false;
        if (hasSuccessCenters) {
            // Give em a SuccessCenter
            this._successPanel = new SuccessCenterLauncher_1.SuccessCenterLauncher(this.sessionSvc.SuccessCenterConfig, this.commSvc, this.appSvc, this.tenantSvc, this.windowSvc, this.storageSvc, this.sessionSvc, this.messageSvc, this.templateCache);
            hasAnyPanelType = true;
        }
        else if (hasSuccessPanels) {
            // Give em a SuccessPanel V2
            this._successPanel = new SuccessPanelLauncher_1.SuccessPanelLauncher(this.windowSvc.document, this.appSvc, this.tenantSvc, this.windowSvc, this.storageSvc, this.sessionSvc, this.messageSvc, this.templateCache, this.commSvc, this.checklistSvc, this._wasPanelOpenRequested);
            hasAnyPanelType = true;
        }
        this._subIds['showSuccessPanelSubId'] = this.appSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.PanelShow, function () {
            _this.commSvc.setPollInterval(2500);
            // Close all open checklist launchers
            _this.closeChecklistLaunchers();
        });
        this._subIds['hideSuccessPanelSubId'] = this.appSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.PanelHide, function () {
            _this.commSvc.resetPollIntervalToDefault();
        });
        return hasAnyPanelType;
    };
    ApplicationMarshal.prototype.unloadSuccessPanel = function () {
        if (this._successPanel) {
            if (clientlibs_1.CoreUtils.hasOwnProp(this._successPanel, 'onHalt') && typeof this._successPanel['onHalt'] === 'function') {
                this._successPanel['onHalt']();
            }
            this._successPanel = null;
        }
    };
    ApplicationMarshal.prototype.loadDevlessPanel = function (wasManualOpen) {
        var _this = this;
        if (wasManualOpen === void 0) { wasManualOpen = false; }
        if (this._devlessPanel) {
            return;
        }
        this._devlessPanel = new DevlessPanel_1.default(this.windowSvc, this.storageSvc, this.sessionSvc, this.appSvc, this.commSvc, this.tenantSvc, this.eventSvc, this.walkthroughSvc, wasManualOpen);
        var wasPanelOpenBeforeShow = false;
        //devless panel show
        this._subIds['devlessShowSubId'] = this.appSvc.pubsub.subscribe(clientlibs_1.DevlessEvents.DevlessShow, function () {
            var _a, _b, _c, _d, _e;
            // Hide the devless launcher itself
            (_a = _this._devlessLauncher) === null || _a === void 0 ? void 0 : _a.hidePanelToggle();
            var hasAnyPanelType = _this.sessionSvc.PanelEnabled || (_this.sessionSvc.SuccessCenterEnabled && !_this.isSuccessCenterInNewTab());
            if (hasAnyPanelType) {
                wasPanelOpenBeforeShow = (_c = (_b = _this._successPanel) === null || _b === void 0 ? void 0 : _b.basePanelVisible) !== null && _c !== void 0 ? _c : false;
                // Hide any visible panel
                (_d = _this._successPanel) === null || _d === void 0 ? void 0 : _d.hide();
            }
            // Attempt to hide any visible panel launcher
            (_e = _this._successPanel) === null || _e === void 0 ? void 0 : _e.hidePanelToggle();
            _this.commSvc.setPollInterval(2500);
        });
        //devless panel hide
        this._subIds['devlessHideSubId'] = this.appSvc.pubsub.subscribe(clientlibs_1.DevlessEvents.DevlessHide, function () {
            var _a, _b, _c, _d;
            // Show the devless launcher itself
            (_a = _this._devlessLauncher) === null || _a === void 0 ? void 0 : _a.showPanelToggle();
            var hasAnyPanelType = _this.sessionSvc.PanelEnabled || (_this.sessionSvc.SuccessCenterEnabled && !_this.isSuccessCenterInNewTab());
            if (wasPanelOpenBeforeShow && hasAnyPanelType) {
                // Show the panel again
                (_b = _this._successPanel) === null || _b === void 0 ? void 0 : _b.show();
            }
            // Attempt to show any hidden launchers again
            (_c = _this._successPanel) === null || _c === void 0 ? void 0 : _c.showPanelToggle();
            if ((_d = _this._successPanel) === null || _d === void 0 ? void 0 : _d.basePanelVisible) {
                _this.commSvc.setPollInterval(2500);
            }
            else {
                _this.commSvc.resetPollIntervalToDefault();
            }
        });
    };
    ApplicationMarshal.prototype.unloadDevlessPanel = function () {
        if (this._devlessPanel) {
            this._devlessPanel.onHalt();
            this._devlessPanel = null;
        }
    };
    ApplicationMarshal.prototype.loadDevlessLauncher = function (hasPanel, openOnStart) {
        var _this = this;
        if (openOnStart === void 0) { openOnStart = false; }
        if (!hasPanel) {
            //setup the Devless Launcher
            this._devlessLauncher = new DevlessPanelLauncher_1.default(this.appSvc, this.tenantSvc, this.windowSvc, this.storageSvc, this.sessionSvc, this.messageSvc, this.templateCache, this.commSvc);
            if (openOnStart)
                this._devlessLauncher.show();
            return;
        }
        //else wait for the Center/Panel launcher to appear
        var suber = this.appSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.PanelLauncherReady, function () {
            suber.remove();
            //setup the Devless Panel Launcher
            _this._devlessLauncher = new DevlessPanelLauncher_1.default(_this.appSvc, _this.tenantSvc, _this.windowSvc, _this.storageSvc, _this.sessionSvc, _this.messageSvc, _this.templateCache, _this.commSvc);
            _this.handleDevlessLauncherCollisions();
            if (openOnStart)
                _this._devlessLauncher.show();
        });
    };
    ApplicationMarshal.prototype.unloadDevlessLauncher = function () {
        if (this._devlessLauncher) {
            if (clientlibs_1.CoreUtils.hasOwnProp(this._devlessLauncher, 'onHalt') && typeof this._devlessLauncher['onHalt'] === 'function') {
                this._devlessLauncher['onHalt']();
            }
            this._devlessLauncher = null;
        }
    };
    ApplicationMarshal.prototype.loadIndependentLaunchers = function () {
        var _this = this;
        // If we have a panel or center, wait on the PanelLauncherReady event before loading up CL launchers
        if (this.sessionSvc.PanelEnabled || this.sessionSvc.SuccessCenterEnabled) {
            var suber_1 = this.appSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.PanelLauncherReady, function () {
                suber_1.remove();
                _this.populateChecklistLaunchers();
            });
            return;
        }
        // We don't have a panel or center, go ahead and load up CL launchers now
        this.populateChecklistLaunchers();
    };
    ApplicationMarshal.prototype.loadIndependentFramesStyles = function (onSuccess, onError) {
        this._independentFrameStyles = this.windowSvc.createElement('link');
        this._independentFrameStyles.addEventListener('load', function () {
            if (typeof onSuccess === 'function') {
                onSuccess();
            }
        });
        this._independentFrameStyles.addEventListener('error', function (ev) {
            var err, msg = 'independent_frames.css failed to load.';
            if (ev) {
                // Event has an error. Use that and bail
                if (clientlibs_1.CoreUtils.hasOwnProp(ev, 'error')) {
                    err = ev.error;
                }
                else {
                    // Try and discern a meaningful message from the error event...
                    if (typeof ev === 'string')
                        msg = ev;
                    else if (clientlibs_1.CoreUtils.hasOwnProp(ev, 'message'))
                        msg = ev.message;
                }
            }
            err = err || new Error(msg);
            errorLogger_1.default.report('ApplicationMarshal.loadIndependentFramesStyles', err);
            if (typeof onError === 'function') {
                onError();
            }
        });
        this._independentFrameStyles.id = 'cz-independent-frame-styles';
        this._independentFrameStyles.type = 'text/css';
        this._independentFrameStyles.rel = 'stylesheet';
        this._independentFrameStyles.href = this.appSvc.addCdn('css/independent_frames.css');
        this.windowSvc.document.head.appendChild(this._independentFrameStyles);
    };
    ApplicationMarshal.prototype.unloadIndependentLaunchers = function () {
        var _a, _b, _c, _d, _e;
        var launcherLen = this._checklistLaunchers.length;
        for (var i = 0; i < launcherLen; i++) {
            this._checklistLaunchers[i].onHalt();
            this._checklistLaunchers[i] = null;
        }
        this._checklistLaunchers = [];
        while ((_a = this._checklistLauncherContainer) === null || _a === void 0 ? void 0 : _a.lastChild) {
            this._checklistLauncherContainer.removeChild(this._checklistLauncherContainer.firstChild);
        }
        (_c = (_b = this._checklistLauncherContainer) === null || _b === void 0 ? void 0 : _b.parentElement) === null || _c === void 0 ? void 0 : _c.removeChild(this._checklistLauncherContainer);
        this._checklistLauncherContainer = null;
        (_e = (_d = this._independentFrameStyles) === null || _d === void 0 ? void 0 : _d.parentElement) === null || _e === void 0 ? void 0 : _e.removeChild(this._independentFrameStyles);
        this._independentFrameStyles = null;
    };
    ApplicationMarshal.prototype.loadCustomCss = function () {
        var _a;
        if (!((_a = this.sessionSvc.CurrentAccountContent) === null || _a === void 0 ? void 0 : _a.css)) {
            return;
        }
        this._customCssStyles = this.windowSvc.document.createElement('style');
        this._customCssStyles.id = 'cz-custom-css-styles_no-panel';
        this._customCssStyles.textContent = this.sessionSvc.CurrentAccountContent.css;
        this.windowSvc.document.head.appendChild(this._customCssStyles);
    };
    ApplicationMarshal.prototype.unloadCustomCss = function () {
        var _a, _b;
        (_b = (_a = this._customCssStyles) === null || _a === void 0 ? void 0 : _a.parentElement) === null || _b === void 0 ? void 0 : _b.removeChild(this._customCssStyles);
        this._customCssStyles = null;
    };
    ApplicationMarshal.prototype.loadDevlessCss = function () {
        var _a;
        if (!((_a = this.sessionSvc.CurrentAccountContent) === null || _a === void 0 ? void 0 : _a.devlessCss))
            return;
        this._devlessCssStyles = this.windowSvc.document.createElement('style');
        this._devlessCssStyles.id = 'cz-devless-css-styles';
        this._devlessCssStyles.textContent = this.sessionSvc.CurrentAccountContent.devlessCss;
        this.windowSvc.document.head.appendChild(this._devlessCssStyles);
    };
    ApplicationMarshal.prototype.unloadDevlessCss = function () {
        var _a, _b;
        (_b = (_a = this._devlessCssStyles) === null || _a === void 0 ? void 0 : _a.parentElement) === null || _b === void 0 ? void 0 : _b.removeChild(this._devlessCssStyles);
        this._devlessCssStyles = null;
    };
    ApplicationMarshal.prototype.populateChecklistLaunchers = function () {
        var _this = this;
        var _a, _b, _c, _d;
        var bod = this.windowSvc.document.querySelector('body');
        if (!bod ||
            !this.tenantSvc.FeatureEnabled(tenant_service_1.ReleaseGates.JourneyChecklistReleased) ||
            !this.tenantSvc.FeatureEnabled(tenant_service_1.ReleaseGates.JourneyChecklistPhaseTwoReleased)) {
            return;
        }
        var checklistLauncherFilter = function (checklist) {
            // The UI position has been explicitly set to be shown as a launcher
            if (checklist.uiPositionId === 2)
                return true;
            // We have neither a panel nor a center enabled. Force this checklist to display as a launcher
            if (!_this.sessionSvc.PanelEnabled && !_this.sessionSvc.SuccessCenterEnabled)
                return true;
            return false;
        };
        var _e = this.checklistSvc.getChecklistConfig() || { items: [], properties: {} }, items = _e.items, properties = _e.properties, clLaunchers = items.filter(checklistLauncherFilter), len = clLaunchers.length;
        //there weren't any previously and there arent any now
        if (((_b = (_a = this._checklistLaunchers) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) === 0 && len === 0) {
            return;
        }
        var containerId = 'cz_checklist_launcher_container';
        var domElement = this.windowSvc.document.getElementById(containerId);
        if (!domElement) {
            //If the domElement doesnt exist create it
            this._checklistLauncherContainer = this.windowSvc.createElement('div');
            this._checklistLauncherContainer.id = containerId;
            bod.appendChild(this._checklistLauncherContainer);
        }
        else if (!this._checklistLauncherContainer && domElement) {
            //If we dont have a reference to the dom element but it was previously existing stash it
            this._checklistLauncherContainer = domElement;
        }
        // If for some reason the launcher container is still bogus at this point, there's nothing we can do. Bail
        if (!this._checklistLauncherContainer)
            return;
        var globalSettings = properties['globalSettingsConfig'] || {}, merged = __assign(__assign({}, clientlibs_1.CZ_DEFAULT_CHECKLIST_SETTINGS_CONFIG), globalSettings), settingsConfig = clientlibs_1.ModelUtils.create(new clientlibs_1.ChecklistSettingsConfig(), merged);
        this._launcherConfigs['checklistSettings'] = __assign({}, settingsConfig);
        this._checklistLauncherContainer.className = this.checklistSvc.getPositionalClassNameFromConfig(settingsConfig);
        var launcherClass = (settingsConfig.launchIconType === clientlibs_1.LaunchIconType.Float) ? 'float' : 'tabbed';
        this._checklistLauncherContainer.classList.add('cz-independent-frame-container');
        this._checklistLauncherContainer.classList.add(launcherClass);
        this._checklistLauncherContainer.removeAttribute('style');
        var sourceIds = clLaunchers.map(function (cl) { return cl.id; });
        // Remove any existing launchers that don't exist in the fresh CL list we've received
        var i = this._checklistLaunchers.length;
        while (i--) {
            var launcher = this._checklistLaunchers[i];
            if (sourceIds.indexOf(launcher.getId()) > -1)
                continue;
            launcher.onHalt();
            launcher = null;
            this._checklistLaunchers.splice(i, 1);
        }
        var existingIds = this._checklistLaunchers.map(function (l) { return l.getId(); });
        for (var i_1 = 0; i_1 < len; i_1++) {
            var item = clLaunchers[i_1], isLastChild = i_1 === len - 1, meta = { domOrder: i_1, isLastChild: isLastChild };
            var existingIdx = existingIds.indexOf(item.id);
            if (existingIdx > -1) {
                this._checklistLaunchers[existingIdx].updateMetaData(meta);
                continue;
            }
            var launcher = new JourneyChecklistLauncher_1.JourneyChecklistLauncher(item, settingsConfig, this._checklistLauncherContainer, this.appSvc, this.tenantSvc, this.windowSvc, this.storageSvc, this.sessionSvc, this.messageSvc, this.templateCache, this.checklistSvc, meta);
            launcher.registerShowListener(this.handleChecklistLauncherShow);
            launcher.onInit();
            this._checklistLaunchers.push(launcher);
        }
        if (this._checklistLaunchers.length === 0) {
            //no checklists so remove the container. if new ones come in later
            // the container will get readded in the logic above
            (_d = (_c = this._checklistLauncherContainer) === null || _c === void 0 ? void 0 : _c.parentElement) === null || _d === void 0 ? void 0 : _d.removeChild(this._checklistLauncherContainer);
            this._checklistLauncherContainer = null;
            return;
        }
        this.handleChecklistLauncherCollisions();
        this.calculateFramePositions();
        this._checklistLauncherContainer.classList.add('in');
    };
    ApplicationMarshal.prototype.handleChecklistLauncherCollisions = function () {
        var _a, _b, _c, _d;
        var spRect = (_a = this._successPanel) === null || _a === void 0 ? void 0 : _a.getLauncherBoundingRectangle(true);
        if (!spRect) {
            return;
        }
        var launcherRect = (_b = this._checklistLauncherContainer) === null || _b === void 0 ? void 0 : _b.getBoundingClientRect();
        if (!launcherRect) {
            return;
        }
        // No collision, move on
        if (!DOM_utils_1.DOMUtils.hasCollision(launcherRect, spRect)) {
            return;
        }
        var position = (_d = (_c = this._launcherConfigs) === null || _c === void 0 ? void 0 : _c['checklistSettings']) === null || _d === void 0 ? void 0 : _d['launchIconPosition'], offset = 10;
        // Handle the collision based upon the launch icon position
        switch (position) {
            case clientlibs_1.LaunchIconPosition.TopCenter:
            case clientlibs_1.LaunchIconPosition.BottomCenter: {
                // if collision, move left
                var n = spRect.left - launcherRect.width - offset;
                this._checklistLauncherContainer.style.setProperty('left', n + "px", 'important');
                this._checklistLauncherContainer.classList.add('no-transforms');
                break;
            }
            case clientlibs_1.LaunchIconPosition.LeftCenter:
            case clientlibs_1.LaunchIconPosition.RightCenter:
            case clientlibs_1.LaunchIconPosition.TopLeft:
            case clientlibs_1.LaunchIconPosition.TopRight: {
                // if collision, move down
                var n = spRect.bottom + offset;
                this._checklistLauncherContainer.style.setProperty('top', n + "px", 'important');
                this._checklistLauncherContainer.classList.add('no-transforms');
                break;
            }
            case clientlibs_1.LaunchIconPosition.BottomLeft:
            default: { // defaults to bottom right
                // if collision, move up
                var b = this.windowSvc.document.documentElement.clientHeight - spRect.bottom, n = b + spRect.height + offset;
                this._checklistLauncherContainer.style.setProperty('bottom', n + "px", 'important');
                break;
            }
        }
    };
    /**
     * Handle any frame positional calculations (i.e. regarding launcher frames) here
     */
    ApplicationMarshal.prototype.calculateFramePositions = function () {
        var cLen = this._checklistLaunchers.length;
        for (var i = 0; i < cLen; i++) {
            this._checklistLaunchers[i].calculateFramePositions();
        }
    };
    /** Events **/
    ApplicationMarshal.prototype.handleChecklistLauncherShow = function (id) {
        this.closeChecklistLaunchers(id);
        this.closeSuccessPanel();
    };
    ApplicationMarshal.prototype.closeChecklistLaunchers = function (shownId) {
        var cLen = this._checklistLaunchers.length;
        for (var i = 0; i < cLen; i++) {
            var launcher = this._checklistLaunchers[i];
            if (launcher.getId() === shownId)
                continue;
            launcher.hide();
        }
    };
    ApplicationMarshal.prototype.handleWindowResize = function () {
        var _this = this;
        if (!this._checklistLauncherContainer)
            return;
        this._checklistLauncherContainer.classList.remove('in');
        this._checklistLauncherContainer.removeAttribute('style');
        // Give the browser some time to catch up with the attributes we just changed, then check collisions
        this.windowSvc.window.setTimeout(function () {
            _this.handleChecklistLauncherCollisions();
            _this.calculateFramePositions();
            _this._checklistLauncherContainer.classList.add('in');
        }, 100);
    };
    ApplicationMarshal.prototype.handleChecklistConfigRefresh = function (msg) {
        var info = msg.info, clConfig = this.checklistSvc.getChecklistConfig();
        if ((info === null || info === void 0 ? void 0 : info.version) === (clConfig === null || clConfig === void 0 ? void 0 : clConfig.version)) {
            return;
        }
        this.checklistSvc.SeedData(info);
        this.appSvc.debug("Checklist config refreshed with version " + info.version);
        // Determine if we should emit this event to the app
        if (this.appSvc.isMain && this.tenantSvc.FeatureEnabled(tenant_service_1.ReleaseGates.JourneyChecklistReleased)) {
            var doPopulate = (this.tenantSvc.FeatureEnabled(tenant_service_1.ReleaseGates.JourneyChecklistPhaseTwoReleased) &&
                !this.sessionSvc.IsSilent &&
                !this.sessionSvc.DevlessPanelEnabled);
            if (doPopulate)
                this.populateChecklistLaunchers();
            this.appSvc.pubsub.publish(clientlibs_1.ChurnZeroAppEvents.JourneyChecklistRefreshed);
        }
    };
    ApplicationMarshal.prototype.handleDevlessLauncherCollisions = function () {
        var _a, _b;
        var spRect = (_a = this._successPanel) === null || _a === void 0 ? void 0 : _a.getLauncherBoundingRectangle(true);
        if (!spRect) {
            return;
        }
        var launcherRect = (_b = this._devlessLauncher) === null || _b === void 0 ? void 0 : _b.getLauncherBoundingRectangle(true);
        if (!launcherRect) {
            return;
        }
        // No collision, move on
        if (!DOM_utils_1.DOMUtils.hasCollision(launcherRect, spRect)) {
            return;
        }
        var position = clientlibs_1.LaunchIconPosition.BottomRight, offset = 10;
        // Handle the collision based upon the launch icon position
        switch (position) {
            default: { // defaults to bottom right
                // if collision, move up
                var b = this.windowSvc.document.documentElement.clientHeight - spRect.bottom, n = b + spRect.height + offset;
                this._devlessLauncher.positionLauncher({ 'bottom': n + "px" });
                break;
            }
        }
    };
    ApplicationMarshal.prototype.isSuccessCenterInNewTab = function () {
        /************************************************************/
        /** If we're this far, we know that devless is enabled... **/
        /************************************************************/
        var forceV3 = false;
        try {
            forceV3 = (this.appSvc.isDebugging && sessionStorage.getItem('czDebugPanelsV3') === 'true');
        }
        catch (ex) {
            //meh - GD
        }
        var hasSuccessCenters = this.sessionSvc.SuccessCenterEnabled || forceV3;
        return (hasSuccessCenters && this.sessionSvc.SuccessCenterConfig.locationTypeId === clientlibs_1.SuccessCenterLocation.NewTab);
    };
    return ApplicationMarshal;
}());
exports.ApplicationMarshal = ApplicationMarshal;


/***/ }),

/***/ "./src/core/DevlessPanel.ts":
/*!**********************************!*\
  !*** ./src/core/DevlessPanel.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Enums_1 = __webpack_require__(/*! ./Enums */ "./src/core/Enums.ts");
var ElementFinder_1 = __importDefault(__webpack_require__(/*! ./ElementFinder */ "./src/core/ElementFinder.ts"));
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var DevlessPanel = /** @class */ (function () {
    function DevlessPanel(windowSvc, storageSvc, sessionSvc, appSvc, commSvc, tenantSvc, eventSvc, walkthroughSvc, wasUserDriven) {
        var _this = this;
        if (wasUserDriven === void 0) { wasUserDriven = false; }
        this.windowSvc = windowSvc;
        this.storageSvc = storageSvc;
        this.sessionSvc = sessionSvc;
        this.appSvc = appSvc;
        this.commSvc = commSvc;
        this.tenantSvc = tenantSvc;
        this.eventSvc = eventSvc;
        this.walkthroughSvc = walkthroughSvc;
        this.subIds = {};
        this._adminPanelState = null;
        this.buildIframe();
        this.initEventHandlers(wasUserDriven);
        this.subIds['onHaltSubId'] = this.appSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.HALT, function () { return _this.onHalt; });
    }
    Object.defineProperty(DevlessPanel.prototype, "AdminPanelState", {
        get: function () {
            //if the current _adminPanelState does not exist,
            // try to load it from storage
            if (!this._adminPanelState) {
                this._adminPanelState = this.storageSvc.get(DevlessPanel.storageKeys.AdminPanelState, {
                    height: '365px',
                    lastStatus: '',
                    lastStatusData: ''
                });
            }
            return this._adminPanelState;
        },
        set: function (AdminPanelOpenStatus) {
            this._adminPanelState = AdminPanelOpenStatus;
            //store current state of _adminPanelState
            this.persistState();
        },
        enumerable: false,
        configurable: true
    });
    DevlessPanel.prototype.onHalt = function () {
        //persist state
        this.persistState();
        clientlibs_1.PubSuber.removeAll(this.subIds);
        if (this.frame) {
            this.frame.parentNode.removeChild(this.frame);
            this.frame = null;
        }
        if (this.frameResizer) {
            this.frameResizer.parentNode.removeChild(this.frameResizer);
            this.frameResizer = null;
        }
    };
    DevlessPanel.prototype.persistState = function () {
        this.storageSvc.set(DevlessPanel.storageKeys.AdminPanelState, this._adminPanelState);
    };
    DevlessPanel.prototype.buildIframe = function () {
        //Setup the iframe
        var iframeSrc = this.appSvc.WebAppDomain + "devless/";
        iframeSrc += "?ak=" + encodeURIComponent(this.commSvc.appKey) + "&ti=" + this.tenantSvc.currentTenantId();
        var iframe = this.windowSvc.createElement('iframe');
        var resizerHeight = 15;
        var iframeHeight;
        try {
            iframeHeight = parseInt(this.AdminPanelState.height || '265px');
        }
        catch (ex) {
            iframeHeight = 265;
        }
        var resizerBottom = iframeHeight - (resizerHeight / 2);
        iframe.id = 'cz-devless-iframe';
        iframe.src = iframeSrc;
        iframe.style.display = 'block';
        iframe.style.position = 'fixed';
        iframe.style.bottom = '0';
        iframe.style.left = '0';
        iframe.style.right = '0';
        //added max height to prevent the top bar from going outside the viewport.
        iframe.style.maxHeight = '100vh';
        iframe.style.height = iframeHeight + 'px';
        iframe.style.width = '100%';
        iframe.style.zIndex = '1000000';
        iframe.style.border = 'none';
        var iframeResizer = this.windowSvc.createElement('div');
        iframeResizer.id = 'cz-devless-iframe-resizer';
        iframeResizer.style.display = 'block';
        iframeResizer.style.position = 'fixed';
        iframeResizer.style.bottom = resizerBottom + 'px';
        iframeResizer.style.left = '0';
        iframeResizer.style.right = '0';
        iframeResizer.style.width = '100%';
        iframeResizer.style.height = resizerHeight + "px";
        iframeResizer.style.zIndex = '1000002';
        iframeResizer.style.cursor = 'row-resize';
        iframeResizer.ondragstart = function () {
            return false;
        };
        var env = this.appSvc.environment;
        if (env === 't' || env === 'd') {
            iframe.addEventListener('load', function (e) {
                try {
                    var f = e.target;
                    f.contentWindow.parent.document.getElementsByTagName('html')[0].classList.add('cz-devless-ready');
                }
                catch (e) {
                    console.warn(e);
                }
            }, { once: true });
        }
        this.windowSvc.elementCache.body[0].appendChild(iframeResizer);
        this.windowSvc.elementCache.body[0].appendChild(iframe);
        this.frame = iframe;
        this.frameResizer = iframeResizer;
    };
    DevlessPanel.prototype.initEventHandlers = function (wasUserDriven) {
        var _this = this;
        if (wasUserDriven === void 0) { wasUserDriven = false; }
        //Add a mirror to the pubsub so core events get propagated to the devlessIframe
        this.appSvc.pubsub.addMirror(function (message) {
            if (!_this.frame || !_this.frame.contentWindow) {
                return;
            }
            var transportMessage = clientlibs_1.iFrameUtils.encrypt(_this.windowSvc.JSON.stringify(clientlibs_1.iFrameUtils.buildTransportMessage(clientlibs_1.TransportCodes.PubSubMirror, message)));
            //this is the iframe we created for hosting the devless panel so * is fine here
            _this.frame.contentWindow.postMessage(transportMessage, '*');
        });
        //Add a listener for messages coming from the devlessIframe
        this.appSvc.addChildFrameListener();
        //attach listener for devlessInit
        this.subIds['devlessInitSubId'] = this.appSvc.pubsub.subscribe(Enums_1.Enums.DevlessEvents.DevlessInit, function () {
            var connectionInfo = {
                clientSideUrls: _this.windowSvc.clientSideUrls,
                webAppDomain: _this.appSvc.WebAppDomain,
                height: _this.AdminPanelState.height,
                currentTenantId: _this.tenantSvc.currentTenantId(),
                locationHref: _this.windowSvc.href(),
                wasUserDrivenOpen: wasUserDriven,
                featureFlags: _this.tenantSvc.getFeatureFlags()
            };
            _this.appSvc.pubsub.publish(Enums_1.Enums.DevlessEvents.DevlessConnectionInfo, connectionInfo);
            _this.initElementFinder();
        });
        //devless panel show
        this.subIds['devlessShowSubId'] = this.appSvc.pubsub.subscribe(Enums_1.Enums.DevlessEvents.DevlessShow, function () {
            _this.frame.style.display = 'block';
            _this.frameResizer.style.display = 'block';
            _this.commSvc.setPollInterval(2500);
            _this.sessionSvc.IsDevlessPanelOpen = true;
        });
        //devless panel hide
        this.subIds['devlessHideSubId'] = this.appSvc.pubsub.subscribe(Enums_1.Enums.DevlessEvents.DevlessHide, function () {
            _this.frame.style.display = 'none';
            _this.frameResizer.style.display = 'none';
            _this.sessionSvc.IsDevlessPanelOpen = false;
        });
        //devless panel resize
        this.subIds['devlessResizeSubId'] = this.appSvc.pubsub.subscribe(Enums_1.Enums.DevlessEvents.DevlessResize, function (message) {
            var resizeInfo = message.info;
            if (resizeInfo.height) {
                _this.frame.style.height = resizeInfo.height || _this.frame.style.height;
            }
            if (resizeInfo.width) {
                _this.frame.style.width = resizeInfo.width || _this.frame.style.width;
            }
            if (resizeInfo.left) {
                _this.frame.style.left = resizeInfo.left || _this.frame.style.width;
            }
            if (resizeInfo.disableResizing) {
                _this.frameResizer.style.display = 'none';
            }
            else {
                _this.frameResizer.style.display = 'block';
            }
        });
        //devless check visibility
        this.subIds['devlessElementExistsSubId'] = this.appSvc.pubsub.subscribe(Enums_1.Enums.DevlessEvents.DevlessElementExistsCheck, function (message) {
            var exists = _this.windowSvc.czq(message.info.selector).length > 0;
            _this.appSvc.pubsub.publish(Enums_1.Enums.DevlessEvents.DevlessElementExistsCheckResponse, {
                selector: message.info.selector,
                exists: exists
            });
        });
        this.subIds['devlessCurrentHrefSubId'] = this.appSvc.pubsub.subscribe(Enums_1.Enums.DevlessEvents.DevlessCurrentHref, function (message) {
            _this.appSvc.pubsub.publish(Enums_1.Enums.DevlessEvents.DevlessCurrentHrefResponse, { currentHref: _this.windowSvc.href() });
        });
        this.subIds['devlessPushSubId'] = this.appSvc.pubsub.subscribe(Enums_1.Enums.DevlessEvents.DevlessPush, function (message) {
            var infoArray = message.info;
            _this.windowSvc.window.ChurnZero.push(infoArray);
        });
        //panel resize handler
        this.initResizer();
    };
    DevlessPanel.prototype.initResizer = function () {
        var that = this;
        var target = this.frameResizer;
        var frame = this.frame;
        var guard = null;
        this.frameResizer.addEventListener('mousedown', initDrag);
        var startX, startY, startBottom, startHeight;
        function initDrag(e) {
            var frameStyle = document.defaultView.getComputedStyle(frame);
            guard = document.createElement('DIV');
            guard.classList.add('cz-resize-guard');
            guard.style.position = 'fixed';
            guard.style.zIndex = '1000001';
            guard.style.left = '0';
            guard.style.right = '0';
            guard.style.bottom = '0';
            guard.style.height = parseInt(frameStyle.height, 10) + 'px';
            guard.style.backgroundColor = 'transparent';
            //startX = e.clientX;
            startY = e.clientY;
            //startWidth = parseInt(document.defaultView.getComputedStyle(p).width, 10);
            startHeight = parseInt(frameStyle.height, 10);
            startBottom = parseInt(document.defaultView.getComputedStyle(target).bottom, 10);
            document.documentElement.addEventListener('mousemove', doDrag);
            target.addEventListener('mouseup', stopDrag);
            //document.body.addEventListener("mouseleave", stopDrag, false);
            target.style.backgroundColor = 'rgba(0,0,0,0.5)';
            target.style.position = 'fixed';
            document.body.append(target);
            document.body.append(guard);
        }
        function doDrag(e) {
            e.preventDefault();
            //p.style.width = (startWidth + e.clientX - startX) + "px";
            var diff = (startY - e.clientY);
            target.style.bottom = (startBottom + diff) + 'px';
            frame.style.height = (startHeight + diff) + 'px';
            guard.style.height = (startHeight + diff) + 'px';
        }
        function stopDrag(e) {
            document.documentElement.removeEventListener('mousemove', doDrag);
            target.removeEventListener('mouseup', stopDrag);
            // document.body.removeEventListener("mouseleave", stopDrag, false);
            target.style.backgroundColor = 'transparent';
            target.style.position = 'fixed';
            that.AdminPanelState.height = frame.style.height;
            that.persistState();
            that.appSvc.pubsub.publish(Enums_1.Enums.DevlessEvents.DevlessIframeResized, { height: frame.style.height });
            //guard.parentElement.removeChild(guard);
            var guards = document.querySelectorAll('.cz-resize-guard');
            if (guards) {
                for (var i = 0; i < guards.length; i++) {
                    var currentGuard = guards[i];
                    if (currentGuard && currentGuard.parentElement) {
                        currentGuard.parentElement.removeChild(currentGuard);
                    }
                }
            }
        }
    };
    //Internal Methods
    DevlessPanel.prototype.initElementFinder = function () {
        var _this = this;
        if (!this.elementFinder) {
            this.elementFinder = new ElementFinder_1.default({
                elementNamespace: 'element-finder-border',
                pubHubElement: 'body',
                ignoreContainerFilter: 'cz-devless-iframe',
                eventNamespace: 'element-finder-event',
                keepBordersOnClick: true,
                onHoverFunction: this.updateHoverTextHandler.bind(this),
                onSelectedFunction: this.elementSelectedHandler.bind(this),
                onHighlightFunction: this.elementHighlightedHandler.bind(this)
            }, this.windowSvc);
        }
        this.subIds['elementFinderStartSubId'] = this.appSvc.pubsub.subscribe(Enums_1.Enums.DevlessEvents.ElementFinderStart, function (message) {
            _this.elementFinder.start();
            _this.raiseDevlessFrame();
        });
        this.subIds['elementFinderStopSubId'] = this.appSvc.pubsub.subscribe(Enums_1.Enums.DevlessEvents.ElementFinderStop, function (message) {
            _this.elementFinder.stop(message.info);
            _this.lowerDevlessFrame();
        });
        this.subIds['elementFinderHighlightElementSubId'] = this.appSvc.pubsub.subscribe(Enums_1.Enums.DevlessEvents.ElementFinderHighlightElement, function (message) {
            _this.elementFinder.highlightElement(message.info.selector);
        });
    };
    DevlessPanel.prototype.updateHoverTextHandler = function (e, hoveredElement) {
        var hoverElementInfo = {
            description: this.windowSvc.buildSelector(hoveredElement),
            textValue: clientlibs_1.CoreUtils.getTextFromElement(this.windowSvc.czq(hoveredElement))
        };
        this.appSvc.pubsub.publish(Enums_1.Enums.DevlessEvents.ElementFinderHoverUpdate, hoverElementInfo);
    };
    DevlessPanel.prototype.elementSelectedHandler = function (e, selectedElement) {
        var selectedElementInfo = {
            description: this.windowSvc.buildSelector(selectedElement),
            textValue: clientlibs_1.CoreUtils.getTextFromElement(this.windowSvc.czq(selectedElement))
        };
        this.appSvc.pubsub.publish(Enums_1.Enums.DevlessEvents.ElementFinderElementSelected, selectedElementInfo);
        this.lowerDevlessFrame();
    };
    DevlessPanel.prototype.elementHighlightedHandler = function (highlightedElements) {
        var highlightElementInfo = {
            description: this.windowSvc.buildSelector(highlightedElements.get(0)),
            textValue: clientlibs_1.CoreUtils.getTextFromElement(highlightedElements)
        };
        this.appSvc.pubsub.publish(Enums_1.Enums.DevlessEvents.ElementFinderElementHighlighted, highlightElementInfo);
        this.lowerDevlessFrame();
    };
    DevlessPanel.prototype.raiseDevlessFrame = function () {
        this.frame.style.zIndex = '1000001';
    };
    DevlessPanel.prototype.lowerDevlessFrame = function () {
        this.frame.style.zIndex = '1000000';
    };
    DevlessPanel.storageKeys = {
        AdminPanelState: 'ADMIN_PANEL__STATE'
    };
    return DevlessPanel;
}());
exports["default"] = DevlessPanel;


/***/ }),

/***/ "./src/core/ElementFinder.ts":
/*!***********************************!*\
  !*** ./src/core/ElementFinder.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var errorLogger_1 = __importDefault(__webpack_require__(/*! ./errorLogger */ "./src/core/errorLogger.ts"));
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var ElementFinder = /** @class */ (function () {
    function ElementFinder(options, windowSvc) {
        this.windowSvc = windowSvc;
        this.isInited = false;
        this.options = this.windowSvc.czq.extend({}, ElementFinder.defaultOptions, (options || {}));
        this.init();
    }
    ElementFinder.prototype.init = function () {
        if (this.options.eventNamespace && this.options.eventNamespace.substring(0, 1) !== '.') {
            this.options.eventNamespace = '.' + this.options.eventNamespace;
        }
        this.elements = {
            pubHub: this.windowSvc.czq(this.options.pubHubElement),
            iframes: null,
            borderElements: undefined,
            extraBorders: []
        };
    };
    ElementFinder.prototype.start = function () {
        var _this = this;
        this.stop();
        //inject hover style stylesheet into window
        this._initStylesheet();
        this._addBorderElements();
        //listen for a click indicating element found
        this.boundSelectionHandler = this._elementSelectedHandler.bind(this);
        this.elements.pubHub.get(0).addEventListener('click', this.boundSelectionHandler, true);
        //start monitoring mouse hover for selector
        this.elements.pubHub.on(this._nameSpaceEvent('mouseover'), this._mouseOverHandler.bind(this));
        this.elements.iframes = this.elements.pubHub.find('iframe');
        this.elements.iframes.each(function (i, e) {
            var iframe = _this.windowSvc.czq(e);
            try {
                iframe.contents()
                    .on(_this._nameSpaceEvent('mouseover'), function (e) {
                    _this._mouseOverHandler(e, iframe);
                })
                    .on(_this._nameSpaceEvent('click'), function (e) {
                    _this._elementSelectedHandler(e);
                });
            }
            catch (e) {
                //meh...
            }
        });
        this.IsFinding = true;
    };
    ElementFinder.prototype.stop = function (keepBorders) {
        var _this = this;
        //clean everything up
        if (!keepBorders) {
            this._removeBorderElements();
            this.currentHover = null;
        }
        this.elements.pubHub.get(0).removeEventListener('click', this.boundSelectionHandler, true);
        this.boundSelectionHandler = null;
        this.elements.pubHub.off(this.options.eventNamespace);
        if (this.elements.iframes) {
            this.elements.iframes.each(function (i, e) {
                try {
                    _this.windowSvc.czq(e).contents().off(_this.options.eventNamespace);
                }
                catch (e) {
                    //meh...
                }
            });
        }
        this.IsFinding = false;
    };
    ElementFinder.prototype.highlightElement = function (elementToHighlight) {
        var _this = this;
        //inject hover style stylesheet into window
        this._initStylesheet();
        this._addBorderElements();
        var element, jqueryResult;
        if (typeof elementToHighlight === 'string') {
            jqueryResult = this.windowSvc.czq(elementToHighlight);
            if (jqueryResult.length > 0) {
                element = jqueryResult;
            }
            else {
                return;
            }
        }
        else {
            element = this.windowSvc.czq(elementToHighlight);
        }
        if (element.length > 0) {
            this._removeBorderElements();
            element.each(function (i, e) {
                var borders = _this.buildBorderElements();
                _this.elements.extraBorders.push(borders);
                _this._updateBorderPositions(borders, e);
            });
            //trigger event with hovered element
            if (this.options.onHighlightFunction && typeof this.options.onHighlightFunction === 'function') {
                this.options.onHighlightFunction(element);
            }
        }
    };
    //Setup
    ElementFinder.prototype._initStylesheet = function () {
        if (this.isInited !== true) {
            var css = '' +
                '.' + this.options.elementNamespace + ' {' +
                '    background: mediumpurple;' +
                '    position: absolute;' +
                '    z-index: 1000000;' +
                '}';
            this._writeStylesheet(css);
            this.isInited = true;
        }
    };
    //Event Handlers
    ElementFinder.prototype._elementSelectedHandler = function (e) {
        try {
            //turn everything off
            e.preventDefault();
            e.stopPropagation();
            var target = e.target;
            if (this._isIgnorableElement(target)) {
                if (this.currentHover && !this._isIgnorableElement(this.currentHover)) {
                    console.log('using hovered element', this.currentHover);
                    target = this.currentHover;
                }
                else {
                    return false;
                }
            }
            //trigger event with hovered element
            if (this.options.onSelectedFunction && typeof this.options.onSelectedFunction === 'function') {
                this.options.onSelectedFunction(e, target);
            }
            this.stop(this.options.keepBordersOnClick);
        }
        catch (ex) {
            //report?
            errorLogger_1.default.report('ElementFinder.SelectedHandler', ex);
        }
        return false;
    };
    ElementFinder.prototype._mouseOverHandler = function (e, iframeParent) {
        var target = e.target;
        if (this._isIgnorableElement(target)) {
            return;
        }
        //add highlight borders
        var offset;
        if (typeof iframeParent !== 'undefined') {
            offset = iframeParent.offset();
        }
        this._updateBorderPositions(this.elements.BorderElements, target, offset);
        this.currentHover = target;
        if (this.options.onHoverFunction && typeof this.options.onHoverFunction === 'function') {
            this.options.onHoverFunction(e, target);
        }
    };
    //Border Control
    ElementFinder.prototype._addBorderElements = function () {
        this._removeBorderElements();
        var borderElements = this.buildBorderElements();
        this.elements.BorderElements = this.elements.BorderElements || {};
        this.elements.BorderElements.top = borderElements.top;
        this.elements.BorderElements.right = borderElements.right;
        this.elements.BorderElements.bottom = borderElements.bottom;
        this.elements.BorderElements.left = borderElements.left;
    };
    ElementFinder.prototype.buildBorderElements = function () {
        var borderElements = {
            top: this.windowSvc.czq('<div></div>').addClass(this.options.elementNamespace).appendTo('body'),
            right: this.windowSvc.czq('<div></div>').addClass(this.options.elementNamespace).appendTo('body'),
            bottom: this.windowSvc.czq('<div></div>').addClass(this.options.elementNamespace).appendTo('body'),
            left: this.windowSvc.czq('<div></div>').addClass(this.options.elementNamespace).appendTo('body')
        };
        return borderElements;
    };
    ElementFinder.prototype._removeBorderElements = function () {
        var _this = this;
        this.windowSvc.czq.each((this.elements.BorderElements || {}), function (name, element) {
            element.remove();
        });
        this.elements.extraBorders.forEach(function (borders) {
            _this.windowSvc.czq.each((borders || {}), function (name, element) {
                element.remove();
            });
        });
    };
    ElementFinder.prototype._updateBorderPositions = function (borders, element, offset) {
        if (!element || (this.options.elementNamespace && element.className && (element.className).indexOf(this.options.elementNamespace) !== -1)) {
            return;
        }
        var b = 3;
        var scrollTop = this.windowSvc.elementCache.window.scrollTop();
        var pos = element.getBoundingClientRect();
        var top = pos.top + scrollTop;
        var left = pos.left;
        if (offset && typeof offset.top !== 'undefined' && typeof offset.left !== 'undefined') {
            top = pos.top + offset.top;
            left = left + offset.left;
        }
        borders.top.css({
            top: Math.max(0, top - b),
            left: left - b,
            width: pos.width + b,
            height: b
        });
        borders.bottom.css({
            top: top + pos.height,
            left: left - b,
            width: pos.width + b,
            height: b
        });
        borders.left.css({
            top: top - b,
            left: Math.max(0, left - b),
            width: b,
            height: (pos.height + b)
        });
        borders.right.css({
            top: top - b,
            left: left + pos.width,
            width: b,
            height: (pos.height + (b * 2))
        });
    };
    //Utils
    ElementFinder.prototype._writeStylesheet = function (css) {
        var element = document.createElement('style');
        element.type = 'text/css';
        document.getElementsByTagName('head')[0].appendChild(element);
        if (element.styleSheet) {
            element.styleSheet.cssText = css; // IE
        }
        else {
            element.innerHTML = css; // Non-IE
        }
    };
    ElementFinder.prototype._nameSpaceEvent = function (event) {
        return event + this.options.eventNamespace;
    };
    ElementFinder.prototype._isIgnorableElement = function (target) {
        // items specified as should be ignored or the highlight borders
        var ignoreContainer = document.getElementById(this.options.ignoreContainerFilter);
        if (ignoreContainer && ignoreContainer.contains(target) || target.classList.contains('element-finder-border')) {
            return true;
        }
        var targetAsHtml = target;
        // prevent selecting of walkthrough anchors as targets
        if (target.classList.contains('cz-walkthrough-anchor') || clientlibs_1.CoreUtils.closest(targetAsHtml, '.cz-walkthrough-anchor')) {
            return true;
        }
        // prevent success center container highlighting or selection
        if ((target === null || target === void 0 ? void 0 : target.id) === 'cz_success_center_container' || clientlibs_1.CoreUtils.closest(targetAsHtml, '#cz_success_center_container')) {
            return true;
        }
        //tag type specific ignore rules
        var isIgnorable = false;
        switch ((target.tagName || '').toLowerCase()) {
            case 'input':
                //inputs of type password
                isIgnorable = (target.type || '').toLowerCase() === 'password';
                break;
            case 'option':
                isIgnorable = true;
                break;
        }
        return isIgnorable;
    };
    //Default Options
    ElementFinder.defaultOptions = {
        elementNamespace: 'element-finder-border',
        pubHubElement: 'body',
        ignoreContainerFilter: '',
        eventNamespace: '.element-finder-event',
        keepBordersOnClick: false,
        onHoverFunction: false,
        onSelectedFunction: false,
        onHighlightFunction: false
    };
    return ElementFinder;
}());
exports["default"] = ElementFinder;


/***/ }),

/***/ "./src/core/Enums.ts":
/*!***************************!*\
  !*** ./src/core/Enums.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

/* eslint-disable @typescript-eslint/no-namespace  */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Enums = void 0;
var Enums;
(function (Enums) {
    //Used to describe the eventMap Type
    var EventTypes;
    (function (EventTypes) {
        EventTypes[EventTypes["Mapped"] = 1] = "Mapped";
        EventTypes[EventTypes["Unmapped"] = 2] = "Unmapped";
    })(EventTypes = Enums.EventTypes || (Enums.EventTypes = {}));
    //Used to describe the location where an eventMap is relevant
    var LocationTypes;
    (function (LocationTypes) {
        LocationTypes[LocationTypes["Site"] = 1] = "Site";
        LocationTypes[LocationTypes["Page"] = 2] = "Page";
    })(LocationTypes = Enums.LocationTypes || (Enums.LocationTypes = {}));
    //Used to describe the origin of an eventMap selector
    var SelectorTypes;
    (function (SelectorTypes) {
        SelectorTypes[SelectorTypes["Suggested"] = 1] = "Suggested";
        SelectorTypes[SelectorTypes["Custom"] = 2] = "Custom";
    })(SelectorTypes = Enums.SelectorTypes || (Enums.SelectorTypes = {}));
    var TransportCodes;
    (function (TransportCodes) {
        TransportCodes[TransportCodes["PubSubMirror"] = 1] = "PubSubMirror";
        TransportCodes[TransportCodes["FrameComm"] = 2] = "FrameComm";
        TransportCodes[TransportCodes["WalkthroughClickAudit"] = 3] = "WalkthroughClickAudit";
    })(TransportCodes = Enums.TransportCodes || (Enums.TransportCodes = {}));
    //Commands issued between the Main and Sub Frames
    var FrameCommCodes;
    (function (FrameCommCodes) {
        FrameCommCodes[FrameCommCodes["SubframeBoot"] = 1001] = "SubframeBoot";
        FrameCommCodes[FrameCommCodes["SubframeBootResponse"] = 1002] = "SubframeBootResponse";
        FrameCommCodes[FrameCommCodes["SubFramePassback"] = 1003] = "SubFramePassback";
        FrameCommCodes[FrameCommCodes["MainFrameComRePublish"] = 1004] = "MainFrameComRePublish";
        FrameCommCodes[FrameCommCodes["MainFramePassdown"] = 1005] = "MainFramePassdown"; //main frame sends something down to subframes
    })(FrameCommCodes = Enums.FrameCommCodes || (Enums.FrameCommCodes = {}));
    var DevlessEvents;
    (function (DevlessEvents) {
        DevlessEvents[DevlessEvents["DevlessInit"] = 2001] = "DevlessInit";
        DevlessEvents[DevlessEvents["DevlessConnectionInfo"] = 2002] = "DevlessConnectionInfo";
        DevlessEvents[DevlessEvents["DevlessShow"] = 2003] = "DevlessShow";
        DevlessEvents[DevlessEvents["DevlessHide"] = 2004] = "DevlessHide";
        DevlessEvents[DevlessEvents["DevlessResize"] = 2005] = "DevlessResize";
        DevlessEvents[DevlessEvents["DevlessIframeResized"] = 2006] = "DevlessIframeResized";
        DevlessEvents[DevlessEvents["DevlessElementExistsCheck"] = 2007] = "DevlessElementExistsCheck";
        DevlessEvents[DevlessEvents["DevlessElementExistsCheckResponse"] = 2008] = "DevlessElementExistsCheckResponse";
        DevlessEvents[DevlessEvents["DevlessCurrentHref"] = 2009] = "DevlessCurrentHref";
        DevlessEvents[DevlessEvents["DevlessCurrentHrefResponse"] = 2010] = "DevlessCurrentHrefResponse";
        DevlessEvents[DevlessEvents["DevlessPush"] = 2011] = "DevlessPush";
        DevlessEvents[DevlessEvents["ElementFinderStart"] = 2012] = "ElementFinderStart";
        DevlessEvents[DevlessEvents["ElementFinderStop"] = 2013] = "ElementFinderStop";
        DevlessEvents[DevlessEvents["ElementFinderElementSelected"] = 2014] = "ElementFinderElementSelected";
        DevlessEvents[DevlessEvents["ElementFinderHoverUpdate"] = 2015] = "ElementFinderHoverUpdate";
        DevlessEvents[DevlessEvents["ElementFinderHighlightElement"] = 2016] = "ElementFinderHighlightElement";
        DevlessEvents[DevlessEvents["ElementFinderElementHighlighted"] = 2017] = "ElementFinderElementHighlighted";
        DevlessEvents[DevlessEvents["EditorSet"] = 2018] = "EditorSet";
        DevlessEvents[DevlessEvents["EditorChanged"] = 2019] = "EditorChanged";
    })(DevlessEvents = Enums.DevlessEvents || (Enums.DevlessEvents = {}));
    //negative values are clientside only
    var SocketMessageTypes;
    (function (SocketMessageTypes) {
        SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_DISCONNECT"] = -2] = "SOCKETMESSAGETYPE_DISCONNECT";
        SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_INITIAL_CONNECTION"] = -1] = "SOCKETMESSAGETYPE_INITIAL_CONNECTION";
        SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_ANNOUNCEMENT"] = 1] = "SOCKETMESSAGETYPE_ANNOUNCEMENT";
        SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_USER_ACCOUNT_ALERT"] = 5] = "SOCKETMESSAGETYPE_USER_ACCOUNT_ALERT";
        SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_TRACK_EVENT"] = 6] = "SOCKETMESSAGETYPE_TRACK_EVENT";
        SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_SET_ATTRIBUTE"] = 7] = "SOCKETMESSAGETYPE_SET_ATTRIBUTE";
        SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_IS_ACTIVE"] = 8] = "SOCKETMESSAGETYPE_IS_ACTIVE";
        SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_MESSAGE_READ"] = 9] = "SOCKETMESSAGETYPE_MESSAGE_READ";
        SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_MESSAGE_CLICKED"] = 10] = "SOCKETMESSAGETYPE_MESSAGE_CLICKED";
        SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_CHECK_ONLINE"] = 11] = "SOCKETMESSAGETYPE_CHECK_ONLINE";
        SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_CHECK_ONLINE_RESULT"] = 12] = "SOCKETMESSAGETYPE_CHECK_ONLINE_RESULT";
        SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_UPDATE_APP_VERSION"] = 13] = "SOCKETMESSAGETYPE_UPDATE_APP_VERSION";
        SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_EXPIRE_MESSAGE"] = 14] = "SOCKETMESSAGETYPE_EXPIRE_MESSAGE";
        SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_CHECK_EVENT_MAP_CONFIG_VERSION"] = 15] = "SOCKETMESSAGETYPE_CHECK_EVENT_MAP_CONFIG_VERSION";
        SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_REFRESH_EVENT_MAP_CONFIG"] = 16] = "SOCKETMESSAGETYPE_REFRESH_EVENT_MAP_CONFIG";
        SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_TIME_IN_APP"] = 17] = "SOCKETMESSAGETYPE_TIME_IN_APP";
        SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_CheckWalkthroughConfigVersion"] = 18] = "SOCKETMESSAGETYPE_CheckWalkthroughConfigVersion";
        SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_RefreshWalkthroughConfig"] = 19] = "SOCKETMESSAGETYPE_RefreshWalkthroughConfig";
        SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_WalkthroughAction"] = 20] = "SOCKETMESSAGETYPE_WalkthroughAction";
        SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_CheckPageTagConfigVersion"] = 21] = "SOCKETMESSAGETYPE_CheckPageTagConfigVersion";
        SocketMessageTypes[SocketMessageTypes["SOCKETMESSAGETYPE_RefreshPageTagConfig"] = 22] = "SOCKETMESSAGETYPE_RefreshPageTagConfig";
    })(SocketMessageTypes = Enums.SocketMessageTypes || (Enums.SocketMessageTypes = {}));
    var AnnouncementPosition;
    (function (AnnouncementPosition) {
        AnnouncementPosition[AnnouncementPosition["PanelOnly"] = 1] = "PanelOnly";
        AnnouncementPosition[AnnouncementPosition["PopUp"] = 2] = "PopUp";
        AnnouncementPosition[AnnouncementPosition["SlideBottomCenter"] = 3] = "SlideBottomCenter";
        AnnouncementPosition[AnnouncementPosition["SlideLeftBottom"] = 4] = "SlideLeftBottom";
        AnnouncementPosition[AnnouncementPosition["SlideTopLeft"] = 5] = "SlideTopLeft";
        AnnouncementPosition[AnnouncementPosition["SlideTopCenter"] = 6] = "SlideTopCenter";
        AnnouncementPosition[AnnouncementPosition["SlideTopRight"] = 7] = "SlideTopRight";
        AnnouncementPosition[AnnouncementPosition["SlideBottomLeft"] = 8] = "SlideBottomLeft";
        AnnouncementPosition[AnnouncementPosition["SlideBottomRight"] = 9] = "SlideBottomRight";
        AnnouncementPosition[AnnouncementPosition["SlideLeftTop"] = 10] = "SlideLeftTop";
        AnnouncementPosition[AnnouncementPosition["SlideLeftCenter"] = 11] = "SlideLeftCenter";
        AnnouncementPosition[AnnouncementPosition["SlideRightTop"] = 12] = "SlideRightTop";
        AnnouncementPosition[AnnouncementPosition["SlideRightCenter"] = 13] = "SlideRightCenter";
        AnnouncementPosition[AnnouncementPosition["SlideRightBottom"] = 14] = "SlideRightBottom";
        AnnouncementPosition[AnnouncementPosition["Tooltip"] = 15] = "Tooltip";
    })(AnnouncementPosition = Enums.AnnouncementPosition || (Enums.AnnouncementPosition = {}));
    var WalkthroughActionType;
    (function (WalkthroughActionType) {
        WalkthroughActionType[WalkthroughActionType["Unknown"] = 0] = "Unknown";
        WalkthroughActionType[WalkthroughActionType["WalkthroughStarted"] = 1] = "WalkthroughStarted";
        WalkthroughActionType[WalkthroughActionType["StepStarted"] = 2] = "StepStarted";
        WalkthroughActionType[WalkthroughActionType["StepClicked"] = 3] = "StepClicked";
        WalkthroughActionType[WalkthroughActionType["StepCompleted"] = 4] = "StepCompleted";
        WalkthroughActionType[WalkthroughActionType["StepAbandonded"] = 5] = "StepAbandonded";
        WalkthroughActionType[WalkthroughActionType["WalkthroughCompleted"] = 6] = "WalkthroughCompleted";
        WalkthroughActionType[WalkthroughActionType["WalkthroughAbandoned"] = 7] = "WalkthroughAbandoned";
        WalkthroughActionType[WalkthroughActionType["WalkthroughResumed"] = 8] = "WalkthroughResumed";
    })(WalkthroughActionType = Enums.WalkthroughActionType || (Enums.WalkthroughActionType = {}));
    /**
     * Available frame types
     */
    var FrameType;
    (function (FrameType) {
        FrameType[FrameType["WalkThrough"] = 0] = "WalkThrough";
        FrameType[FrameType["InAppAnnouncement"] = 1] = "InAppAnnouncement";
        FrameType[FrameType["NPS"] = 2] = "NPS";
    })(FrameType = Enums.FrameType || (Enums.FrameType = {}));
    /**
     * Available announcement types
     */
    var AnnouncementElementType;
    (function (AnnouncementElementType) {
        AnnouncementElementType[AnnouncementElementType["Popup"] = 0] = "Popup";
        AnnouncementElementType[AnnouncementElementType["Slider"] = 1] = "Slider";
        AnnouncementElementType[AnnouncementElementType["Tooltip"] = 2] = "Tooltip";
    })(AnnouncementElementType = Enums.AnnouncementElementType || (Enums.AnnouncementElementType = {}));
})(Enums = exports.Enums || (exports.Enums = {}));


/***/ }),

/***/ "./src/core/EventSpider.ts":
/*!*********************************!*\
  !*** ./src/core/EventSpider.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Enums_1 = __webpack_require__(/*! ./Enums */ "./src/core/Enums.ts");
var errorLogger_1 = __importDefault(__webpack_require__(/*! ./errorLogger */ "./src/core/errorLogger.ts"));
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var tenant_service_1 = __webpack_require__(/*! ../services/tenant.service */ "./src/services/tenant.service.ts");
var EventSpider = /** @class */ (function () {
    function EventSpider(appSvc, tenantSvc, eventSvc, walkthroughSvc, windowSvc, commSvc, sessionSvc) {
        var _this = this;
        this.appSvc = appSvc;
        this.tenantSvc = tenantSvc;
        this.eventSvc = eventSvc;
        this.walkthroughSvc = walkthroughSvc;
        this.windowSvc = windowSvc;
        this.commSvc = commSvc;
        this.sessionSvc = sessionSvc;
        //subscribe to events
        this.startId = this.appSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.START, function () { return _this.onStart(); });
        this.digestId = this.appSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.DIGEST, function () { return _this.onDigest(); });
        this.haltId = this.appSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.HALT, function () { return _this.onHalt(); });
    }
    EventSpider.prototype.Stop = function () {
        this.onHalt();
    };
    EventSpider.prototype.onStart = function () {
        var _this = this;
        //wire up Update Mapped Events listener
        this.updateMappedEventHandlersId = this.commSvc.registerListener(Enums_1.Enums.SocketMessageTypes.SOCKETMESSAGETYPE_REFRESH_EVENT_MAP_CONFIG, function (message) { return _this.updateMappedEventHandlers(message.info); });
        this.updateMappedWalkthroughsHandlersId = this.commSvc.registerListener(Enums_1.Enums.SocketMessageTypes.SOCKETMESSAGETYPE_RefreshWalkthroughConfig, function (message) { return _this.updateMappedWalkthroughHandlers(message.info); });
        //start click tracking events
        this.trackMappedClicks();
    };
    EventSpider.prototype.onDigest = function () {
        //poll for eventmap updates
        this.eventSvc.RefreshEventMapConfig();
        //poll for walkthrough updates
        if (this.tenantSvc.FeatureEnabled(tenant_service_1.FeatureFlags.Walkthroughs)) {
            this.walkthroughSvc.RefreshWalkthroughConfig();
        }
    };
    EventSpider.prototype.onHalt = function () {
        console.log('Halting - Event Spider');
        //stop tracking events
        this.removeMappedClickHandlers();
        //unsubscribe
        if (this.updateMappedEventHandlersId) {
            this.updateMappedEventHandlersId.remove();
            this.updateMappedEventHandlersId = undefined;
        }
        if (this.updateMappedWalkthroughsHandlersId) {
            this.updateMappedWalkthroughsHandlersId.remove();
            this.updateMappedWalkthroughsHandlersId = undefined;
        }
        if (this.startId) {
            this.startId.remove();
            this.startId = null;
        }
        if (this.digestId) {
            this.digestId.remove();
            this.digestId = null;
        }
        if (this.haltId) {
            this.haltId.remove();
            this.haltId = null;
        }
    };
    //refresh the mapped event handlers
    EventSpider.prototype.updateMappedEventHandlers = function (data) {
        //short circuit
        if (this.eventSvc.eventMapVersion === data.eventMapVersion) {
            return;
        }
        this.appSvc.debug('Updated EventMap Config Received', data);
        //update the event services data
        this.eventSvc.LoadEventMapConfig(data);
        //stop old event handlers
        this.removeMappedClickHandlers();
        //restart event handlers
        this.trackMappedClicks();
    };
    //refresh the mapped event handlers
    EventSpider.prototype.updateMappedWalkthroughHandlers = function (data) {
        //short circuit
        if (this.walkthroughSvc.walkthroughsVersion === data.version) {
            return;
        }
        this.appSvc.debug('Updated Walkthrough Config Received', data);
        //update the event services data
        this.walkthroughSvc.LoadWalkthroughConfig(data);
        //stop old event handlers
        this.removeMappedClickHandlers();
        //restart event handlers
        this.trackMappedClicks();
    };
    /**************************
     *  Devless Event Tracking
     **************************/
    EventSpider.prototype.trackMappedClicks = function () {
        var _this = this;
        var relevantEvents = this.eventSvc.RelevantMappedEvents().all, relevantWalkthroughs = this.walkthroughSvc.GetClickWalkthroughs(), itemFilter, walkthroughFilter;
        //remove any preexisting handlers
        this.removeMappedClickHandlers();
        if (relevantEvents.length > 0 || relevantWalkthroughs.length > 0) {
            itemFilter = clientlibs_1.CoreUtils.concatEventMapSelectors(relevantEvents);
            walkthroughFilter = clientlibs_1.CoreUtils.concatWalkthroughSelectors(relevantWalkthroughs);
            this.boundEventClickHandler = function (e) {
                //setTimeout(() => {
                try {
                    //guard against synthetic events
                    if (!e || !e.target) {
                        return;
                    }
                    var target = _this.windowSvc.czq(e.target);
                    if (itemFilter && target.is(itemFilter)) {
                        e['data'] = relevantEvents;
                        _this.mappedEventClickHandler(e);
                    }
                    if (walkthroughFilter && target.is(walkthroughFilter)) {
                        e['data'] = relevantWalkthroughs;
                        _this.walkthroughClickHandler(e);
                    }
                }
                catch (ex) {
                    //report?
                    errorLogger_1.default.report('EventSpider.boundEventClickHandler', ex);
                }
                //}, 0);
            };
            this.windowSvc.elementCache.document.get(0).addEventListener('click', this.boundEventClickHandler, true);
        }
    };
    EventSpider.prototype.removeMappedClickHandlers = function () {
        this.windowSvc.elementCache.document.get(0).removeEventListener('click', this.boundEventClickHandler, true);
        this.boundEventClickHandler = null;
        this.windowSvc.elementCache.document.off('click.mappedEvents');
    };
    EventSpider.prototype.mappedEventClickHandler = function (evt) {
        var _this = this;
        var allEventMaps = evt.data;
        if (allEventMaps && allEventMaps.length > 0) {
            var target_1 = this.windowSvc.czq(evt.target);
            allEventMaps.forEach(function (eventMap) {
                var doesLocationMatch = _this.checkEventMapMatchesCurrentUrl(eventMap), selector = clientlibs_1.CoreUtils.buildEventMapSelector(eventMap), doesSelectorMatch = target_1.is(selector);
                if (doesSelectorMatch && doesLocationMatch) {
                    evt.WasMapped = true;
                    var a = _this.buildEventArrayFromEventMap(eventMap);
                    _this.appSvc.debug('[Devless Event Mapping]', a);
                    _this.eventSvc.TrackEvent.apply(_this.eventSvc, a);
                }
            });
        }
    };
    EventSpider.prototype.walkthroughClickHandler = function (evt) {
        var _this = this;
        var allClickWalkthroughs = evt.data;
        if (allClickWalkthroughs && allClickWalkthroughs.length > 0) {
            var target_2 = this.windowSvc.czq(evt.target);
            allClickWalkthroughs.forEach(function (walkthrough) {
                if (walkthrough.pageTag && walkthrough.pageTag.disabled) {
                    return;
                }
                var doesLocationMatch = _this.checkLocationMatchesCurrentUrl(walkthrough.pageTag), selector = clientlibs_1.CoreUtils.buildEventMapSelector(walkthrough.triggerConfig), doesSelectorMatch = target_2.is(selector);
                if (doesSelectorMatch && doesLocationMatch) {
                    evt.WasMapped = true;
                    _this.appSvc.debug('[Devless Walkthrough Mapping]', walkthrough);
                    //dont track events or engage walkthroughs if the devless panel enabled
                    if (_this.sessionSvc.ShouldPreventUsageSends) {
                        return;
                    }
                    _this.appSvc.pubsub.publish(clientlibs_1.ChurnZeroAppEvents.WalkthroughStart, walkthrough);
                }
            });
        }
    };
    /** Devless Event Tracking Helpers **/
    EventSpider.prototype.buildEventArrayFromEventMap = function (e) {
        var tempEventArray = [e.eventName], element, text;
        if (e.descriptionSelector) {
            element = this.windowSvc.czq(e.descriptionSelector);
            if (element.length > 0) {
                text = clientlibs_1.CoreUtils.getTextFromElement(element);
                tempEventArray = tempEventArray.concat([text]);
            }
        }
        element = text = null;
        if (e.quantitySelector) {
            element = this.windowSvc.czq(e.quantitySelector);
            if (element.length > 0) {
                text = clientlibs_1.CoreUtils.getIntFromElement(element);
                if (tempEventArray.length === 1) {
                    tempEventArray = tempEventArray.concat([null]);
                }
                tempEventArray = tempEventArray.concat([text]);
            }
        }
        return tempEventArray;
    };
    EventSpider.prototype.checkEventMapMatchesCurrentUrl = function (eventMap) {
        return (eventMap.locationTypeId === Enums_1.Enums.LocationTypes.Site || (eventMap.locationTypeId === Enums_1.Enums.LocationTypes.Page && (eventMap.location || this.windowSvc.href()) === this.windowSvc.href()));
    };
    EventSpider.prototype.checkLocationMatchesCurrentUrl = function (pageTag) {
        return this.windowSvc.CheckPageTagAgainstCurrentLocation(pageTag);
    };
    return EventSpider;
}());
exports["default"] = EventSpider;


/***/ }),

/***/ "./src/core/FrameBuilder.ts":
/*!**********************************!*\
  !*** ./src/core/FrameBuilder.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FRAME_BUILDER_STYLE_ELEMENT_ID_MAPPING = exports.FrameBuilder = void 0;
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var inline_styles_constants_1 = __webpack_require__(/*! ../constants/inline-styles.constants */ "./src/constants/inline-styles.constants.ts");
var FrameComm_util_1 = __webpack_require__(/*! ../utils/FrameComm.util */ "./src/utils/FrameComm.util.ts");
var Enums_1 = __webpack_require__(/*! ./Enums */ "./src/core/Enums.ts");
var DOM_utils_1 = __webpack_require__(/*! @src/utils/DOM.utils */ "./src/utils/DOM.utils.ts");
var FRAME_BUILDER_STYLE_ELEMENT_ID_MAPPING = {
    popupStyle: 'cz-walkthrough-popup-styles',
    sliderStyle: 'cz-walkthrough-slider-styles',
    tooltipStyle: 'cz-walkthrough-tooltip-styles',
    styleOverrides: 'cz-walkthrough-style-overrides',
    inAppStyle: 'cz-in-app-announcement-styles'
};
exports.FRAME_BUILDER_STYLE_ELEMENT_ID_MAPPING = FRAME_BUILDER_STYLE_ELEMENT_ID_MAPPING;
var FRAME_BUILDER_IDS = {
    inAppContentBody: 'cz_in_app_content_body',
    walkthroughAnchorContentBody: 'cz_walkthrough_anchor_content_body',
    walkthroughContentBody: 'cz_walkthrough_content_body'
};
var FrameBuilder = /** @class */ (function () {
    function FrameBuilder(windowSvc, sessionSvc, tenantSvc) {
        this.windowSvc = windowSvc;
        this.sessionSvc = sessionSvc;
        this.tenantSvc = tenantSvc;
        this.blankHtmlDocString = '<!DOCTYPE html>\n<html><head></head><body></body></html>';
        this.callToActionContainerClass = 'cz-walk-cta-container';
        this.callToActionButtonClass = 'cz-walk-cta-button';
        this.czSliderClassName = 'cz-ui-slider';
        this.czPopupClassName = 'cz-ui-popup';
        this.buildSurveyContentFrame = this.buildSurveyContentFrame.bind(this);
        this.buildInAppContentFrame = this.buildInAppContentFrame.bind(this);
        this.buildWalkthroughContentFrame = this.buildWalkthroughContentFrame.bind(this);
        this.buildWalkthroughAnchorFrame = this.buildWalkthroughAnchorFrame.bind(this);
        this.removeWalkthroughStyleElements = this.removeWalkthroughStyleElements.bind(this);
        this.getWalkthroughContentIFrameLoadFunc = this.getWalkthroughContentIFrameLoadFunc.bind(this);
        this.getInAppContentIFrameLoadFunc = this.getInAppContentIFrameLoadFunc.bind(this);
        this.fixVideoElementsFromFroala = this.fixVideoElementsFromFroala.bind(this);
        this.fixImageElementsFromFroala = this.fixImageElementsFromFroala.bind(this);
    }
    /** Surveys **/
    /**
     * Build a string of html that represents the iframe that will load the Survey page
     * @param url - string to load as the src of the iframe
     * @param infoMessageString - text to display in the click here to show again bubble
     */
    FrameBuilder.prototype.buildSurveyContentFrame = function (url, infoMessageString) {
        url = this.windowSvc.clientSideUrls.baseApiUrl + url;
        return '<iframe id="cz_nps_frame" src="' + url + '" width="100%" height="100%" data-info-message="' + infoMessageString + '"  frameborder="0"></iframe>';
    };
    /** In App Announcements **/
    FrameBuilder.prototype.buildInAppContentFrame = function (configuration) {
        var _a;
        var clickAuditData = configuration.clickAuditData, styleConfig = configuration.styleConfig;
        var contentiFrame = this.windowSvc.createElement('iframe');
        contentiFrame.style.margin = '0';
        contentiFrame.style.padding = '0';
        contentiFrame.style.border = 'none';
        contentiFrame.style.display = 'block'; // force block-level rules
        contentiFrame.style.width = '100%';
        contentiFrame.style.maxWidth = '100%';
        var transportPod = clientlibs_1.iFrameUtils.buildTransportMessage(clientlibs_1.TransportCodes.AnnouncementFrameComm, clickAuditData);
        var customCss = clientlibs_1.StyleUtils.froalaViewerStyle;
        if (this.sessionSvc.CurrentAccountContent && this.sessionSvc.CurrentAccountContent.css) {
            customCss += this.sessionSvc.CurrentAccountContent.css;
        }
        var fontFamily = styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.fontFamily, _b = styleConfig || {}, fontSize = _b.fontSize, fontColor = _b.fontColor, textAlignment = _b.textAlignment;
        var cssText = '', secondaryClassName = this.czPopupClassName;
        if (fontFamily) {
            cssText += "font-family:" + this.tenantSvc.getUIFontFamilyMappingDisplayValue(fontFamily) + ";";
        }
        if (typeof fontSize === 'number') {
            cssText += "font-size:" + fontSize + "px;";
        }
        if (fontColor) {
            cssText += "color:" + fontColor + ";";
        }
        if (textAlignment) {
            cssText += "text-align:" + textAlignment + ";";
        }
        if (configuration.type === Enums_1.Enums.AnnouncementElementType.Slider) {
            secondaryClassName = this.czSliderClassName;
            cssText += 'overflow:auto;';
        }
        customCss += "#" + FRAME_BUILDER_IDS.inAppContentBody + "{" + cssText + "}p{margin: 0 0 1rem 0;}";
        customCss += inline_styles_constants_1.IN_APP_CONTENT_CONTAINER_STYLES;
        contentiFrame.classList.add('cz-in-app-content-frame');
        contentiFrame.classList.add(secondaryClassName);
        contentiFrame.addEventListener('load', this.getInAppContentIFrameLoadFunc(configuration, transportPod, [customCss, configuration.customCss]));
        contentiFrame.setAttribute('data-message-id', (_a = clickAuditData === null || clickAuditData === void 0 ? void 0 : clickAuditData.id) === null || _a === void 0 ? void 0 : _a.toString());
        return contentiFrame;
    };
    FrameBuilder.prototype.getInAppContentIFrameLoadFunc = function (config, transportPod, customCss) {
        var _this = this;
        var styleConfig = config.styleConfig, content = config.content, width = config.width, type = config.type, position = config.position, onResizeCallback = config.onResizeCallback, onShownCallback = config.onShownCallback, onLoadCallback = config.onLoadCallback, onCloseCallback = config.onCloseCallback, onClickCallback = config.onClickCallback;
        // Page wrap click handler
        var clickHandler = function (e) {
            var className = e.target.className, wasClose = className === 'cz-close-in-app';
            if (wasClose && typeof onCloseCallback === 'function') {
                onCloseCallback();
                return;
            }
            if (onClickCallback && typeof onClickCallback === 'function') {
                onClickCallback(e);
            }
        };
        return function (e) {
            var contentiFrame = e.target;
            contentiFrame.contentDocument.write(_this.blankHtmlDocString);
            var win = contentiFrame.contentWindow, d = win.document, b = d.body, pageWrap = d.createElement('section'), contentWrap = d.createElement('div');
            b.style.margin = '0';
            b.style.padding = '0';
            b.id = FRAME_BUILDER_IDS.inAppContentBody;
            // Add content to contentWrap
            contentWrap.className = 'cz-in-app-content-container';
            contentWrap.innerHTML = content;
            if (styleConfig.textAlignment === 'right') { // Pad content horizontally, if applicable
                contentWrap.style.paddingRight = '30px';
            }
            // Add close button and contentWrap to the page wrap
            pageWrap.className = 'cz-in-app-page-container';
            pageWrap.innerHTML = '<span class="cz-close-in-app">&#x2716;</span>';
            var supportsResizeObserver = DOM_utils_1.DOMUtils.isFeatureSupported(win, 'ResizeObserver');
            if (supportsResizeObserver) {
                var frameResizeObserver_1 = clientlibs_1.iFrameUtils.getFrameResizeObserver(contentiFrame, onShownCallback, onResizeCallback);
                frameResizeObserver_1.observe(pageWrap);
                d.defaultView.addEventListener('unload', function () {
                    console.log('Announcement: resize obs unload!');
                    frameResizeObserver_1.disconnect();
                });
            }
            pageWrap.appendChild(contentWrap);
            pageWrap.addEventListener('click', clickHandler);
            // Add pageWrap to the body
            b.appendChild(pageWrap);
            if (!Element.prototype.matches)
                Element.prototype.matches = Element.prototype['msMatchesSelector'];
            if (!Element.prototype.closest)
                Element.prototype.closest = function (selector) {
                    return clientlibs_1.CoreUtils.closest(this, selector);
                };
            var customCssItems;
            // Custom css from meta data
            if (typeof customCss === 'string') {
                customCssItems = [customCss];
            }
            else {
                customCssItems = customCss;
            }
            for (var i = 0; i < customCssItems.length; i++) {
                if (customCssItems[i]) {
                    var s = d.createElement('style');
                    s.setAttribute('type', 'text/css');
                    s.textContent = customCssItems[i];
                    d.head.appendChild(s);
                }
            }
            // UI Font Family Logic
            _this.addUIFontFamilyCssRequestUrl(d, styleConfig, false);
            // Style props
            var propConfig = {};
            if (type === Enums_1.Enums.AnnouncementElementType.Slider)
                propConfig['position'] = position;
            /*
            * For announcements, we can directly style the contentiFrame instead of targeting a nested element.
            * So, we pass contentiFrame as the first and second parameter to the addAnnouncementStyleProperties method.
            */
            _this.addAnnouncementStyleProperties(contentiFrame, contentiFrame, FRAME_BUILDER_STYLE_ELEMENT_ID_MAPPING.inAppStyle, styleConfig, Enums_1.Enums.FrameType.InAppAnnouncement, propConfig);
            //ensure all videos are playable
            var videos = b.querySelectorAll('.fr-video'), parentWidth = width || ((type === Enums_1.Enums.AnnouncementElementType.Popup) ? clientlibs_1.StyleConfigPopUpWidth.Small : clientlibs_1.StyleConfigSliderWidth.Small);
            _this.fixVideoElementsFromFroala(videos, parentWidth);
            FrameComm_util_1.FrameCommUtil.setUpLinkAuditEvents(win, transportPod);
            FrameComm_util_1.FrameCommUtil.setUpVideoAuditEvents(win, transportPod);
            // Old browsers that don't support ResizeObserver must use an interval to adjust the content frame's height
            if (!supportsResizeObserver) {
                var resizeIntervalDereg = clientlibs_1.iFrameUtils.setFrameHeightBySourceAtInterval(pageWrap, contentiFrame, 200, onShownCallback, onResizeCallback);
                d.defaultView.addEventListener('unload', resizeIntervalDereg);
            }
            // Clear the resize interval & remove click events when iframe is destroyed
            d.defaultView.addEventListener('unload', function () {
                pageWrap.removeEventListener('click', clickHandler);
            });
            onLoadCallback === null || onLoadCallback === void 0 ? void 0 : onLoadCallback(win);
        };
    };
    /** Anchors **/
    FrameBuilder.prototype.buildWalkthroughAnchorFrame = function (configuration) {
        var triggerConfig = configuration.triggerConfig, walkthroughStyleConfig = configuration.walkthroughStyleConfig;
        var contentiFrame = this.windowSvc.createElement('iframe');
        contentiFrame.style.margin = '0';
        contentiFrame.style.padding = '0';
        contentiFrame.style.border = 'none';
        contentiFrame.style.display = 'block'; // force block-level rules
        contentiFrame.style.width = triggerConfig.iconStyleConfig.size * 1.5 + 'px';
        contentiFrame.style.height = triggerConfig.iconStyleConfig.size * 1.5 + 'px';
        contentiFrame.style.position = 'absolute';
        //contentiFrame.style.zIndex = '999997'; //2 below success center frames
        contentiFrame.style.zIndex = (triggerConfig.iconStyleConfig.zIndex || walkthroughStyleConfig.anchorZIndex || '999997').toString();
        var customCss = clientlibs_1.StyleUtils.froalaViewerStyle;
        if (this.sessionSvc.CurrentAccountContent && this.sessionSvc.CurrentAccountContent.css) {
            customCss += this.sessionSvc.CurrentAccountContent.css;
        }
        customCss += inline_styles_constants_1.IN_APP_CONTENT_CONTAINER_STYLES;
        contentiFrame.classList.add('cz-walk-anchor-frame');
        contentiFrame.addEventListener('load', this.getWalkthroughAnchorIFrameLoadFunc(configuration, [customCss, configuration.customCss], configuration.cssLinks));
        return contentiFrame;
    };
    FrameBuilder.prototype.getWalkthroughAnchorIFrameLoadFunc = function (config, customCss, cssLinks) {
        var _this = this;
        var walkthroughStyleConfig = config.walkthroughStyleConfig, onClickCallback = config.onClickCallback;
        // Page wrap click handler
        var clickHandler = function (e) {
            if (onClickCallback && typeof onClickCallback === 'function') {
                onClickCallback(e);
            }
        };
        return function (e) {
            var contentiFrame = e.target;
            contentiFrame.contentDocument.write(_this.blankHtmlDocString);
            var win = contentiFrame.contentWindow, d = win.document, b = d.body, pageWrap = d.createElement('section'), contentWrap = d.createElement('div');
            b.style.margin = '0';
            b.style.padding = '0';
            b.id = FRAME_BUILDER_IDS.walkthroughAnchorContentBody;
            var fontFamily = (walkthroughStyleConfig === null || walkthroughStyleConfig === void 0 ? void 0 : walkthroughStyleConfig.fontFamily) || walkthroughStyleConfig.fontFamily;
            if (fontFamily) {
                var mappedFontFamily = _this.tenantSvc.getUIFontFamilyMappingDisplayValue(fontFamily);
                b.style.fontFamily = mappedFontFamily;
            }
            // Add content to contentWrap
            contentWrap.className = 'cz-in-app-anchor-container';
            //contentWrap.innerHTML = content;
            var anchorSize = config.triggerConfig.iconStyleConfig.size * 1.5;
            var anchor = _this.generateAnchor(win, config.triggerConfig, contentWrap);
            contentWrap.appendChild(anchor);
            var tooltipArrowSize = 10;
            var px = 'px';
            var ttw = 0, tth = 0, minW = 0, minH = 0, neededTopAdjustment, neededLeftAdjustment;
            var mouseEnterHandler = function () {
                var _a, _b;
                if (!((_b = (_a = config === null || config === void 0 ? void 0 : config.triggerConfig) === null || _a === void 0 ? void 0 : _a.iconStyleConfig) === null || _b === void 0 ? void 0 : _b.hoverTextEnabled)) {
                    return;
                }
                var tooltip = d.querySelector('p.cz-tool-tip__info'), arrow = d.querySelector('span.cz-tool-tip__arrow'), style = getComputedStyle(tooltip);
                var marginLeft = parseInt(style.marginLeft);
                var marginRight = parseInt(style.marginRight);
                var marginTop = parseInt(style.marginTop);
                var marginBottom = parseInt(style.marginBottom);
                ttw = tooltip.offsetWidth + marginLeft + marginRight;
                tth = tooltip.offsetHeight + marginTop + marginBottom;
                minW = ttw > anchorSize ? ttw : anchorSize;
                minH = tth > anchorSize ? tth : anchorSize;
                //force to even numbers to avoid rounding issues
                if (minW % 2 !== 0) {
                    minW++;
                }
                if (minH % 2 !== 0) {
                    minH++;
                }
                //determine where tooltip will be
                //reposition and resize iframe so that tooltip is visible
                //reposition anchor so it appears not to have moved
                anchor.style.position = 'absolute';
                arrow.style.display = 'block';
                var originalTop = parseFloat(contentiFrame.style.top), originalLeft = parseFloat(contentiFrame.style.left);
                switch (config.triggerConfig.iconStyleConfig.hoverTextPositionId) {
                    case clientlibs_1.AnchorHoverTextPosition.Right:
                        //resize the iframe so the tooltip is visible
                        neededTopAdjustment = ((minH - (anchorSize)) / 2);
                        contentiFrame.style.top = originalTop - neededTopAdjustment + px;
                        contentiFrame.style.width = anchorSize + minW + tooltipArrowSize + px;
                        contentiFrame.style.height = minH + px;
                        b.style.width = anchorSize + minW + tooltipArrowSize + px;
                        b.style.height = minH + px;
                        //reposition the anchor in the frame so it appears in the same
                        //place on the page
                        anchor.style.top = neededTopAdjustment + px;
                        //anchor.style.bottom = 'auto';
                        //position the tooltip in the middle of the anchor
                        tooltip.style.top = (anchorSize / 2) - (tth / 2) + px;
                        tooltip.style.left = (anchorSize + tooltipArrowSize) + px;
                        arrow.style.top = (anchorSize / 2) - (tooltipArrowSize) + px; //dont divide arrow size here as the element height is top+bottom border
                        arrow.style.left = (anchorSize) - (tooltipArrowSize) + px; //subtract arrow size here as the element width is left+right border
                        break;
                    case clientlibs_1.AnchorHoverTextPosition.Bottom:
                        //neededTopAdjustment =
                        neededLeftAdjustment = ((minW - anchorSize) / 2);
                        //resize the iframe so the tooltip is visible
                        contentiFrame.style.width = minW + px;
                        contentiFrame.style.height = anchorSize + minH + tooltipArrowSize + px;
                        contentiFrame.style.left = originalLeft - neededLeftAdjustment + px;
                        b.style.width = minW + px;
                        b.style.height = anchorSize + minH + tooltipArrowSize + px;
                        //reposition the anchor in the frame so it appears in the same
                        //place on the page
                        anchor.style.top = '0';
                        anchor.style.bottom = 'auto';
                        anchor.style.left = neededLeftAdjustment + px;
                        //position the tooltip in the middle of the anchor
                        tooltip.style.top = anchorSize + tooltipArrowSize + px;
                        tooltip.style.left = (anchorSize / 2) - (minW / 2) + px;
                        arrow.style.top = (anchorSize) - (tooltipArrowSize) + px; //subtract arrow size here as the element width is 2x border
                        arrow.style.right = (anchorSize / 2) - (tooltipArrowSize) + px; //dont divide arrow size here as the element height is 2x border
                        break;
                    case clientlibs_1.AnchorHoverTextPosition.Left:
                        neededTopAdjustment = ((minH - (anchorSize)) / 2);
                        neededLeftAdjustment = ((minW + tooltipArrowSize));
                        //resize the iframe so the tooltip is visible
                        contentiFrame.style.width = anchorSize + minW + tooltipArrowSize + px;
                        contentiFrame.style.height = anchorSize + minH + px;
                        contentiFrame.style.top = originalTop - neededTopAdjustment + px;
                        contentiFrame.style.left = originalLeft - neededLeftAdjustment + px;
                        b.style.width = anchorSize + minW + tooltipArrowSize + px;
                        b.style.height = anchorSize + minH + px;
                        //reposition the anchor in the frame so it appears in the same
                        //place on the page
                        anchor.style.top = neededTopAdjustment + px;
                        anchor.style.bottom = 'auto';
                        anchor.style.left = neededLeftAdjustment + px;
                        //position the tooltip in the middle of the anchor
                        tooltip.style.top = (anchorSize / 2) - (tth / 2) + px;
                        tooltip.style.right = (anchorSize) + tooltipArrowSize + px;
                        arrow.style.top = (anchorSize / 2) - (tooltipArrowSize) + px; //dont divide arrow size here as the element height is 2x border
                        arrow.style.right = (anchorSize) - (tooltipArrowSize) + px; //subtract arrow size here as the element width is 2x border
                        break;
                    case clientlibs_1.AnchorHoverTextPosition.Top:
                        neededTopAdjustment = (minH + tooltipArrowSize);
                        neededLeftAdjustment = ((minW - anchorSize) / 2);
                        //resize the iframe so the tooltip is visible
                        contentiFrame.style.top = originalTop - neededTopAdjustment + px;
                        contentiFrame.style.left = originalLeft - neededLeftAdjustment + px;
                        contentiFrame.style.height = anchorSize + minH + tooltipArrowSize + px;
                        contentiFrame.style.width = minW + px;
                        b.style.height = anchorSize + minH + tooltipArrowSize + px;
                        b.style.width = minW + px;
                        //reposition the anchor in the frame so it appears in the same
                        //place on the page
                        anchor.style.top = neededTopAdjustment + px;
                        anchor.style.left = neededLeftAdjustment + px;
                        //position the tooltip in the middle of the anchor
                        tooltip.style.top = -tth - tooltipArrowSize + px;
                        tooltip.style.bottom = 'auto';
                        tooltip.style.left = (anchorSize / 2) - (minW / 2) + px;
                        arrow.style.top = -(tooltipArrowSize) + px; //subtract arrow size here as the element width is 2x border
                        arrow.style.right = (anchorSize / 2) - (tooltipArrowSize) + px; //dont divide arrow size here as the element height is 2x border
                        break;
                }
            };
            var mouseLeaveHandler = function () {
                var _a, _b;
                if (!((_b = (_a = config === null || config === void 0 ? void 0 : config.triggerConfig) === null || _a === void 0 ? void 0 : _a.iconStyleConfig) === null || _b === void 0 ? void 0 : _b.hoverTextEnabled)) {
                    return;
                }
                if (window['leaveTooltipOpen']) {
                    return;
                }
                contentiFrame.style.width = anchorSize + px;
                contentiFrame.style.height = anchorSize + px;
                b.style.height = anchorSize + px;
                b.style.width = anchorSize + px;
                anchor.style.top = '0';
                anchor.style.left = '0';
                anchor.style.right = 'auto';
                anchor.style.bottom = 'auto';
                var currentTop = parseFloat(contentiFrame.style.top), currentLeft = parseFloat(contentiFrame.style.left);
                switch (config.triggerConfig.iconStyleConfig.hoverTextPositionId) {
                    case clientlibs_1.AnchorHoverTextPosition.Top:
                        contentiFrame.style.top = currentTop + (neededTopAdjustment) + px;
                        contentiFrame.style.left = currentLeft + neededLeftAdjustment + px;
                        break;
                    case clientlibs_1.AnchorHoverTextPosition.Bottom:
                        contentiFrame.style.left = currentLeft + neededLeftAdjustment + px;
                        break;
                    case clientlibs_1.AnchorHoverTextPosition.Left:
                        contentiFrame.style.top = currentTop + neededTopAdjustment + px;
                        contentiFrame.style.left = currentLeft + neededLeftAdjustment + px;
                        break;
                    case clientlibs_1.AnchorHoverTextPosition.Right:
                        contentiFrame.style.top = currentTop + neededTopAdjustment + px;
                        break;
                }
            };
            anchor.addEventListener('mouseenter', mouseEnterHandler);
            anchor.addEventListener('mouseleave', mouseLeaveHandler);
            pageWrap.appendChild(contentWrap);
            pageWrap.addEventListener('click', clickHandler);
            // Add pageWrap to the body
            b.appendChild(pageWrap);
            if (!Element.prototype.matches)
                Element.prototype.matches = Element.prototype['msMatchesSelector'];
            if (!Element.prototype.closest)
                Element.prototype.closest = function (selector) {
                    return clientlibs_1.CoreUtils.closest(this, selector);
                };
            var cssLinkItems;
            // Custom css from meta data
            if (typeof cssLinks === 'string') {
                cssLinkItems = [cssLinks];
            }
            else {
                cssLinkItems = cssLinks || [];
            }
            for (var i = 0; i < cssLinkItems.length; i++) {
                if (cssLinkItems[i]) {
                    var s = d.createElement('link');
                    s.setAttribute('type', 'text/css');
                    s.href = cssLinkItems[i];
                    s.rel = 'stylesheet';
                    d.head.appendChild(s);
                }
            }
            var customCssItems;
            // Custom css from meta data
            if (typeof customCss === 'string') {
                customCssItems = [customCss];
            }
            else {
                customCssItems = customCss || [];
            }
            for (var i = 0; i < customCssItems.length; i++) {
                if (customCssItems[i]) {
                    var s = d.createElement('style');
                    s.setAttribute('type', 'text/css');
                    s.textContent = customCssItems[i];
                    d.head.appendChild(s);
                }
            }
            // UI Font Family Logic
            _this.addUIFontFamilyCssRequestUrl(d, walkthroughStyleConfig, (config && config['testing']));
            // Remove click and mouse event handlers when the iframe is destroyed
            d.defaultView.onunload = function () {
                pageWrap.removeEventListener('click', clickHandler);
                anchor.removeEventListener('mouseenter', mouseEnterHandler);
                anchor.removeEventListener('mouseleave', mouseLeaveHandler);
            };
            if (config.onLoadCallback && typeof config.onLoadCallback === 'function') {
                config.onLoadCallback(win);
                var resizeDebounce_1;
                win.addEventListener('resize', function () {
                    if (config.onResizeCallback && typeof config.onResizeCallback === 'function') {
                        if (resizeDebounce_1) {
                            _this.windowSvc.window.clearTimeout(resizeDebounce_1);
                        }
                        resizeDebounce_1 = _this.windowSvc.window.setTimeout(function () {
                            config.onResizeCallback(win);
                        }, 10);
                    }
                });
            }
        };
    };
    FrameBuilder.prototype.generateAnchor = function (win, triggerConfig, target) {
        var anchorContainer = this.windowSvc.createElement('span'), anchorSize = (triggerConfig.iconStyleConfig.size * 1.5);
        //vCenter = (target.offsetHeight / 2), //includes content,padding,and border
        //hCenter = (target.offsetWidth / 2), //includes content,padding,and border
        anchorContainer.classList.add('cz-walkthrough-anchor');
        anchorContainer.style.display = 'inline-block';
        anchorContainer.style.textAlign = 'center';
        anchorContainer.style.cursor = 'pointer';
        anchorContainer.style.zIndex = '1000002'; //1 below walkthrough content frames
        /*switch (triggerConfig.iconStyleConfig.positionTypeId) {

            case AnchorPositionType.Top:
                anchorContainer.style.position = 'absolute';
                anchorContainer.style.left = hCenter - sizeOffset + 'px';
                anchorContainer.style.top = sizeOffset * -1 + 'px';
                break;
            case AnchorPositionType.TopRight:
                //anchorContainer.style.position = 'absolute';
                //anchorContainer.style.right = sizeOffset * -1 + 'px';
                //anchorContainer.style.top = sizeOffset * -1 + 'px';
                break;
            case AnchorPositionType.BottomRight:
                anchorContainer.style.position = 'absolute';
                anchorContainer.style.right = sizeOffset * -1 + 'px';
                anchorContainer.style.bottom = sizeOffset * -1 + 'px';
                break;
            case AnchorPositionType.Bottom:
                anchorContainer.style.position = 'absolute';
                anchorContainer.style.left = hCenter - sizeOffset + 'px';
                anchorContainer.style.bottom = sizeOffset * -1 + 'px';
                break;
            case AnchorPositionType.BottomLeft:
                anchorContainer.style.position = 'absolute';
                anchorContainer.style.left = sizeOffset * -1 + 'px';
                anchorContainer.style.bottom = sizeOffset * -1 + 'px';
                break;
            case AnchorPositionType.Left:
                anchorContainer.style.position = 'absolute';
                anchorContainer.style.left = sizeOffset * -1 + 'px';
                anchorContainer.style.top = vCenter - sizeOffset + 'px';
                break;
            case AnchorPositionType.TopLeft:
                anchorContainer.style.position = 'absolute';
                anchorContainer.style.left = sizeOffset * -1 + 'px';
                anchorContainer.style.top = sizeOffset * -1 + 'px';
                break;

            case AnchorPositionType.Right:
            default:
                anchorContainer.style.position = 'absolute';
                anchorContainer.style.right = sizeOffset * -1 + 'px';
                anchorContainer.style.top = vCenter - sizeOffset + 'px';
                break;
        }*/
        anchorContainer.style.top = '0';
        anchorContainer.style.left = '0';
        anchorContainer.style.bottom = 'auto';
        anchorContainer.style.right = 'auto';
        anchorContainer.style.height = anchorSize + 'px';
        anchorContainer.style.width = anchorSize + 'px';
        anchorContainer.style.borderRadius = triggerConfig.iconStyleConfig.size + 'px';
        anchorContainer.style.fontSize = triggerConfig.iconStyleConfig.size + 'px';
        //anchorContainer.style.lineHeight = anchorLineHeight + 'px';
        anchorContainer.style.color = triggerConfig.iconStyleConfig.iconColor;
        anchorContainer.style.backgroundColor = triggerConfig.iconStyleConfig.iconBackgroundColor;
        var anchorIcon = this.windowSvc.createElement('i');
        anchorIcon.classList.add('czi');
        anchorIcon.classList.add(triggerConfig.iconType);
        anchorIcon.style.zIndex = '1000002'; //1 below walkthrough content frames
        anchorIcon.style.display = 'inline-block';
        anchorIcon.style.position = 'absolute';
        anchorIcon.style.height = triggerConfig.iconStyleConfig.size + 'px';
        anchorIcon.style.width = triggerConfig.iconStyleConfig.size + 'px';
        anchorIcon.style.top = (anchorSize - triggerConfig.iconStyleConfig.size) / 2 + 'px';
        var left = (anchorSize - triggerConfig.iconStyleConfig.size) / 2;
        switch (triggerConfig.iconType) {
            case 'czi-play':
                //play icon is slightly narrower than the rest :shrug:
                left += ((triggerConfig.iconStyleConfig.size * 0.25) / 2);
                break;
        }
        anchorIcon.style.left = left + 'px';
        anchorContainer.appendChild(anchorIcon);
        //build tooltip
        if (triggerConfig.iconStyleConfig.hoverTextEnabled) {
            var anchorTooltip = this.windowSvc.createElement('p');
            anchorTooltip.style.fontSize = '12px';
            anchorTooltip.style.color = triggerConfig.iconStyleConfig.hoverTextColor;
            anchorTooltip.style.backgroundColor = triggerConfig.iconStyleConfig.hoverTextBackgroundColor;
            anchorTooltip.style.borderColor = triggerConfig.iconStyleConfig.hoverTextBackgroundColor;
            anchorTooltip.innerText = triggerConfig.iconStyleConfig.hoverText;
            anchorTooltip.classList.add('cz-tool-tip__info');
            var anchorTooltipArrow = this.windowSvc.createElement('span');
            anchorTooltipArrow.classList.add('cz-tool-tip__arrow');
            anchorTooltipArrow.style.display = 'none';
            var posClass = void 0;
            switch (triggerConfig.iconStyleConfig.hoverTextPositionId) {
                case clientlibs_1.AnchorHoverTextPosition.Left:
                    posClass = 'cz-tool-tip__left';
                    anchorTooltipArrow.style.borderLeftColor = triggerConfig.iconStyleConfig.hoverTextBackgroundColor;
                    break;
                case clientlibs_1.AnchorHoverTextPosition.Bottom:
                    posClass = 'cz-tool-tip__bottom';
                    anchorTooltipArrow.style.borderBottomColor = triggerConfig.iconStyleConfig.hoverTextBackgroundColor;
                    break;
                case clientlibs_1.AnchorHoverTextPosition.Right:
                    posClass = 'cz-tool-tip__right';
                    anchorTooltipArrow.style.borderRightColor = triggerConfig.iconStyleConfig.hoverTextBackgroundColor;
                    break;
                case clientlibs_1.AnchorHoverTextPosition.Top:
                    posClass = 'cz-tool-tip__top';
                    anchorTooltipArrow.style.borderTopColor = triggerConfig.iconStyleConfig.hoverTextBackgroundColor;
                    break;
            }
            anchorTooltip.classList.add(posClass);
            anchorContainer.appendChild(anchorTooltip);
            anchorContainer.appendChild(anchorTooltipArrow);
        }
        return anchorContainer;
    };
    /** Walkthroughs **/
    FrameBuilder.prototype.buildWalkthroughContentFrame = function (configuration) {
        var stepType = configuration.stepType, content = configuration.content, config = configuration.config, clickAuditData = configuration.clickAuditData, onResizeCallback = configuration.onResizeCallback, onShownCallback = configuration.onShownCallback, styleConfig = configuration.styleConfig, sequence = configuration.sequence, metaData = configuration.metaData;
        var contentiFrame = this.windowSvc.createElement('iframe');
        contentiFrame.style.margin = '0';
        contentiFrame.style.padding = '0';
        contentiFrame.style.border = 'none';
        contentiFrame.style.display = 'block'; // force block-level rules
        contentiFrame.style.width = '100%';
        contentiFrame.style.maxWidth = '100%';
        console.log('ClickAuditData', clickAuditData);
        var transportPod = clientlibs_1.iFrameUtils.buildTransportMessage(clientlibs_1.TransportCodes.WalkthroughClickAudit, clickAuditData);
        var customCss = clientlibs_1.StyleUtils.froalaViewerStyle;
        if (this.sessionSvc.CurrentAccountContent && this.sessionSvc.CurrentAccountContent.css) {
            customCss += this.sessionSvc.CurrentAccountContent.css;
        }
        var fontFamily = (styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.fontFamily) || config.fontFamily, _a = styleConfig || {}, fontSize = _a.fontSize, fontColor = _a.fontColor, textAlignment = _a.textAlignment;
        var cssText = '';
        if (fontFamily) {
            cssText += "font-family:" + this.tenantSvc.getUIFontFamilyMappingDisplayValue(fontFamily) + ";";
        }
        if (typeof fontSize === 'number') {
            cssText += "font-size:" + fontSize + "px;";
        }
        if (fontColor) {
            cssText += "color:" + fontColor + ";";
        }
        if (textAlignment) {
            cssText += "text-align:" + textAlignment + ";";
        }
        customCss += "body{" + cssText + "}p{margin: 0 0 1rem 0;}";
        customCss += inline_styles_constants_1.WT_CONTENT_CONTAINER_STYLES;
        customCss += inline_styles_constants_1.WT_CTA_CONTAINER_STYLES;
        customCss += inline_styles_constants_1.WT_STEP_NUMBER_STYLES;
        customCss += inline_styles_constants_1.WT_POPUP_STYLES;
        var buttonHoverColor = styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.ctaButtonHoverColor;
        if (buttonHoverColor) {
            customCss += ".cz-walk-cta-button:hover{background-color:" + buttonHoverColor + "!important;border-color:" + buttonHoverColor + "!important;}";
        }
        if (metaData === null || metaData === void 0 ? void 0 : metaData.cssText) {
            customCss += metaData === null || metaData === void 0 ? void 0 : metaData.cssText;
        }
        var meta = {
            stepType: stepType,
            config: config,
            styleConfig: styleConfig,
            content: content,
            customCss: customCss,
            transportPod: transportPod,
            sequence: sequence,
            totalSteps: metaData === null || metaData === void 0 ? void 0 : metaData.totalSteps,
            onCloseCallback: metaData === null || metaData === void 0 ? void 0 : metaData.onCloseCallback
        };
        stepType === clientlibs_1.WalkthroughStepType.Slider && contentiFrame.classList.add(this.czSliderClassName);
        contentiFrame.classList.add('cz-walk-content-frame');
        contentiFrame.addEventListener('load', this.getWalkthroughContentIFrameLoadFunc(meta, onResizeCallback, onShownCallback));
        return contentiFrame;
    };
    FrameBuilder.prototype.getWalkthroughContentIFrameLoadFunc = function (metaData, onResizeCallback, onShownCallback) {
        var _this = this;
        var stepType = metaData.stepType, config = metaData.config, styleConfig = metaData.styleConfig, sequence = metaData.sequence, totalSteps = metaData.totalSteps, onCloseCallback = metaData.onCloseCallback;
        // Page wrap click handler
        var clickHandler = function (e) {
            var className = e.target.className, wasCta = className === _this.callToActionButtonClass, wasClose = className === 'cz-close-walk';
            if (!wasCta && !wasClose) {
                return;
            }
            onCloseCallback === null || onCloseCallback === void 0 ? void 0 : onCloseCallback(wasCta);
        };
        // Determine content class
        var defaultVideoWidth = clientlibs_1.StyleConfigPopUpWidth.Small;
        switch (stepType) {
            case clientlibs_1.WalkthroughStepType.Slider:
                defaultVideoWidth = clientlibs_1.StyleConfigSliderWidth.Small;
                break;
            case clientlibs_1.WalkthroughStepType.Tooltip:
                defaultVideoWidth = clientlibs_1.StyleConfigTooltipWidth.Small;
                break;
            default:
                break;
        }
        return function (e) {
            var contentiFrame = e.target;
            var win = contentiFrame.contentWindow, d = win.document, b = d.body, pageWrap = d.createElement('section'), contentWrap = d.createElement('div');
            b.style.margin = '0';
            b.style.padding = '0';
            // b.style.width = "100%";
            b.id = FRAME_BUILDER_IDS.walkthroughContentBody;
            // Add content to contentWrap
            contentWrap.className = 'cz-walk-content-container';
            if (config['testing']) {
                contentWrap.classList.add('cz-walk-content-preview');
            }
            contentWrap.innerHTML = metaData.content;
            _this.setContentContainerHorizontalPadding(contentWrap, styleConfig); // Pad content horizontally, if applicable
            // Add contentWrap and cta to the page wrap
            var cta = _this.buildCTAContainer(config, false, styleConfig);
            pageWrap.className = 'cz-walk-page-container';
            pageWrap.innerHTML = (styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.shouldHideClose) ? '' : '<span class="cz-close-walk">&#x2716;</span>';
            var supportsResizeObserver = DOM_utils_1.DOMUtils.isFeatureSupported(win, 'ResizeObserver');
            if (supportsResizeObserver) {
                var frameResizeObserver_2 = clientlibs_1.iFrameUtils.getFrameResizeObserver(contentiFrame, onShownCallback, onResizeCallback);
                frameResizeObserver_2.observe(pageWrap);
                d.defaultView.addEventListener('unload', function () {
                    frameResizeObserver_2.disconnect();
                    console.log('WT: resize obs unload!');
                });
            }
            pageWrap.appendChild(contentWrap);
            pageWrap.appendChild(cta);
            pageWrap.addEventListener('click', clickHandler);
            _this.appendWalkthroughStepNumber(pageWrap, styleConfig, sequence, totalSteps);
            _this.addStepNumberContainerClassName(pageWrap, styleConfig);
            // Add pageWrap to the body
            b.appendChild(pageWrap);
            if (!Element.prototype.matches)
                Element.prototype.matches = Element.prototype['msMatchesSelector'];
            if (!Element.prototype.closest)
                Element.prototype.closest = function (selector) {
                    return clientlibs_1.CoreUtils.closest(this, selector);
                };
            // Custom css from meta data
            var s = d.createElement('style');
            s.setAttribute('type', 'text/css');
            s.textContent = metaData.customCss;
            d.head.appendChild(s);
            // UI Font Family Logic
            _this.addUIFontFamilyCssRequestUrl(d, styleConfig, (config && config['testing']));
            // WT-Specific css
            _this.addWalkthroughStyleProperties(contentiFrame, config, stepType, styleConfig, pageWrap);
            //ensure all videos are playable
            var videos = b.querySelectorAll('.fr-video');
            _this.fixVideoElementsFromFroala(videos, defaultVideoWidth);
            //ensure images are the correct size
            var images = b.querySelectorAll('.fr-fic');
            _this.fixImageElementsFromFroala(images);
            // Set up click audit event listeners
            FrameComm_util_1.FrameCommUtil.setUpLinkAuditEvents(win, metaData === null || metaData === void 0 ? void 0 : metaData.transportPod);
            FrameComm_util_1.FrameCommUtil.setUpVideoAuditEvents(win, metaData === null || metaData === void 0 ? void 0 : metaData.transportPod);
            // Old browsers that don't support ResizeObserver must use an interval to adjust the content frame's height
            if (!supportsResizeObserver) {
                var resizeIntervalDereg = clientlibs_1.iFrameUtils.setFrameHeightBySourceAtInterval(pageWrap, contentiFrame, 200, onShownCallback, onResizeCallback);
                d.defaultView.addEventListener('unload', resizeIntervalDereg);
            }
            // Clear the checkHeight interval & remove click events when iframe is destroyed
            d.defaultView.addEventListener('unload', function () {
                pageWrap.removeEventListener('click', clickHandler);
            });
        };
    };
    /**
     * Removes any <style> elements created by walkthrough logic
     */
    FrameBuilder.prototype.removeWalkthroughStyleElements = function () {
        for (var prop in FRAME_BUILDER_STYLE_ELEMENT_ID_MAPPING) {
            if (!clientlibs_1.CoreUtils.hasOwnProp(FRAME_BUILDER_STYLE_ELEMENT_ID_MAPPING, prop))
                continue;
            var el = this.windowSvc.document.getElementById(FRAME_BUILDER_STYLE_ELEMENT_ID_MAPPING[prop]);
            el && el.parentNode && el.parentNode.removeChild(el);
        }
    };
    FrameBuilder.prototype.getWalkthroughStyleProperties = function (config, styleConfig) {
        // Get style properties
        var br = (typeof (styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.borderRadius) === 'number') ? styleConfig.borderRadius : config.borderRadius, bw = (typeof (styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.borderWidth) === 'number') ? styleConfig.borderWidth : 0, backgroundColor = (styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.backgroundColor) || config.backgroundColor || '', closeColor = (styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.closeColor) || config.closeColor, closeHoverColor = styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.closeHoverColor, borderColor = styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.borderColor, shouldHideClose = styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.shouldHideClose, textAlign = styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.textAlignment, shouldShowStepNumber = styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.shouldShowStepNumber, stepNumberPosition = styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.stepNumberPosition, stepNumberColor = styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.stepNumberColor;
        return {
            backgroundColor: backgroundColor,
            closeColor: closeColor,
            closeHoverColor: closeHoverColor,
            borderRadius: br,
            borderColor: borderColor,
            borderWidth: bw,
            shouldHideClose: shouldHideClose,
            textAlign: textAlign,
            shouldShowStepNumber: shouldShowStepNumber,
            stepNumberPosition: stepNumberPosition,
            stepNumberColor: stepNumberColor
        };
    };
    /* Walkthrough Utilities */
    FrameBuilder.prototype.buildCTAContainer = function (config, setBorderRadius, styleConfig) {
        // Style config properties
        var ctaText = (styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.ctaText) || config.ctaText, ctaFontSize = styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.ctaFontSize, ctaFontFamily = styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.ctaFontFamily, alignment = (styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.ctaAlignment) || config.ctaAlignment, bgColor = (styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.ctaBackgroundColor) || config.ctaBackgroundColor, textColor = (styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.ctaTextColor) || config.ctaTextColor, borderRadius = (styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.borderRadius) || config.borderRadius, buttonColor = (styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.ctaButtonColor) || config.ctaButtonColor, borderColor = styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.ctaButtonBorderColor;
        var ctaContainer = this.windowSvc.createElement('div');
        ctaContainer.classList.add(this.callToActionContainerClass);
        ctaContainer.style.textAlign = alignment || 'center';
        var ctaButton = this.windowSvc.createElement('button');
        ctaButton.classList.add(this.callToActionButtonClass);
        ctaButton.style.backgroundColor = buttonColor || '#FFFFFF';
        ctaButton.style.borderColor = borderColor || buttonColor || '#FFFFFF';
        ctaButton.style.color = textColor || '#FFFFFF';
        ctaButton.textContent = ctaText || 'Got it!';
        if (typeof ctaFontSize === 'number') {
            ctaButton.style.fontSize = ctaFontSize + "px";
        }
        if (ctaFontFamily) {
            ctaButton.style.fontFamily = this.tenantSvc.getUIFontFamilyMappingDisplayValue(ctaFontFamily);
        }
        ctaContainer.appendChild(ctaButton);
        ctaContainer.style.borderColor = bgColor || 'white';
        ctaContainer.style.borderTopColor = 'transparent';
        ctaContainer.style.backgroundColor = bgColor || 'white';
        if (setBorderRadius && !clientlibs_1.CoreUtils.isNullOrUndefined(borderRadius)) {
            ctaContainer.style.borderTopLeftRadius = '0';
            ctaContainer.style.borderTopRightRadius = '0';
            ctaContainer.style.borderBottomLeftRadius = borderRadius + 'px';
            ctaContainer.style.borderBottomRightRadius = borderRadius + 'px';
        }
        return ctaContainer;
    };
    FrameBuilder.prototype.appendWalkthroughStepNumber = function (container, styleConfig, sequence, totalSteps) {
        var _a = styleConfig || {}, shouldShowStepNumber = _a.shouldShowStepNumber, stepNumberPosition = _a.stepNumberPosition, stepNumberColor = _a.stepNumberColor;
        if (!shouldShowStepNumber || !stepNumberColor)
            return;
        var numberWrap = this.windowSvc.createElement('span'), num = (sequence || 0) + 1;
        numberWrap.className = 'cz-walk-step-number';
        numberWrap.innerHTML = num + " / " + (totalSteps || num);
        numberWrap.style.setProperty('color', stepNumberColor, 'important');
        switch (stepNumberPosition) {
            case clientlibs_1.StepNumberPosition.TopCenter:
                numberWrap.classList.add('top-center');
                break;
            case clientlibs_1.StepNumberPosition.TopRight:
                numberWrap.classList.add('top-right');
                break;
            case clientlibs_1.StepNumberPosition.BottomLeft:
                numberWrap.classList.add('bottom-left');
                break;
            case clientlibs_1.StepNumberPosition.BottomCenter:
                numberWrap.classList.add('bottom-center');
                break;
            case clientlibs_1.StepNumberPosition.BottomRight:
                numberWrap.classList.add('bottom-right');
                break;
            default:
                numberWrap.classList.add('top-left');
                break;
        }
        container.appendChild(numberWrap);
    };
    FrameBuilder.prototype.addStepNumberContainerClassName = function (container, styleConfig) {
        var _a = styleConfig || {}, shouldShowStepNumber = _a.shouldShowStepNumber, stepNumberColor = _a.stepNumberColor, stepNumberPosition = _a.stepNumberPosition;
        var hasStepNumber = !!(shouldShowStepNumber && stepNumberColor);
        if (!hasStepNumber)
            return;
        switch (stepNumberPosition) {
            case clientlibs_1.StepNumberPosition.BottomCenter:
            case clientlibs_1.StepNumberPosition.BottomLeft:
            case clientlibs_1.StepNumberPosition.BottomRight:
                container.classList.add('has-bottom-step-number');
                break;
            case clientlibs_1.StepNumberPosition.TopLeft:
            case clientlibs_1.StepNumberPosition.TopCenter:
            case clientlibs_1.StepNumberPosition.TopRight: {
                container.classList.add('has-top-step-number');
                if (stepNumberPosition === clientlibs_1.StepNumberPosition.TopRight)
                    container.classList.add('has-top-right-step-number');
                break;
            }
            default:
                break;
        }
    };
    FrameBuilder.prototype.addWalkthroughStyleProperties = function (frame, config, stepType, styleConfig, targetElement) {
        var styleProps = this.getWalkthroughStyleProperties(config, styleConfig);
        // Determine <style> element id
        var styleId = '';
        switch (stepType) {
            case clientlibs_1.WalkthroughStepType.PopUp:
                styleId = FRAME_BUILDER_STYLE_ELEMENT_ID_MAPPING.popupStyle;
                break;
            case clientlibs_1.WalkthroughStepType.Slider:
                styleId = FRAME_BUILDER_STYLE_ELEMENT_ID_MAPPING.sliderStyle;
                break;
            case clientlibs_1.WalkthroughStepType.Tooltip:
                styleId = FRAME_BUILDER_STYLE_ELEMENT_ID_MAPPING.tooltipStyle;
                break;
            default:
                throw new Error('addWalkthroughStyleProperties: Unknown WalkThroughElementType!');
        }
        var announcementStyleConfig = {
            position: undefined
        };
        if (stepType === clientlibs_1.WalkthroughStepType.Slider) {
            announcementStyleConfig.position = config.position;
        }
        /*
        ! This used to pass in the targetElement as the second argument, but I do not believe we need to do that.
        ! (Making a note here in case we need to reinstate the old logic)
        */
        this.addAnnouncementStyleProperties(frame, frame, styleId, styleProps, Enums_1.Enums.FrameType.WalkThrough, announcementStyleConfig);
    };
    /* Shared Utilities */
    FrameBuilder.prototype.addAnnouncementStyleProperties = function (frame, targetElement, styleId, styleProps, frameType, config) {
        var backgroundColor = styleProps.backgroundColor, closeColor = styleProps.closeColor, closeHoverColor = styleProps.closeHoverColor, borderRadius = styleProps.borderRadius, borderWidth = styleProps.borderWidth, borderColor = styleProps.borderColor, hasBorderRadius = typeof borderRadius === 'number';
        // Create on-page style element
        var shouldAppend = false, styleTag = document.getElementById(styleId);
        if (!styleTag) {
            shouldAppend = true;
            styleTag = this.windowSvc.createElement('style');
            styleTag.id = styleId;
            styleTag.setAttribute('type', 'text/css');
        }
        var closeClassName = (frameType === Enums_1.Enums.FrameType.InAppAnnouncement) ? '.cz-close-in-app' : '.cz-close-walk';
        if (closeColor) {
            styleTag.innerText += closeClassName + "{text-shadow:0 0 0 " + closeColor + "}";
        }
        if (closeHoverColor) {
            styleTag.innerText += closeClassName + ":hover{text-shadow:0 0 0 " + closeHoverColor + "}";
        }
        // Bg color
        targetElement.style.setProperty('background-color', backgroundColor, 'important');
        // Border width and color
        if (typeof borderWidth === 'number' && borderColor) {
            targetElement.style.border = borderWidth + "px solid " + borderColor;
        }
        // Border radius styles
        if (hasBorderRadius) {
            frame.style.setProperty('border-radius', borderRadius + "px");
            if (clientlibs_1.CoreUtils.hasOwnProp(config, 'position'))
                this.setSliderBorderRadiusStyles(config.position, frame);
        }
        if (shouldAppend)
            frame.contentDocument.getElementsByTagName('head')[0].appendChild(styleTag);
    };
    FrameBuilder.prototype.setSliderBorderRadiusStyles = function (position, sliderElement) {
        switch (position) {
            case clientlibs_1.AnnouncementPosition.SlideTopLeft:
            case clientlibs_1.AnnouncementPosition.SlideTopCenter:
            case clientlibs_1.AnnouncementPosition.SlideTopRight: {
                sliderElement.style.borderTopLeftRadius = '0px';
                sliderElement.style.borderTopRightRadius = '0px';
                break;
            }
            case clientlibs_1.AnnouncementPosition.SlideRightTop:
            case clientlibs_1.AnnouncementPosition.SlideRightCenter:
            case clientlibs_1.AnnouncementPosition.SlideRightBottom: {
                sliderElement.style.borderTopRightRadius = '0px';
                sliderElement.style.borderBottomRightRadius = '0px';
                break;
            }
            case clientlibs_1.AnnouncementPosition.SlideBottomLeft:
            case clientlibs_1.AnnouncementPosition.SlideBottomCenter:
            case clientlibs_1.AnnouncementPosition.SlideBottomRight: {
                sliderElement.style.borderBottomLeftRadius = '0px';
                sliderElement.style.borderBottomRightRadius = '0px';
                break;
            }
            case clientlibs_1.AnnouncementPosition.SlideLeftTop:
            case clientlibs_1.AnnouncementPosition.SlideLeftCenter:
            case clientlibs_1.AnnouncementPosition.SlideLeftBottom: {
                sliderElement.style.borderTopLeftRadius = '0px';
                sliderElement.style.borderBottomLeftRadius = '0px';
                break;
            }
        }
    };
    FrameBuilder.prototype.setContentContainerHorizontalPadding = function (container, styleConfig) {
        var _a = styleConfig || {}, textAlignment = _a.textAlignment, shouldShowStepNumber = _a.shouldShowStepNumber, stepNumberPosition = _a.stepNumberPosition, hasTopStepNumber = shouldShowStepNumber && (stepNumberPosition === clientlibs_1.StepNumberPosition.TopLeft || stepNumberPosition === clientlibs_1.StepNumberPosition.TopRight);
        if (textAlignment === 'left' && hasTopStepNumber) {
            container.style.paddingLeft = '30px';
            return;
        }
        if (textAlignment === 'right') {
            container.style.paddingRight = '30px';
        }
    };
    FrameBuilder.prototype.addUIFontFamilyCssRequestUrl = function (doc, styleConfig, isTesting) {
        var fontLinkHref = (isTesting) ?
            this.tenantSvc.getFullUIFontFamilyCssRequestUrl() :
            this.tenantSvc.buildUIFontFamilyCssRequestUrlFromConfig(styleConfig);
        if (!fontLinkHref) {
            return;
        }
        var fontLink = doc.createElement('link');
        fontLink.href = fontLinkHref;
        fontLink.rel = 'stylesheet';
        doc.head.appendChild(fontLink);
    };
    FrameBuilder.prototype.fixVideoElementsFromFroala = function (videos, parentWidth) {
        var _a;
        var len = videos.length;
        for (var i = 0; i < len; i++) {
            var vid = videos[i];
            vid.classList.add('fr-active');
            var vFrame = vid.querySelector('iframe');
            if (!vFrame) {
                continue;
            }
            var vidProps = vid.getBoundingClientRect(), ratio = 0.5625;
            var vFrameStyleWidth = 0;
            if (((_a = vFrame.style) === null || _a === void 0 ? void 0 : _a.width) && vFrame.style.width !== '100%') {
                vFrameStyleWidth = parseInt(vFrame.style.width || '0');
            }
            var vFrameAttrWidth = vFrame.getAttribute('width');
            if (vFrameAttrWidth === '100%') {
                vFrameAttrWidth = '';
            }
            // if the video has an explicit width, use that. Otherwise, use the provided parentWidth minus 21px on each side
            var vidWidth = vidProps.width || vFrameStyleWidth || parseInt(vFrameAttrWidth || '0') || parentWidth - 42, h = ratio * vidWidth;
            console.log('vid width', vidWidth);
            console.log('vid ratio', ratio);
            //recalc for impending scroll bar
            if ((h / window.innerHeight) > 0.75) {
                vidWidth = vidWidth - 12;
                h = vidWidth * ratio;
            }
            vFrame.style.setProperty('width', vidWidth + 'px', 'important');
            vFrame.style.setProperty('height', h + 'px', 'important');
            vFrame.setAttribute('width', vidWidth.toString());
            vFrame.setAttribute('height', h.toString());
        }
    };
    FrameBuilder.prototype.fixImageElementsFromFroala = function (images) {
        for (var i = 0; i < images.length; i++) {
            var img = images[i];
            if (img.style.width.indexOf('%') === -1) {
                var width = parseInt(img.style.width || '300');
                if (width >= 300) {
                    img.style.width = '100%';
                }
                else {
                    img.style.width = ((width / 651) * 100) + '%';
                }
            }
        }
    };
    return FrameBuilder;
}());
exports.FrameBuilder = FrameBuilder;


/***/ }),

/***/ "./src/core/HashHandler.ts":
/*!*********************************!*\
  !*** ./src/core/HashHandler.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var HashHandler = /** @class */ (function () {
    // eslint-disable-next-line @typescript-eslint/ban-types
    function HashHandler(onChangeEvent, stopOnChange, timeout) {
        var _this = this;
        if (timeout === void 0) { timeout = 100; }
        this.oldHash = window.location.hash;
        this.onChangeEvent = onChangeEvent;
        this.stopOnChange = stopOnChange;
        this.Check = window.setInterval(function () {
            try {
                _this.detect();
            }
            catch (ex) {
                //meh
            }
        }, timeout);
    }
    HashHandler.prototype.detect = function () {
        if (this.oldHash !== window.location.hash) {
            console.log('Hash Changed');
            this.onChangeEvent();
            if (this.stopOnChange) {
                this.Stop();
            }
            this.oldHash = window.location.hash;
        }
    };
    HashHandler.prototype.Stop = function () {
        if (this.Check) {
            window.clearInterval(this.Check);
            this.Check = null;
        }
    };
    return HashHandler;
}());
exports["default"] = HashHandler;


/***/ }),

/***/ "./src/core/Herald.ts":
/*!****************************!*\
  !*** ./src/core/Herald.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Enums_1 = __webpack_require__(/*! ./Enums */ "./src/core/Enums.ts");
var errorLogger_1 = __importDefault(__webpack_require__(/*! ./errorLogger */ "./src/core/errorLogger.ts"));
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var tenant_service_1 = __webpack_require__(/*! ../services/tenant.service */ "./src/services/tenant.service.ts");
var FrameBuilder_1 = __webpack_require__(/*! ./FrameBuilder */ "./src/core/FrameBuilder.ts");
var inline_styles_constants_1 = __webpack_require__(/*! @src/constants/inline-styles.constants */ "./src/constants/inline-styles.constants.ts");
var Herald = /** @class */ (function () {
    function Herald(appSvc, tenantSvc, sessionSvc, messageSvc, walkthroughSvc, windowSvc, commSvc, templateCache) {
        var _this = this;
        this.appSvc = appSvc;
        this.tenantSvc = tenantSvc;
        this.sessionSvc = sessionSvc;
        this.messageSvc = messageSvc;
        this.walkthroughSvc = walkthroughSvc;
        this.windowSvc = windowSvc;
        this.commSvc = commSvc;
        this.templateCache = templateCache;
        this.subIds = {};
        this.seenWalkthroughIds = [];
        this.lastShownAnnouncementDate = null;
        //walkthroughs
        this.currentWalkthrough = undefined;
        this.currentWalkthroughStep = undefined;
        this.currentWalkthroughCssText = undefined;
        this.walkthroughPopupClass = 'cz-walk-popup';
        this.walkthroughPopupContentClass = 'cz-walk-popup-content';
        this.inAppPopupClass = 'cz-in-app-popup';
        this.inAppPopupContentClass = 'cz-in-app-popup-content';
        this.walkthroughSliderClass = 'cz-walk-slider';
        this.walkthroughSliderContainerClass = 'cz-walk-slider-container';
        this.walkthroughSliderContentClass = 'cz-walk-slider-content';
        //tooltips
        this.tooltipClass = 'cz-walk-tooltip-container';
        this.tooltipContentClass = 'cz-walk-tooltip-container-content';
        this.tooltipTriangleClass = 'cz-tooltip-triangle';
        this.tooltipTriangleInnerClass = 'cz-tooltip-triangle-inner';
        this.overAnnouncementiFrame = -1;
        this.overWalkthroughiFrame = -1;
        this.anchorFrames = [];
        this.defaultTestMessageContent = '<p><em>This is a test message</em></p>';
        this.surveyLinkHash = '#surveyLink';
        this.czInClassName = 'cz-in';
        this.onCustomSurveyClick = function (e) {
            if (!e.target || e.target['hash'] !== _this.surveyLinkHash) {
                return true;
            }
            try {
                var target = e.target;
                var container = clientlibs_1.CoreUtils.closest(target, '.cz-announcement');
                var url = container.getAttribute('data-nps-url');
                var showNewWindow = (container.getAttribute('data-show-new-window') || '').toLowerCase() === 'true';
                var wide = (container.getAttribute('data-nps-wide') || '').toLowerCase() === 'true';
                var socketAnnouncement = _this.messageSvc.GetAnnouncementFromAnnouncementHtml(container);
                _this.closeSlider();
                _this.showSurveyPopup(url, showNewWindow, false, wide, socketAnnouncement);
            }
            catch (ex) {
                errorLogger_1.default.report('Herald.npsClickEvent', ex);
            }
        };
        this.onStandardSurveyClick = function (e) {
            var target = e.target, hasClass = target.classList.contains('cz-nps-click');
            if (!hasClass) {
                target = clientlibs_1.CoreUtils.closest(target, '.cz-nps-click');
                hasClass = target !== undefined;
            }
            if (hasClass) {
                try {
                    var url = target.getAttribute('data-nps-url');
                    var wide = (target.getAttribute('data-nps-wide') || '').toLowerCase() === 'true';
                    var showNewWindow = (target.getAttribute('data-show-new-window') || '').toLowerCase() === 'true';
                    var announcement = clientlibs_1.CoreUtils.closest(target, '.cz-announcement');
                    var showMessageBubble = (announcement.getAttribute('data-info-message') || 'true').toLowerCase() === 'true';
                    var socketAnnouncement = _this.messageSvc.GetAnnouncementFromAnnouncementHtml(target);
                    _this.closeSlider();
                    _this.showSurveyPopup(url, showNewWindow, showMessageBubble, wide, socketAnnouncement);
                }
                catch (ex) {
                    //report?
                    errorLogger_1.default.report('Herald.npsClickEvent', ex);
                }
            }
        };
        this.onStartWalkthrough = this.onStartWalkthrough.bind(this);
        this.TestAnnouncement = this.TestAnnouncement.bind(this);
        this.UpdateAnnouncement = this.UpdateAnnouncement.bind(this);
        this.HideAnyAnnouncement = this.HideAnyAnnouncement.bind(this);
        this.AnnouncementLinkClickHandler = this.AnnouncementLinkClickHandler.bind(this);
        this.CloseSliderClickHandler = this.CloseSliderClickHandler.bind(this);
        this.ShowNPSClickHandler = this.ShowNPSClickHandler.bind(this);
        this.CompletelyAbandonAnyCurrentWalkthrough = this.CompletelyAbandonAnyCurrentWalkthrough.bind(this);
        this.setupWalkthroughAnchor = this.setupWalkthroughAnchor.bind(this);
        this.onWindowResizeForAnchors = this.onWindowResizeForAnchors.bind(this);
        this.frameBuilder = new FrameBuilder_1.FrameBuilder(windowSvc, sessionSvc, tenantSvc);
        this.onInit();
    }
    Object.defineProperty(Herald.prototype, "popupDiv", {
        //popups
        get: function () {
            return this.windowSvc.document.getElementById('cz_popover');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Herald.prototype, "popupContainer", {
        get: function () {
            return this.windowSvc.document.getElementById('cz_popover_content');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Herald.prototype, "popupBackground", {
        get: function () {
            return this.windowSvc.document.getElementById('cz_transBG');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Herald.prototype, "sliderContainer", {
        //sliders
        get: function () {
            return this.windowSvc.czq('.cz-slide-announcement');
        },
        enumerable: false,
        configurable: true
    });
    /* Lifecycle Hooks */
    Herald.prototype.onInit = function () {
        var _this = this;
        //if the panel is silenced exit now
        if (this.sessionSvc.IsSilent) {
            console.info('Silent Mode');
            return;
        }
        this.addPopOverDiv();
        this.checkForLastAdvancedDisplayAnnouncement();
        //subscribe to events
        //this.subIds["startId"] = this.appSvc.pubsub.subscribe(Enums.ChurnZeroAppEvents.START, () => this.onStart());
        this.subIds['digestId'] = this.appSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.DIGEST, function () { return _this.onDigest(); });
        this.subIds['haltId'] = this.appSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.HALT, function () { return _this.onHalt(); });
        this.subIds['walkthroughId'] = this.appSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.WalkthroughStart, function (message) { return _this.onStartWalkthrough(message.info); });
        //set up socket for incoming announcements
        this.subIds['announcementListenerId'] = this.commSvc.registerListener(Enums_1.Enums.SocketMessageTypes.SOCKETMESSAGETYPE_ANNOUNCEMENT, function (message) {
            console.info('announcement received');
            _this.createNewAnnouncement(message.info);
        });
        //set up socket for expire notifications
        this.subIds['expireListenerId'] = this.commSvc.registerListener(Enums_1.Enums.SocketMessageTypes.SOCKETMESSAGETYPE_EXPIRE_MESSAGE, function (message) {
            console.info('expire message received', message.info);
            _this.expireAnnouncement(message.info);
            _this.appSvc.pubsub.publish(clientlibs_1.ChurnZeroAppEvents.ExpireAnnouncement, message.info);
        });
        //add event handler for closing Survey popups
        this.windowSvc.elementCache.body.on(this.windowSvc.namespaceEvent('click'), '.cz-close-popover-trigger', function (e) {
            try {
                var target = _this.windowSvc.czq(e.currentTarget);
                var announcementCont = target.closest('.cz-popover');
                var announcement = announcementCont.find('.cz-announcement');
                if (announcement.length === 0) {
                    announcement = announcementCont.find('#cz_nps_frame');
                }
                var showMessageBubble = (announcement.attr('data-info-message') || 'true').toLowerCase() === 'true';
                var socketAnnouncement = _this.messageSvc.GetAnnouncementFromAnnouncementHtml(announcement.get(0));
                _this.closePopUpAnnouncement(false, false);
                if (showMessageBubble) {
                    _this.announceClosure(_this.sessionSvc.CurrentAccountContent.clickToSeeMoreText, socketAnnouncement);
                }
                _this.onAdvancedDisplayClose();
            }
            catch (ex) {
                //report?
                errorLogger_1.default.report('Herald.closePopoverEvent', ex);
            }
        });
        //add event handler for closing survey sliders
        this.windowSvc.elementCache.body.on(this.windowSvc.namespaceEvent('click'), '.cz-close-announcement', this.CloseSliderClickHandler);
        //add event handler for showing nps popup
        // announcementNpsTemplate.html || announcementNpsTemplatePanel.html
        this.windowSvc.elementCache.body.on(this.windowSvc.namespaceEvent('click'), '.cz-nps-click', this.ShowNPSClickHandler);
        //event handler for when announcements/messages that contain a link are clicked
        this.windowSvc.elementCache.body.on(this.windowSvc.namespaceEvent('click'), '.cz-click-audit a', this.AnnouncementLinkClickHandler);
        //attach listener for any messages posted from ChurnZero
        this.boundClickAuditHandler = clientlibs_1.iFrameUtils.attachTransportMessageListener(this.windowSvc.window, '*', function (transportMessage) {
            var code = transportMessage.code, data = transportMessage.data;
            switch (code) {
                case clientlibs_1.TransportCodes.AnnouncementFrameComm: {
                    if (!data) {
                        return;
                    }
                    _this.messageClicked(data.id);
                    break;
                }
                case clientlibs_1.TransportCodes.WalkthroughClickAudit:
                    _this.walkthroughMessageClicked(data);
                    break;
                case clientlibs_1.TransportCodes.InterfaceComm: {
                    switch (data.code) {
                        case clientlibs_1.InterfaceCommCodes.NpsAnnouncementLinkClicked:
                            _this.ShowNPSFrameCommHandler(data);
                            break;
                        case clientlibs_1.InterfaceCommCodes.AnnouncementClickAudit:
                            _this.messageClicked(data === null || data === void 0 ? void 0 : data.id);
                            break;
                    }
                    break;
                }
            }
        }, null, function (ex, e) {
            errorLogger_1.default.report('iFrameUtils.attachTransportMessageListener at Herald.ts', ex, (e.data || 'e.data is falsy').toString());
        });
        this.windowSvc.elementCache.body
            .on(this.windowSvc.namespaceEvent('mouseenter'), '.cz-click-audit .fr-video iframe', function (e) {
            var auditContainer = _this.windowSvc.czq(e.currentTarget).closest('.cz-click-audit');
            //if there is no audit container then bailout
            if (!auditContainer || auditContainer.length === 0) {
                return;
            }
            var messageId = auditContainer.attr('data-message-id');
            if (messageId) {
                _this.overAnnouncementiFrame = messageId;
            }
            // ! This is probably going away...not sure yet
            if (_this.currentWalkthroughStep && !_this.currentWalkthroughStep['testing']) {
                _this.overWalkthroughiFrame = {
                    wId: _this.currentWalkthroughStep.walkthroughId,
                    sId: _this.currentWalkthroughStep.id
                };
            }
        })
            .on(this.windowSvc.namespaceEvent('mouseleave'), '.cz-click-audit .fr-video iframe', function () {
            _this.overAnnouncementiFrame = -1;
            _this.overWalkthroughiFrame = -1;
        });
        this.windowSvc.elementCache.window.on(this.windowSvc.namespaceEvent('blur'), function () {
            if (_this.overAnnouncementiFrame !== -1) {
                _this.messageClicked(_this.overAnnouncementiFrame);
            }
            // ! This is probably going away...not sure yet
            if (_this.overWalkthroughiFrame !== -1) {
                _this.walkthroughMessageClicked(_this.overWalkthroughiFrame);
            }
            if (_this.currentWalkthroughStep || _this.announcementVisible) {
                // Old school for loop to guard against IE 11
                var popupFrames = _this.popupContainer.querySelectorAll('iframe'), pLen = popupFrames.length;
                for (var i = 0; i < pLen; i++) {
                    var iframe = popupFrames[i];
                    iframe.contentWindow.postMessage('czCodeBlur', '*');
                }
                _this.sliderContainer.find('iframe').each(function (i, iframe) {
                    iframe.contentWindow.postMessage('czCodeBlur', '*');
                });
                _this.windowSvc.elementCache.body.find('.cz-walk-tooltip-container iframe').each(function (i, iframe) {
                    iframe.contentWindow.postMessage('czCodeBlur', '*');
                });
            }
        });
        this.windowSvc.window.addEventListener('resize', this.onWindowResizeForAnchors);
        //attempt to record that the current walkthrough was abandoned
        this.windowSvc.elementCache.window.on(this.windowSvc.namespaceEvent('beforeunload'), function () {
            if (_this.currentWalkthroughStep) {
                _this.endWalkthroughStep(false, 'Abandoned');
            }
            if (_this.currentWalkthrough) {
                _this.endWalkthrough(true);
            }
        });
    };
    Herald.prototype.onDigest = function () {
        if (!this.tenantSvc.FeatureEnabled(tenant_service_1.FeatureFlags.Walkthroughs)) {
            return;
        }
        this.CheckForWalkthroughAnchors();
    };
    Herald.prototype.onHalt = function () {
        console.log('Halting - Herald');
        clientlibs_1.PubSuber.removeAll(this.subIds);
        this.windowSvc.window.removeEventListener('message', this.boundClickAuditHandler);
        this.windowSvc.window.removeEventListener('resize', this.onWindowResizeForAnchors);
        this.CompletelyAbandonAnyCurrentWalkthrough();
        //remove all injected HTML
        this.windowSvc.elementCache.body.find('.cz-tooltip-container').remove();
        this.windowSvc.elementCache.body.find('#cz_transBG').remove();
        this.popoverDivLoaded = false;
        //remove any anchors
        this.clearAllAnchors();
    };
    /* Event Handlers */
    Herald.prototype.onStartWalkthrough = function (walkthrough, metaData) {
        var testFlag = walkthrough['testing'];
        //ignore disabled walkthroughs
        if (!testFlag && walkthrough.disabled) {
            return;
        }
        //dont show onetime walkthroughs more than once
        if (!testFlag && !walkthrough.recurrence && walkthrough.id && this.seenWalkthroughIds.indexOf(walkthrough.id) !== -1) {
            return;
        }
        //only allow one walkthrough at a time
        // ! Keep an eye on the addition of !testFlag here!
        if (!testFlag && this.currentWalkthrough) {
            this.appSvc.debug('[Devless Walkthrough Prevented (Another In Progress)]', walkthrough);
            return;
        }
        if (this.announcementVisible === true) {
            this.appSvc.debug('[Devless Walkthrough Prevented (In-App Announcement Visible)]', walkthrough);
            //this.walkthroughQueue.push(walkthrough);
            return;
        }
        //stash the current walkthrough
        this.currentWalkthrough = walkthrough;
        // Stash any WT css text for use further down the pipe
        // This is pretty hacky, but it avoids updating a bunch of method signatures to pass in the metaData and provide custom cssText
        if (metaData === null || metaData === void 0 ? void 0 : metaData.cssText) {
            this.currentWalkthroughCssText = metaData.cssText;
        }
        if (!testFlag && this.currentWalkthrough.id) {
            this.seenWalkthroughIds.push(this.currentWalkthrough.id);
        }
        this.appSvc.debug('[Devless Walkthrough Started]', this.currentWalkthrough);
        if (this.currentWalkthrough && !testFlag && this.currentWalkthrough.id) {
            this.walkthroughSvc.SendActionMessage(Enums_1.Enums.WalkthroughActionType.WalkthroughStarted, this.currentWalkthrough.id);
        }
        //if there are no steps then bail out
        if (!this.currentWalkthrough.steps || this.currentWalkthrough.steps.length === 0) {
            this.endWalkthrough(false);
            return;
        }
        var step = this.currentWalkthrough.steps[0];
        this.doWalkthroughStep(step);
    };
    Herald.prototype.ReplayAnnouncement = function (id, position) {
        // Use filter instead of find, because IE
        var filtered = this.messageSvc.Announcements.filter(function (a) { return a.id === id; });
        if (filtered.length === 0) {
            return;
        }
        // Clone here so we don't mutate the in-memory array
        var message = __assign(__assign({}, filtered[0]), { isReplay: true });
        if (position) {
            message.announcementPositionId = position;
        }
        if (message && this.messageSvc.isAdvancedDisplayAnnouncement(message)) {
            this.addAdvancedDisplayAnnouncement(message);
        }
    };
    Herald.prototype.TestAnnouncement = function (type, message, includeInPanel, config, styleConfig, sequence, metaData) {
        this.HideAnyAnnouncement();
        var baseMessage = {
            messageKey: -1 * this.windowSvc.Date.now(),
            isRead: false,
            deliveryDate: this.windowSvc.Date.now(),
            announcementIncludeInPanel: (includeInPanel === true),
            announcementIncludeInPanelString: (includeInPanel === true).toString(),
            id: -1,
            announcementPositionId: Enums_1.Enums.AnnouncementPosition.PopUp,
            messageContent: "" + (message || this.defaultTestMessageContent)
        };
        if (baseMessage.messageContent.charAt(0) !== '<') {
            baseMessage.messageContent = "<p>" + baseMessage.messageContent + "</p>";
        }
        if (message !== null && typeof message === 'object') {
            baseMessage['messageData'] = message;
            delete baseMessage.messageContent;
        }
        if (config) {
            config['testing'] = true;
        }
        switch (type) {
            case Enums_1.Enums.AnnouncementPosition.PopUp:
                if (config) {
                    this.showWalkthroughPopup(baseMessage.messageContent, config, undefined, styleConfig, sequence, metaData);
                }
                else {
                    this.createNewAnnouncement(baseMessage);
                }
                break;
            case Enums_1.Enums.AnnouncementPosition.SlideBottomRight:
            case Enums_1.Enums.AnnouncementPosition.SlideBottomCenter:
            case Enums_1.Enums.AnnouncementPosition.SlideBottomLeft:
            case Enums_1.Enums.AnnouncementPosition.SlideLeftBottom:
            case Enums_1.Enums.AnnouncementPosition.SlideLeftCenter:
            case Enums_1.Enums.AnnouncementPosition.SlideLeftTop:
            case Enums_1.Enums.AnnouncementPosition.SlideTopLeft:
            case Enums_1.Enums.AnnouncementPosition.SlideTopCenter:
            case Enums_1.Enums.AnnouncementPosition.SlideTopRight:
            case Enums_1.Enums.AnnouncementPosition.SlideRightTop:
            case Enums_1.Enums.AnnouncementPosition.SlideRightCenter:
            case Enums_1.Enums.AnnouncementPosition.SlideRightBottom:
                if (config) {
                    this.showWalkthroughSlider(baseMessage.messageContent, config, undefined, styleConfig, sequence, metaData);
                }
                else {
                    baseMessage.announcementPositionId = type;
                    this.createNewAnnouncement(baseMessage);
                }
                break;
            case Enums_1.Enums.AnnouncementPosition.PanelOnly:
                baseMessage.announcementIncludeInPanel = true;
                baseMessage.announcementIncludeInPanelString = 'true';
                baseMessage.announcementPositionId = Enums_1.Enums.AnnouncementPosition.PanelOnly;
                this.createNewAnnouncement(baseMessage);
                break;
            case Enums_1.Enums.AnnouncementPosition.Tooltip:
                this.showTooltip(message || this.defaultTestMessageContent, config, undefined, 1, styleConfig, sequence, metaData);
                break;
        }
    };
    Herald.prototype.UpdateAnnouncement = function (type, message, includeInPanel, config, styleConfig, sequence, metaData) {
        switch (type) {
            case Enums_1.Enums.AnnouncementPosition.PopUp:
                if (this.popupContainer) {
                    this.popupContainer.innerHTML = message;
                }
                break;
            case Enums_1.Enums.AnnouncementPosition.SlideBottomRight:
            case Enums_1.Enums.AnnouncementPosition.SlideBottomCenter:
            case Enums_1.Enums.AnnouncementPosition.SlideBottomLeft:
            case Enums_1.Enums.AnnouncementPosition.SlideLeftBottom:
            case Enums_1.Enums.AnnouncementPosition.SlideLeftCenter:
            case Enums_1.Enums.AnnouncementPosition.SlideLeftTop:
            case Enums_1.Enums.AnnouncementPosition.SlideTopLeft:
            case Enums_1.Enums.AnnouncementPosition.SlideTopCenter:
            case Enums_1.Enums.AnnouncementPosition.SlideTopRight:
            case Enums_1.Enums.AnnouncementPosition.SlideRightTop:
            case Enums_1.Enums.AnnouncementPosition.SlideRightCenter:
            case Enums_1.Enums.AnnouncementPosition.SlideRightBottom:
                this.closeSlider();
                this.showWalkthroughSlider(message || this.defaultTestMessageContent, config, undefined, styleConfig, sequence, metaData);
                break;
            case Enums_1.Enums.AnnouncementPosition.PanelOnly:
                // baseMessage.announcementIncludeInPanel = true;
                // baseMessage.announcementIncludeInPanelString = "true";
                // baseMessage.announcementPositionId = Enums.AnnouncementPosition.PanelOnly;
                // this.createNewAnnouncement(baseMessage);
                break;
            case Enums_1.Enums.AnnouncementPosition.Tooltip:
                this.closeTooltips(false, false);
                this.showTooltip(message || this.defaultTestMessageContent, config, undefined, undefined, styleConfig, sequence, metaData);
                break;
        }
    };
    //Hide any visible announcement
    Herald.prototype.HideAnyAnnouncement = function () {
        this.frameBuilder.removeWalkthroughStyleElements();
        this.closePopUpAnnouncement(false, false);
        this.closeSlider();
        this.closeTooltips(false, false);
    };
    Herald.prototype.TestWalkthrough = function (walkthrough, metaData) {
        walkthrough = clientlibs_1.Walkthrough.fromObject(walkthrough);
        walkthrough['testing'] = true;
        this.HideAnyAnnouncement();
        if (walkthrough.triggerType === clientlibs_1.WalkthroughTriggerType.Anchor) {
            var id = this.generateWalkthroughAnchorId(walkthrough), anchor = this.windowSvc.document.getElementById(id);
            if (anchor) {
                this.removeAnchorFrame(anchor);
            }
            this.setupWalkthroughAnchor(walkthrough, metaData);
        }
        else {
            this.onStartWalkthrough(walkthrough, metaData);
        }
    };
    Herald.prototype.TestClearAll = function () {
        this.HideAnyAnnouncement();
        if (this.currentWalkthrough && this.currentWalkthrough['testing']) {
            this.CompletelyAbandonAnyCurrentWalkthrough();
        }
        for (var i = 0; i < this.anchorFrames.length; i++) {
            if (this.anchorFrames[i]) {
                var _a = this.anchorFrames[i], anchorFrame = _a.anchorFrame, anchorFrameConfig = _a.anchorFrameConfig, target = _a.target;
                if (anchorFrameConfig['testing']) {
                    var parent = anchorFrame.parentElement;
                    parent.removeChild(anchorFrame);
                    this.anchorFrames[i] = null;
                }
            }
        }
        //remove nulls
        this.anchorFrames = this.anchorFrames.filter(function (f) { return f; });
    };
    Herald.prototype.removeAnchorFrame = function (anchor) {
        if (!anchor) {
            return;
        }
        var parent = anchor.parentElement;
        if (parent)
            parent.removeChild(anchor);
        this.anchorFrames = this.anchorFrames.filter(function (f) {
            if (!f)
                return false;
            return f.anchorFrame.getAttribute('id') !== anchor.getAttribute('id');
        });
    };
    Herald.prototype.CompletelyAbandonAnyCurrentWalkthrough = function () {
        this.HideAnyAnnouncement();
        if (this.currentWalkthroughStep) {
            this.endWalkthroughStep(false, 'Abandoned');
        }
        if (this.currentWalkthrough) {
            this.endWalkthrough(true);
        }
    };
    Herald.prototype.AnnouncementLinkClickHandler = function (e) {
        try {
            var auditContainer = this.windowSvc.czq(e.currentTarget).closest('.cz-click-audit');
            //if there is no audit container then bailout
            if (!auditContainer || auditContainer.length === 0) {
                return;
            }
            var messageId = auditContainer.attr('data-message-id');
            this.messageClicked(messageId);
        }
        catch (ex) {
            //report?
            errorLogger_1.default.report('Herald.auditClick', ex);
        }
    };
    Herald.prototype.CloseSliderClickHandler = function (e) {
        try {
            var target = this.windowSvc.czq(e.currentTarget);
            var announcementCont = target.closest('.cz-slide-announcement'); //announcementSliderTemplate.html
            var announcement = announcementCont.find('.cz-announcement'); //announcementTemplate.html || announcementNpsTemplate.html
            if (announcement.length === 0) {
                announcement = announcementCont.find('#cz_nps_frame');
            }
            var showMessageBubble = (announcement.attr('data-info-message') || 'true').toLowerCase() === 'true';
            var socketAnnouncement = this.messageSvc.GetAnnouncementFromAnnouncementHtml(announcement.get(0));
            this.closeSlider();
            if (showMessageBubble) {
                this.announceClosure(this.sessionSvc.CurrentAccountContent.clickToSeeMoreText, socketAnnouncement);
            }
            this.onAdvancedDisplayClose();
        }
        catch (ex) {
            //report?
            errorLogger_1.default.report('Herald.closeAnnouncementEvent', ex);
        }
    };
    Herald.prototype.ShowNPSClickHandler = function (e) {
        try {
            var target = e.currentTarget;
            var url = target.getAttribute('data-nps-url');
            var wide = (target.getAttribute('data-nps-wide') || '').toLowerCase() === 'true';
            var showNewWindow = (target.getAttribute('data-show-new-window') || '').toLowerCase() === 'true';
            var announcement = clientlibs_1.CoreUtils.closest(target, '.cz-announcement');
            var showMessageBubble = (announcement.getAttribute('data-info-message') || 'true').toLowerCase() === 'true';
            var socketAnnouncement = this.messageSvc.GetAnnouncementFromAnnouncementHtml(announcement);
            this.closeSlider();
            this.showSurveyPopup(url, showNewWindow, showMessageBubble, wide, socketAnnouncement);
        }
        catch (ex) {
            //report?
            errorLogger_1.default.report('Herald.ShowNPSClickHandler', ex);
        }
    };
    Herald.prototype.ShowNPSFrameCommHandler = function (data) {
        try {
            var url = data.url, wide = data.wide, showMessageBubble = data.showMessageBubble, showNewWindow = data.showNewWindow, id_1 = data.id;
            var socketAnnouncement_1;
            this.messageSvc.Announcements.filter(function (sa) {
                if (sa.id.toString() === id_1.toString()) {
                    socketAnnouncement_1 = sa;
                }
            });
            this.closeSlider();
            this.showSurveyPopup(url, showNewWindow, showMessageBubble, wide, socketAnnouncement_1);
            this.appSvc.debug('[Show NPS Popup]');
        }
        catch (ex) {
            errorLogger_1.default.report('Herald.ShowNPSFrameCommHandler', ex);
        }
    };
    /* Announcement & Popup Functionality */
    //Entry point for Announcements workflow
    Herald.prototype.createNewAnnouncement = function (message) {
        var addToUI = this.messageSvc.AddNewAnnouncement(message);
        if (addToUI) {
            //take special actions for other message types
            if (this.messageSvc.isAdvancedDisplayAnnouncement(message)) {
                this.addAdvancedDisplayAnnouncement(message);
            }
            //ChurnZeroAppEvents.NewAnnouncement
            this.appSvc.pubsub.publish(clientlibs_1.ChurnZeroAppEvents.NewAnnouncement, message);
        }
    };
    Herald.prototype.announceClosure = function (infoMessage, announcement) {
        this.appSvc.pubsub.publish(clientlibs_1.ChurnZeroAppEvents.AnnouncementClosed, { infoMessage: infoMessage, announcement: announcement });
    };
    //send click audit for messages
    Herald.prototype.messageClicked = function (id) {
        var theId = parseInt(id, 10);
        // id is bogus, bail
        if (isNaN(theId)) {
            return;
        }
        this.appSvc.debug("[Click Audit " + theId + "]");
        this.messageSvc.SendReadReceipt(theId);
        this.messageSvc.SendClickAudit(theId);
    };
    Herald.prototype.walkthroughMessageClicked = function (clickAuditData) {
        this.appSvc.debug('[Devless Walkthrough Click Audit]');
        //if there is no Id then bailout
        if (!clickAuditData) {
            return;
        }
        var action = Enums_1.Enums.WalkthroughActionType.StepClicked;
        this.walkthroughSvc.SendActionMessage(action, clickAuditData.wId, clickAuditData.sId);
    };
    Herald.prototype.expireAnnouncement = function (message) {
        this.messageSvc.ExpireAnnouncement(message);
        //this.adjustPanelFooter();
    };
    //validate that the non panel only announcements can be displayed right now
    Herald.prototype.validateAdvancedAnnouncementDisplay = function (announcement) {
        if (!announcement.announcementPositionId || announcement.announcementPositionId < Enums_1.Enums.AnnouncementPosition.PopUp) {
            console.log('No announcementPositionId or it is panel only');
            return false;
        }
        if (this.announcementVisible === true) {
            console.log('Another announcement has been shown');
            return false;
        }
        if (announcement.isReplay === true) {
            return true;
        }
        if (this.lastShownAnnouncementDate && (announcement.deliveryDate.getTime() < this.lastShownAnnouncementDate.getTime())) {
            console.log('Announcement is old');
            return false;
        }
        if (announcement.isRead === true) {
            console.log('Announcement has already been read');
            return false;
        }
        return true;
    };
    /**
     * Add Popup, Slider, or NPS to the UI
     * @param announcement
     */
    Herald.prototype.addAdvancedDisplayAnnouncement = function (announcement) {
        var isValid = this.validateAdvancedAnnouncementDisplay(announcement);
        if (!isValid) {
            return;
        }
        var announcementType = this.messageSvc.getAnnouncementType(announcement);
        switch (announcementType) {
            case clientlibs_1.AnnouncementType.Basic:
                if (announcement.announcementPositionId === Enums_1.Enums.AnnouncementPosition.PopUp) {
                    this.showInAppPopup(announcement);
                }
                else if (announcement.announcementPositionId > Enums_1.Enums.AnnouncementPosition.PopUp) {
                    this.showInAppSlider(announcement);
                }
                break;
            case clientlibs_1.AnnouncementType.Nps:
                this.messageSvc.normalizeMessageData(announcement);
                if (announcement.announcementPositionId === Enums_1.Enums.AnnouncementPosition.PopUp) {
                    this.showSurveyPopup(announcement.messageData.responseUrl, announcement.messageData.showNewWindow, announcement.showInfoMessageString, announcement.messageData.wide, announcement);
                }
                else if (announcement.announcementPositionId > Enums_1.Enums.AnnouncementPosition.PopUp) {
                    this.showStandardSurveySlider(announcement);
                }
                break;
            case clientlibs_1.AnnouncementType.CustomSurvey:
                this.messageSvc.normalizeMessageData(announcement);
                if (announcement.announcementPositionId > Enums_1.Enums.AnnouncementPosition.PopUp) {
                    this.showCustomSurveySlider(announcement);
                }
                break;
            default:
                return; //Unknown message type - ignore
        }
        this.lastShownAnnouncementDate = announcement.deliveryDate;
        this.messageSvc.SendReadReceipt(announcement.id);
    };
    /* Sliders */
    Herald.prototype.showInAppSlider = function (announcement) {
        var _this = this;
        var _a;
        var globalStyleConfig = this.sessionSvc.CurrentAccountContent.announcementStyles, announcementPositionClass = Herald.getAnnouncementPositionClassFromId(announcement.announcementPositionId);
        var sliderDiv = this.windowSvc.createElement('div');
        // Append each new class name one at a time, because IE
        sliderDiv.classList.add('cz-slide-announcement');
        sliderDiv.classList.add('cz-in-app-slider');
        sliderDiv.classList.add(announcementPositionClass);
        sliderDiv.style.setProperty('visibility', 'hidden', 'important');
        var width = globalStyleConfig === null || globalStyleConfig === void 0 ? void 0 : globalStyleConfig.sliderWidth, messageStyleConfig = ((_a = announcement.messageData) === null || _a === void 0 ? void 0 : _a.styleConfig) || {}, configuration = {
            content: announcement.messageContent,
            clickAuditData: announcement,
            styleConfig: __assign(__assign({}, globalStyleConfig), messageStyleConfig),
            width: width,
            type: Enums_1.Enums.AnnouncementElementType.Slider,
            position: announcement.announcementPositionId,
            onCloseCallback: function () {
                _this.closeWalkthroughSlider(false);
                if (announcement.announcementIncludeInPanel)
                    _this.announceClosure(_this.sessionSvc.CurrentAccountContent.clickToSeeMoreText, announcement);
            },
            onShownCallback: function () {
                sliderDiv.style.removeProperty('visibility');
            },
            onResizeCallback: null
        };
        // Determine slider width
        if (width) {
            sliderDiv.style.setProperty('width', width + "px", 'important');
        }
        var sliderContentFrame = this.frameBuilder.buildInAppContentFrame(configuration);
        sliderDiv.appendChild(sliderContentFrame);
        this.showSlider(sliderDiv);
    };
    Herald.prototype.showSurveySlider = function (announcement, messageHtml, onClickCallback) {
        var _this = this;
        var _a;
        var globalStyleConfig = this.sessionSvc.CurrentAccountContent.announcementStyles;
        var sliderDiv = this.windowSvc.createElement('div');
        // Append each new class name one at a time, because IE
        sliderDiv.classList.add('cz-slide-announcement');
        sliderDiv.classList.add('cz-in-app-slider');
        sliderDiv.classList.add('cz-nps-announcement');
        sliderDiv.style.setProperty('visibility', 'hidden', 'important');
        var width = 717, //globalStyleConfig?.sliderWidth,
        messageStyleConfig = ((_a = announcement.messageData) === null || _a === void 0 ? void 0 : _a.styleConfig) || {}, configuration = {
            content: messageHtml,
            clickAuditData: announcement,
            styleConfig: __assign(__assign({}, globalStyleConfig), messageStyleConfig),
            width: width,
            type: Enums_1.Enums.AnnouncementElementType.Slider,
            position: announcement.announcementPositionId,
            onCloseCallback: function () {
                _this.closeSlider();
                if (announcement.announcementIncludeInPanel)
                    _this.announceClosure(_this.sessionSvc.CurrentAccountContent.clickToSeeMoreText, announcement);
            },
            onLoadCallback: function (ctx) {
                var styleUrl = _this.appSvc.addCdn('css/csm_panel_styles.css'), link = ctx.document.createElement('link');
                //link.id = CZ_ANNOUNCEMENT_STYLES_ID;
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = styleUrl;
                var head = ctx.document.getElementsByTagName('head')[0];
                head.insertBefore(link, head.childNodes[0]);
            },
            onShownCallback: function () {
                sliderDiv.style.removeProperty('visibility');
            },
            onClickCallback: onClickCallback,
            onResizeCallback: null
        };
        var cssText = inline_styles_constants_1.SURVEY_CONTENT_CONTAINER_STYLES;
        if (configuration.styleConfig.fontFamily) {
            cssText += '.cz-announcement .cz-nps-container .questiontextcontainer .questiontext, .cz-announcement .cz-nps-container .labels table td.left, .cz-announcement .cz-nps-container .labels table td.right{';
            cssText += "font-family:" + this.tenantSvc.getUIFontFamilyMappingDisplayValue(configuration.styleConfig.fontFamily) + " !important;";
            cssText += '}';
        }
        configuration.customCss = cssText;
        var announcementPositionClass = Herald.getAnnouncementPositionClassFromId(announcement.announcementPositionId);
        sliderDiv.classList.add(announcementPositionClass);
        // Determine slider width
        if (width) {
            sliderDiv.style.setProperty('width', width + "px", 'important');
        }
        var sliderContentFrame = this.frameBuilder.buildInAppContentFrame(configuration);
        sliderDiv.appendChild(sliderContentFrame);
        this.showSlider(sliderDiv);
    };
    Herald.prototype.showCustomSurveySlider = function (socketAnnouncement) {
        var announcement = __assign(__assign({}, socketAnnouncement), { NpsUrl: socketAnnouncement.messageData.responseUrl, Content: this.appSvc.templater.populateTemplate(socketAnnouncement.messageData.content, { SurveyLink: this.surveyLinkHash }), wide: socketAnnouncement.messageData.wide, showNewWindow: socketAnnouncement.messageData.showNewWindow });
        var messageHtml = this.appSvc.templater.populateTemplate(this.templateCache.announcementSurveyCustomTemplate, announcement);
        this.showSurveySlider(announcement, messageHtml, this.onCustomSurveyClick);
    };
    Herald.prototype.showStandardSurveySlider = function (socketAnnouncement) {
        var announcement = __assign(__assign({}, socketAnnouncement), { NpsQuestion: socketAnnouncement.messageData.question, NpsUrl: socketAnnouncement.messageData.responseUrl, NpsLogoUrl: socketAnnouncement.messageData.logoUrl, NpsLogoStyle: socketAnnouncement.messageData.logoUrl ? '' : 'display: none', NpsLowScoreText: socketAnnouncement.messageData.lowScoreText || 'Not at all likely', NpsHighScoreText: socketAnnouncement.messageData.highScoreText || 'Extremely likely', AdditionalScoresClass: socketAnnouncement.messageData.wide ? 'scores-wide' : '', LabelsContainerClass: '', Buttons: this.generateSurveyButtons(socketAnnouncement.messageData) || this.generateDefaultNpsButtons(socketAnnouncement.messageData) });
        announcement.LabelsContainerClass = ((announcement.NpsLowScoreText || '').trim() || (announcement.NpsHighScoreText || '').trim()) ? '' : 'scores-labels-hidden';
        var messageHtml = this.appSvc.templater.populateTemplate(this.templateCache.announcementNpsTemplate, announcement);
        this.showSurveySlider(announcement, messageHtml, this.onStandardSurveyClick);
    };
    Herald.prototype.showWalkthroughSlider = function (content, config, clickAuditData, styleConfig, sequence, metaData) {
        var _this = this;
        var announcementPositionClass = Herald.getAnnouncementPositionClassFromId(config.position), container = this.windowSvc.createElement('div');
        container.classList.add(this.walkthroughSliderContainerClass);
        var sliderContentContainer = this.windowSvc.createElement('div');
        sliderContentContainer.classList.add(this.walkthroughSliderContentClass);
        metaData.onCloseCallback = function (wasCta) { return _this.closeWalkthroughSlider(wasCta); };
        var sliderDiv = this.windowSvc.createElement('div');
        sliderDiv.classList.add('cz-slide-announcement');
        sliderDiv.style.setProperty('background-color', 'transparent', 'important'); // override important style set in scss
        sliderDiv.classList.add(announcementPositionClass);
        sliderDiv.classList.add(this.walkthroughSliderClass);
        sliderDiv.style.setProperty('visibility', 'hidden', 'important');
        var frameConfig = {
            stepType: clientlibs_1.WalkthroughStepType.Slider,
            content: content,
            config: config,
            clickAuditData: clickAuditData,
            onShownCallback: function () {
                sliderDiv.style.removeProperty('visibility');
            },
            onResizeCallback: undefined,
            styleConfig: styleConfig,
            sequence: sequence,
            metaData: metaData
        };
        var sliderContentFrame = this.frameBuilder.buildWalkthroughContentFrame(frameConfig);
        sliderContentContainer.appendChild(sliderContentFrame);
        container.appendChild(sliderContentContainer);
        // Determine slider width
        if (styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.sliderWidth) {
            sliderDiv.style.setProperty('width', styleConfig.sliderWidth + "px", 'important');
        }
        sliderDiv.appendChild(container);
        this.showSlider(sliderDiv);
    };
    Herald.prototype.showSlider = function (messageHtml) {
        if (clientlibs_1.CoreUtils.isString(messageHtml)) {
            this.windowSvc.elementCache.body.append(messageHtml);
        }
        else {
            this.windowSvc.elementCache.body.get(0).appendChild(messageHtml);
        }
        this.announcementVisible = true;
    };
    //close the slider
    Herald.prototype.closeSlider = function () {
        this.sliderContainer.remove();
        this.announcementVisible = false;
    };
    Herald.prototype.closeWalkthroughSlider = function (wasInCta) {
        //ensure true/false value
        wasInCta = wasInCta === true;
        this.closeSlider();
        if (typeof this.currentWalkthroughStep === 'undefined') {
            this.appSvc.pubsub.publish(clientlibs_1.DevlessEvents.WalkthroughStepPreviewClose);
            return;
        }
        this.endWalkthroughStep(wasInCta, wasInCta ? 'CTA Clicked' : 'Close Handle Clicked');
    };
    /* Pop Ups */
    Herald.prototype.showInAppPopup = function (announcement) {
        var _this = this;
        var _a;
        var globalStyleConfig = this.sessionSvc.CurrentAccountContent.announcementStyles;
        // Get a custom width, if applicable
        var width = globalStyleConfig === null || globalStyleConfig === void 0 ? void 0 : globalStyleConfig.popupWidth, messageStyleConfig = ((_a = announcement.messageData) === null || _a === void 0 ? void 0 : _a.styleConfig) || {}, configuration = {
            content: announcement.messageContent,
            clickAuditData: announcement,
            styleConfig: __assign(__assign({}, globalStyleConfig), messageStyleConfig),
            width: width,
            type: Enums_1.Enums.AnnouncementElementType.Popup,
            onCloseCallback: function () {
                _this.closePopUpAnnouncement(false, false);
                if (announcement.announcementIncludeInPanel)
                    _this.announceClosure(_this.sessionSvc.CurrentAccountContent.clickToSeeMoreText, announcement);
            },
            onShownCallback: function () {
                var _a, _b;
                (_b = (_a = _this.popupBackground) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.add(_this.czInClassName);
            },
            onResizeCallback: null,
            position: undefined
        };
        var popupContentFrame = this.frameBuilder.buildInAppContentFrame(configuration);
        popupContentFrame.style.width = '100%'; //set content frame to 100% so content will resize for different width popups
        // Invoke shared "show pop up" method
        var theWidth = (width) ? width + "px" : undefined;
        this.showPopUpAnnouncement(popupContentFrame, theWidth);
        if (this.popupDiv) {
            this.popupDiv.classList.add(this.inAppPopupClass);
        }
    };
    /**
     * Show a survey in an iframe or new window
     * @param url - string to load as the src of the iframe/new window
     * @param showNewWindow - if true, show in new window; otherwise show in iframe
     * @param infoMessageString - whether to display "Click here to show again..." message after close
     * @param wide - whether to show in a wider iframe. Only used for iframes
     */
    Herald.prototype.showSurveyPopup = function (url, showNewWindow, showInfoMessage, wide, socketAnnouncement) {
        var _this = this;
        var showMessageBubble = ((showInfoMessage === null || showInfoMessage === undefined) ? 'true' : showInfoMessage).toString().toLowerCase() === 'true';
        if (showNewWindow) {
            var newWindow = this.windowSvc.openWindow(this.windowSvc.clientSideUrls.baseApiUrl + url);
            newWindow.onunload = function () {
                if (showMessageBubble) {
                    _this.announceClosure(_this.sessionSvc.CurrentAccountContent.clickToSeeMoreText, socketAnnouncement);
                }
            };
            return;
        }
        var surveyFrame = this.frameBuilder.buildSurveyContentFrame(url, showInfoMessage.toString());
        var globalStyleConfig = this.sessionSvc.CurrentAccountContent.announcementStyles;
        var width = 717, //globalStyleConfig?.sliderWidth,
        messageStyleConfig = {}, configuration = {
            content: surveyFrame,
            //clickAuditData: announcement,
            styleConfig: __assign(__assign({}, globalStyleConfig), messageStyleConfig),
            width: width,
            type: Enums_1.Enums.AnnouncementElementType.Popup,
            onCloseCallback: function () {
                _this.closePopUpAnnouncement(false, false);
                if (showMessageBubble) {
                    _this.announceClosure(_this.sessionSvc.CurrentAccountContent.clickToSeeMoreText, socketAnnouncement);
                }
            },
            onLoadCallback: function (ctx) {
                var frame = ctx.document.querySelector('#cz_nps_frame'), setFrameHeight = function () {
                    /*let popOver = document.getElementById("cz_popover"),
                        ph = popOver.clientHeight - 40;*/
                    var ch = parseInt(frame.getAttribute('data-content-size')), mx = ((window.innerHeight
                        || document.documentElement.clientHeight
                        || document.body.clientHeight) * 0.75) - 45;
                    var heightValueToUse = ch + 1;
                    //if the content height is greater than the max height
                    // use the max height
                    if (ch > mx) {
                        heightValueToUse = mx;
                    }
                    frame.style.height = heightValueToUse + 'px';
                };
                if (!clientlibs_1.CoreUtils.isNullOrUndefined(frame)) {
                    ctx.addEventListener('message', function (e) {
                        try {
                            if (clientlibs_1.CoreUtils.hasOwnProp(e, 'data') || !e.data.height) {
                                return;
                            }
                            var fh = parseInt(e.data.height); // - 24;
                            frame.setAttribute('data-content-size', fh.toString());
                            setFrameHeight();
                        }
                        catch (ex) {
                            //report?
                            errorLogger_1.default.report('Herald.npsResizeMessage', ex);
                        }
                    });
                    ctx.addEventListener('resize', function () {
                        try {
                            setFrameHeight();
                        }
                        catch (ex) {
                            //report?
                            errorLogger_1.default.report('Herald.npsResizePopUpEvent', ex);
                        }
                    });
                }
            },
            onShownCallback: function () {
                var _a, _b;
                (_b = (_a = _this.popupBackground) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.add(_this.czInClassName);
            },
            onClickCallback: function (e) {
            },
            onResizeCallback: null
        };
        var cssText = inline_styles_constants_1.SURVEY_CONTENT_CONTAINER_STYLES;
        if (configuration.styleConfig.fontFamily) {
            cssText += '.cz-announcement .cz-nps-container .questiontextcontainer .questiontext, .cz-announcement .cz-nps-container .labels table td.left, .cz-announcement .cz-nps-container .labels table td.right{';
            cssText += "font-family:" + this.tenantSvc.getUIFontFamilyMappingDisplayValue(configuration.styleConfig.fontFamily) + " !important;";
            cssText += '}';
        }
        configuration.customCss = cssText;
        var popupContentFrame = this.frameBuilder.buildInAppContentFrame(configuration);
        popupContentFrame.style.width = '100%';
        this.showPopUpAnnouncement(popupContentFrame, wide ? '800px' : '640px');
        if (this.popupDiv) {
            this.popupDiv.classList.add(this.inAppPopupClass);
            //Add NPS class
            this.popupDiv.classList.add('nps');
        }
    };
    //a special case popup that has call to action buttons
    Herald.prototype.showWalkthroughPopup = function (content, config, clickAuditData, styleConfig, sequence, metaData) {
        var _this = this;
        //build the popup content container
        var container = this.windowSvc.createElement('div');
        container.classList.add(this.walkthroughPopupClass);
        var popupContentContainer = this.windowSvc.createElement('div');
        popupContentContainer.classList.add(this.walkthroughPopupContentClass);
        metaData.onCloseCallback = function (wasCta) { return _this.closePopUpAnnouncement(true, wasCta); };
        var frameConfig = {
            stepType: clientlibs_1.WalkthroughStepType.PopUp,
            content: content,
            config: config,
            clickAuditData: clickAuditData,
            onResizeCallback: undefined,
            onShownCallback: function () {
                var _a, _b;
                (_b = (_a = _this.popupBackground) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.add(_this.czInClassName);
            },
            styleConfig: styleConfig,
            sequence: sequence,
            metaData: metaData
        };
        var popupContentFrame = this.frameBuilder.buildWalkthroughContentFrame(frameConfig);
        popupContentFrame.style.width = '100%'; //set content frame to 100% so content will resize for different width popups
        popupContentContainer.appendChild(popupContentFrame);
        container.appendChild(popupContentContainer);
        // Invoke shared "show pop up" method
        // Take custom widths into consideration, if applicable
        var width = (styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.popupWidth) ? styleConfig.popupWidth + "px" : config.width;
        this.showPopUpAnnouncement(container, width);
        //Add walk class
        this.popupDiv.classList.add('walk');
        // Popup overrides for the main window
        if (!this.windowSvc.document.getElementById(FrameBuilder_1.FRAME_BUILDER_STYLE_ELEMENT_ID_MAPPING.styleOverrides)) {
            var styleOverrides = this.windowSvc.createElement('style');
            styleOverrides.id = FrameBuilder_1.FRAME_BUILDER_STYLE_ELEMENT_ID_MAPPING.styleOverrides;
            styleOverrides.setAttribute('type', 'text/css');
            styleOverrides.innerHTML = '.cz-popover{background-color:transparent!important;}';
            this.windowSvc.document.getElementsByTagName('head')[0].appendChild(styleOverrides);
        }
    };
    //an announcement that pops up in the center of the screen with a modal background
    Herald.prototype.showPopUpAnnouncement = function (content, popupWidth) {
        // SHOW THE BG
        // ! OLD Trans Background logic. Should no longer be needed. Keeping here for reference
        // const transBg = this.windowSvc.document.getElementById('cz_transBG');
        // transBg.classList.remove('hidden');
        // transBg.style.display = 'flex';
        // Load the content
        if (this.popupContainer) {
            if (clientlibs_1.CoreUtils.isString(content)) {
                this.popupContainer.innerHTML = content;
            }
            else {
                this.popupContainer.appendChild(content);
            }
            this.popupContainer.classList.remove('nps');
        }
        if (typeof popupWidth === 'undefined') {
            popupWidth = '340px';
        }
        // SHOW THE DIV
        if (!this.popupDiv) {
            this.addPopOverDiv();
        }
        this.popupDiv.style.width = popupWidth;
        this.popupDiv.classList.remove('walk', this.inAppPopupClass);
        //reset any styles
        this.clearStyles(this.popupDiv, ['border-radius', 'background-color']);
        //make close image visible
        this.windowSvc.czq('#cz_popover .cz-popover-close img').attr('style', '');
        // Replace 'hidden' class with 'shown'. Cannot use replace method because IE
        this.popupDiv.classList.remove('hidden');
        this.popupDiv.classList.add('shown');
        this.announcementVisible = true;
    };
    //close the modal
    Herald.prototype.closePopUpAnnouncement = function (wasFromWalkthrough, wasInCTA) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        // Hide the transparent bg
        (_b = (_a = this.popupBackground) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.remove(this.czInClassName);
        // Hide the popup div and remove any style classes
        (_d = (_c = this.popupDiv) === null || _c === void 0 ? void 0 : _c.classList) === null || _d === void 0 ? void 0 : _d.remove('shown');
        (_f = (_e = this.popupDiv) === null || _e === void 0 ? void 0 : _e.classList) === null || _f === void 0 ? void 0 : _f.remove('walk');
        (_h = (_g = this.popupDiv) === null || _g === void 0 ? void 0 : _g.classList) === null || _h === void 0 ? void 0 : _h.remove('nps');
        (_k = (_j = this.popupDiv) === null || _j === void 0 ? void 0 : _j.classList) === null || _k === void 0 ? void 0 : _k.remove(this.inAppPopupClass);
        //reset any inline styles from the popup div
        this.clearStyles(this.popupDiv, ['border-radius', 'background-color']);
        //empty the content
        var contentContainer = this.popupContainer;
        if (contentContainer) {
            contentContainer.innerHTML = '';
        }
        this.windowSvc.elementCache.window.off(this.windowSvc.namespaceEvent('resize.popup'));
        this.announcementVisible = false;
        if (!wasFromWalkthrough) {
            return;
        }
        // BEGIN: Walkthrough-only logic
        if (typeof this.currentWalkthroughStep === 'undefined') {
            this.appSvc.pubsub.publish(clientlibs_1.DevlessEvents.WalkthroughStepPreviewClose);
            return;
        }
        this.endWalkthroughStep(wasInCTA, wasInCTA ? 'CTA Clicked' : 'Close Handle Clicked');
    };
    /* Tooltips */
    Herald.prototype.showTooltip = function (content, iconfig, clickAuditData, retryNumber, styleConfig, sequence, metaData) {
        var _this = this;
        var target = this.windowSvc.findElement(iconfig.selector);
        var ttConfig = clientlibs_1.CoreUtils.clone(iconfig);
        if (!target || target.length === 0) {
            this.closeTooltips(false, false);
            if (retryNumber === undefined || retryNumber === null) {
                retryNumber = 1;
            }
            if (retryNumber <= 10) {
                this.appSvc.debug('[Devless Walkthrough Step Target Not Found. Attempt ' + retryNumber + '/10]');
                setTimeout(function () {
                    _this.showTooltip(content, iconfig, clickAuditData, ++retryNumber, styleConfig, sequence, metaData);
                }, 250);
                return;
            }
            this.endWalkthroughStep(false, 'Target Not Found');
            return;
        }
        target.each(function (i, t) {
            //build the tooltip container
            var container = _this.windowSvc.createElement('div');
            ttConfig.wasScrolled = false;
            container.classList.add(_this.tooltipClass);
            container.classList.add('cz-click-audit');
            container.style.setProperty('visibility', 'hidden', 'important');
            var tooltipContentContainer = _this.windowSvc.createElement('div'), calcFunc = function () {
                _this.calcTooltipPosition(ttConfig, t, container, i === 0, styleConfig);
            };
            tooltipContentContainer.classList.add(_this.tooltipContentClass);
            metaData.onCloseCallback = function (wasCta) { return _this.closeTooltips(true, wasCta); };
            var frameConfig = {
                stepType: clientlibs_1.WalkthroughStepType.Tooltip,
                content: content,
                config: iconfig,
                clickAuditData: clickAuditData,
                onResizeCallback: calcFunc,
                onShownCallback: function () {
                    var _a, _b;
                    container.style.removeProperty('visibility');
                    (_b = (_a = container.querySelector("." + _this.tooltipTriangleClass)) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.add(_this.czInClassName);
                },
                styleConfig: styleConfig,
                sequence: sequence,
                metaData: metaData
            };
            var tooltipContentFrame = _this.frameBuilder.buildWalkthroughContentFrame(frameConfig);
            tooltipContentContainer.appendChild(tooltipContentFrame);
            // Determine tooltip width
            if (styleConfig === null || styleConfig === void 0 ? void 0 : styleConfig.tooltipWidth) {
                tooltipContentContainer.style.setProperty('width', styleConfig.tooltipWidth + "px", 'important');
            }
            container.appendChild(tooltipContentContainer);
            //set off screen so we can get the sizing
            container.style.setProperty('position', 'fixed', 'important');
            container.style.opacity = '0';
            container.style.top = '0';
            container.style.left = '0';
            var body = (ttConfig.container === clientlibs_1.ContainerType.Parent) ?
                t.parentElement :
                _this.windowSvc.elementCache.body.get(0);
            body.appendChild(container);
            calcFunc();
        });
    };
    /****
     * Sets CSS properties in cssPropsArray to ''.
     *
     * @param el - HTML element to clear style properties from
     * @param cssPropsArray - array of CSS properties to clear.
     * @private
     * @return void
     */
    Herald.prototype.clearStyles = function (el, cssPropsArray) {
        if (!el) {
            return;
        }
        for (var i = 0; i < cssPropsArray.length; i++) {
            el.style.removeProperty(cssPropsArray[i]);
        }
    };
    Herald.prototype.calcTooltipPosition = function (config, t, frame, scrollToView, styleConfig) {
        var _a = styleConfig || {}, borderWidth = _a.borderWidth, borderColor = _a.borderColor, backgroundColor = _a.backgroundColor, ctaBackgroundColor = _a.ctaBackgroundColor, hasBorder = ((borderWidth || 0) > 0 && typeof borderColor === 'string'), bgColor = (hasBorder) ? borderColor : backgroundColor || config.backgroundColor, ctaBgColor = ctaBackgroundColor || config.ctaBackgroundColor;
        //calculate the position
        var offset = 25;
        var targetPos = t.getBoundingClientRect(), tooltipPos = frame.getBoundingClientRect(), tooltipContentContainer = frame.querySelector('.' + this.tooltipContentClass), cPos = tooltipContentContainer.getBoundingClientRect();
        var top;
        var left;
        switch (config.container) {
            case clientlibs_1.ContainerType.Parent:
                top = t.offsetTop;
                left = t.offsetLeft;
                break;
            case clientlibs_1.ContainerType.Body:
            default:
                top = targetPos.top + this.windowSvc.elementCache.window.scrollTop();
                left = targetPos.left + this.windowSvc.elementCache.window.scrollLeft();
                break;
        }
        function calcTopLeft(position) {
            var newTop, newLeft;
            switch (position) {
                case clientlibs_1.TooltipPosition.Top:
                    //should be above target, horizontally centered
                    newTop = top - (offset + tooltipPos.height);
                    newLeft = ((left + (targetPos.width / 2)) - (tooltipPos.width / 2));
                    break;
                case clientlibs_1.TooltipPosition.Bottom:
                    //should be below target, horizontally centered
                    newTop = top + (offset + targetPos.height);
                    newLeft = ((left + (targetPos.width / 2)) - (tooltipPos.width / 2));
                    break;
                case clientlibs_1.TooltipPosition.Left:
                    //should be left of target, vertically centered
                    newLeft = left - (tooltipPos.width + offset);
                    newTop = ((top + (targetPos.height / 2)) - (cPos.height / 2));
                    break;
                case clientlibs_1.TooltipPosition.Right:
                default:
                    //should be right of target, vertically centered
                    newLeft = left + (targetPos.width + offset);
                    newTop = ((top + (targetPos.height / 2)) - (cPos.height / 2));
                    break;
            }
            return { top: newTop, left: newLeft };
        }
        var tl = calcTopLeft(config.position);
        var minLeft = 10;
        var maxLeft = document.documentElement.scrollWidth - (tooltipPos.width + offset);
        var minTop = 10;
        var maxTop = document.documentElement.scrollHeight - (tooltipPos.height + offset);
        var positionForArrow = config.position;
        //is Left but off screen
        if (tl.left < minLeft && config.position === clientlibs_1.TooltipPosition.Left) {
            //try right
            positionForArrow = clientlibs_1.TooltipPosition.Right;
            tl.left = calcTopLeft(positionForArrow).left;
            if (tl.left > maxLeft) {
                //try top
                positionForArrow = clientlibs_1.TooltipPosition.Top;
                tl = calcTopLeft(positionForArrow);
                if (tl.top < minTop) {
                    //try bottom
                    positionForArrow = clientlibs_1.TooltipPosition.Bottom;
                    tl = calcTopLeft(positionForArrow);
                }
            }
        }
        //is Right but off screen
        if (tl.left > maxLeft && config.position === clientlibs_1.TooltipPosition.Right) {
            //try left
            positionForArrow = clientlibs_1.TooltipPosition.Left;
            tl.left = calcTopLeft(positionForArrow).left;
            if (tl.left < minLeft) {
                //try top
                positionForArrow = clientlibs_1.TooltipPosition.Top;
                tl = calcTopLeft(positionForArrow);
                if (tl.top < minTop) {
                    //try bottom
                    positionForArrow = clientlibs_1.TooltipPosition.Bottom;
                    tl = calcTopLeft(positionForArrow);
                }
            }
        }
        if (config.container === clientlibs_1.ContainerType.Body && (config.position === clientlibs_1.TooltipPosition.Right || config.position === clientlibs_1.TooltipPosition.Left)) {
            if (tl.top > maxTop) {
                tl.top = maxTop;
            }
            if (tl.top < minTop) {
                tl.top = 10;
            }
        }
        //is Top but off screen
        if (tl.top < minTop && config.position === clientlibs_1.TooltipPosition.Top) {
            //try bottom
            positionForArrow = clientlibs_1.TooltipPosition.Bottom;
            tl.top = calcTopLeft(positionForArrow).top;
            if (tl.top > maxTop) {
                //try left
                positionForArrow = clientlibs_1.TooltipPosition.Left;
                tl = calcTopLeft(positionForArrow);
                if (tl.left > maxLeft) {
                    //try right
                    positionForArrow = clientlibs_1.TooltipPosition.Right;
                    tl = calcTopLeft(positionForArrow);
                }
            }
        }
        //is Bottom but off screen
        if (tl.top > maxTop && config.position === clientlibs_1.TooltipPosition.Bottom) {
            //try top
            positionForArrow = clientlibs_1.TooltipPosition.Bottom;
            tl.top = calcTopLeft(positionForArrow).top;
            if (tl.top < minTop) {
                //try left
                positionForArrow = clientlibs_1.TooltipPosition.Left;
                tl = calcTopLeft(positionForArrow);
                if (tl.left > maxLeft) {
                    //try right
                    positionForArrow = clientlibs_1.TooltipPosition.Right;
                    tl = calcTopLeft(positionForArrow);
                }
            }
        }
        if (config.container === clientlibs_1.ContainerType.Body && (config.position === clientlibs_1.TooltipPosition.Top || config.position === clientlibs_1.TooltipPosition.Bottom)) {
            if (tl.left > maxLeft) {
                tl.left = maxLeft;
            }
            if (tl.left < minLeft) {
                tl.left = minLeft;
            }
        }
        frame.style.setProperty('position', 'absolute', 'important');
        frame.style.opacity = '1';
        frame.style.top = tl.top + 'px';
        frame.style.left = tl.left + 'px';
        //add the triangle
        var triangleWidth = 15;
        var triangleBorderColorString = 'rgba(0,0,0,0.25)';
        var innerTriangleWidth = (triangleWidth - 1);
        //(targetTop) - (contentTop) + (targetHeight/2) - triangleWidth
        var triangleTop = targetPos.top - cPos.top + (targetPos.height / 2) - triangleWidth; // ((cPos.height + 5) / 2) - triangleWidth;
        var triangleLeft = ((cPos.width) / 2) - (triangleWidth);
        var triangle = frame.querySelector("." + this.tooltipTriangleClass);
        var innerTriangle = frame.querySelector("." + this.tooltipTriangleInnerClass);
        if (!triangle) {
            triangle = this.windowSvc.createElement('div');
            triangle.classList.add(this.tooltipTriangleClass);
            triangle.style.setProperty('border-width', triangleWidth + 'px', 'important');
            innerTriangle = this.windowSvc.createElement('div');
            innerTriangle.classList.add(this.tooltipTriangleInnerClass);
            innerTriangle.style.setProperty('border-width', (innerTriangleWidth) + 'px', 'important');
            triangle.appendChild(innerTriangle);
            frame.appendChild(triangle);
        }
        var tOffset = triangleWidth * -2;
        switch (positionForArrow) {
            case clientlibs_1.TooltipPosition.Top:
                {
                    this.clearStyles(triangle, ['top', 'right', 'border-bottom-color']);
                    triangle.style.setProperty('border-top-color', triangleBorderColorString, 'important');
                    triangle.style.setProperty('bottom', tOffset + "px", 'important');
                    triangle.style.setProperty('left', triangleLeft + 'px', 'important');
                    var colorToUse = (hasBorder) ? bgColor : ctaBgColor;
                    this.clearStyles(innerTriangle, ['top', 'right', 'border-bottom-color']);
                    innerTriangle.style.setProperty('border-top-color', colorToUse, 'important');
                    innerTriangle.style.setProperty('bottom', (innerTriangleWidth - 1) * -1 + 'px', 'important');
                    innerTriangle.style.setProperty('left', innerTriangleWidth * -1 + 'px', 'important');
                }
                break;
            case clientlibs_1.TooltipPosition.Right:
                this.clearStyles(triangle, ['bottom', 'right', 'border-left-color']);
                triangle.style.setProperty('border-right-color', triangleBorderColorString, 'important');
                triangle.style.setProperty('left', tOffset + "px", 'important');
                triangle.style.setProperty('top', triangleTop + 'px', 'important');
                this.clearStyles(innerTriangle, ['bottom', 'right', 'border-left-color']);
                innerTriangle.style.setProperty('border-right-color', bgColor, 'important');
                innerTriangle.style.setProperty('left', (innerTriangleWidth - 1) * -1 + 'px', 'important');
                innerTriangle.style.setProperty('top', innerTriangleWidth * -1 + 'px', 'important');
                break;
            case clientlibs_1.TooltipPosition.Bottom:
                this.clearStyles(triangle, ['bottom', 'right', 'border-top-color']);
                triangle.style.setProperty('border-bottom-color', triangleBorderColorString, 'important');
                triangle.style.setProperty('top', tOffset + "px", 'important');
                triangle.style.setProperty('left', triangleLeft + 'px', 'important');
                this.clearStyles(innerTriangle, ['bottom', 'right', 'border-top-color']);
                innerTriangle.style.setProperty('border-bottom-color', bgColor, 'important');
                innerTriangle.style.setProperty('top', (innerTriangleWidth - 1) * -1 + 'px', 'important');
                innerTriangle.style.setProperty('left', innerTriangleWidth * -1 + 'px', 'important');
                break;
            case clientlibs_1.TooltipPosition.Left:
                this.clearStyles(triangle, ['bottom', 'left', 'border-right-color']);
                triangle.style.setProperty('border-left-color', triangleBorderColorString, 'important');
                triangle.style.setProperty('right', tOffset + "px", 'important');
                triangle.style.setProperty('top', triangleTop + 'px', 'important');
                this.clearStyles(innerTriangle, ['bottom', 'left', 'border-right-color']);
                innerTriangle.style.setProperty('border-left-color', bgColor, 'important');
                innerTriangle.style.setProperty('right', (innerTriangleWidth - 1) * -1 + 'px', 'important');
                innerTriangle.style.setProperty('top', innerTriangleWidth * -1 + 'px', 'important');
                break;
        }
        if (scrollToView && !config.wasScrolled && !clientlibs_1.StyleUtils.isInViewport(frame)) {
            //t.scrollIntoView();
            frame.scrollIntoView();
            config.wasScrolled = true;
        }
    };
    //close any open tooltips
    Herald.prototype.closeTooltips = function (wasFromWalkthrough, wasInCTA) {
        this.windowSvc.elementCache.body.find("." + this.tooltipClass).remove();
        if (!wasFromWalkthrough) {
            return;
        }
        // BEGIN: Walkthrough-only logic
        if (typeof this.currentWalkthroughStep === 'undefined') {
            this.appSvc.pubsub.publish(clientlibs_1.DevlessEvents.WalkthroughStepPreviewClose);
            return;
        }
        this.endWalkthroughStep(wasInCTA, wasInCTA ? 'CTA Clicked' : 'Close Handle Clicked');
    };
    /* Walkthroughs */
    Herald.prototype.doWalkthroughStep = function (step) {
        this.appSvc.debug("[Devless Walkthrough Starting Step " + step.sequence + "]", step);
        this.currentWalkthroughStep = step;
        var clickAuditData = {
            wId: step.walkthroughId,
            sId: step.id
        };
        if (this.currentWalkthrough && !this.currentWalkthrough['testing'] && this.currentWalkthrough.id && this.currentWalkthroughStep.id) {
            var action = Enums_1.Enums.WalkthroughActionType.StepStarted;
            this.walkthroughSvc.SendActionMessage(action, this.currentWalkthrough.id, this.currentWalkthroughStep.id);
        }
        var styleConfig = step.styleConfig, sequence = step.sequence;
        var wtMetaData = (this.currentWalkthrough) ? { totalSteps: this.currentWalkthrough.steps.length } : {};
        if (this.currentWalkthroughCssText) {
            wtMetaData.cssText = this.currentWalkthroughCssText;
        }
        switch (step.stepTypeId) {
            case clientlibs_1.WalkthroughStepType.PopUp:
                this.showWalkthroughPopup(step.content || '', step.stepConfig, clickAuditData, styleConfig, sequence, wtMetaData);
                break;
            case clientlibs_1.WalkthroughStepType.Slider:
                this.showWalkthroughSlider(step.content || '', step.stepConfig, clickAuditData, styleConfig, sequence, wtMetaData);
                break;
            case clientlibs_1.WalkthroughStepType.Tooltip:
                this.showTooltip(step.content || '', step.stepConfig, clickAuditData, undefined, styleConfig, sequence, wtMetaData);
                break;
        }
    };
    Herald.prototype.endWalkthroughStep = function (tryNext, reason) {
        if (tryNext === void 0) { tryNext = true; }
        reason = reason ? " : " + reason : '';
        this.appSvc.debug("[Devless Walkthrough Ended Step " + this.currentWalkthroughStep.sequence + "]" + reason, this.currentWalkthroughStep);
        if (this.currentWalkthrough && !this.currentWalkthrough['testing'] && this.currentWalkthrough.id && this.currentWalkthroughStep.id) {
            var action = tryNext ? Enums_1.Enums.WalkthroughActionType.StepCompleted : Enums_1.Enums.WalkthroughActionType.StepAbandonded;
            this.walkthroughSvc.SendActionMessage(action, this.currentWalkthrough.id, this.currentWalkthroughStep.id);
        }
        //check if we should try next step in walkthrough
        var nextSequence = this.currentWalkthroughStep.sequence + 1;
        var hasNext = nextSequence < (this.currentWalkthrough.steps.length);
        //clear out the current step
        this.currentWalkthroughStep = undefined;
        if (hasNext && tryNext) {
            this.doWalkthroughStep(this.currentWalkthrough.steps[nextSequence]);
        }
        else {
            this.endWalkthrough(!tryNext);
        }
    };
    Herald.prototype.endWalkthrough = function (wasAbandoned) {
        if (wasAbandoned === void 0) { wasAbandoned = false; }
        this.appSvc.debug("[Devless Walkthrough " + (wasAbandoned ? 'Abandoned' : 'Completed') + "]", this.currentWalkthrough);
        if (this.currentWalkthrough && !this.currentWalkthrough['testing'] && this.currentWalkthrough.id) {
            var action = wasAbandoned ? Enums_1.Enums.WalkthroughActionType.WalkthroughAbandoned : Enums_1.Enums.WalkthroughActionType.WalkthroughCompleted;
            this.walkthroughSvc.SendActionMessage(action, this.currentWalkthrough.id);
        }
        //clear out the current walkthrough
        this.currentWalkthrough = undefined;
        this.currentWalkthroughCssText = undefined;
        // Remove any <style> elements that may be appended to the document head
        this.frameBuilder.removeWalkthroughStyleElements();
    };
    /* Shared Announcement/Walkthrough Functionality */
    Herald.prototype.onAdvancedDisplayClose = function () {
        //check for any walkthroughs that might have queued up
        //if(this.walkthroughQueue && this.walkthroughQueue.length){
        //let walkthroughToStart = this.walkthroughQueue.shift();
        //start walkthrough
        //this.appSvc.pubsub.publish(Enums.ChurnZeroAppEvents.WalkthroughStart, walkthroughToStart);
        //}
    };
    /* Start Up Utils */
    //inject the container for pop over style announcements
    Herald.prototype.addPopOverDiv = function () {
        this.popoverDivLoaded = this.popoverDivLoaded || !clientlibs_1.CoreUtils.isNullOrUndefined(this.popupDiv);
        if (this.popoverDivLoaded)
            return;
        var body = this.windowSvc.getBodyElement();
        var document = this.windowSvc.getDocument();
        var popoverHtmlString = this.appSvc.templater.populateTemplate(this.templateCache.popoverContainerTemplate, {});
        body.appendChild(clientlibs_1.CoreUtils.createElementFromHTML(document, popoverHtmlString));
        this.popoverDivLoaded = true;
    };
    Herald.prototype.checkForLastAdvancedDisplayAnnouncement = function () {
        var slideAnnouncement = null;
        for (var i = this.messageSvc.Announcements.length - 1; i >= 0; i--) {
            var current = this.messageSvc.Announcements[i];
            //keep track of only the last slide or popup announcement
            if (this.messageSvc.isAdvancedDisplayAnnouncement(current)) {
                slideAnnouncement = null;
                if (current.isRead === false) {
                    slideAnnouncement = current;
                }
            }
        }
        //display only the last slide announcement
        if (slideAnnouncement) {
            this.addAdvancedDisplayAnnouncement(slideAnnouncement);
        }
    };
    /* Position Utils */
    Herald.getAnnouncementPositionClassFromId = function (announcementPositionId) {
        switch (announcementPositionId) {
            case Enums_1.Enums.AnnouncementPosition.SlideBottomCenter:
                return 'bottom-center';
            case Enums_1.Enums.AnnouncementPosition.SlideLeftBottom:
                return 'left-bottom';
            case Enums_1.Enums.AnnouncementPosition.SlideTopLeft:
                return 'top-left';
            case Enums_1.Enums.AnnouncementPosition.SlideTopCenter:
                return 'top-center';
            case Enums_1.Enums.AnnouncementPosition.SlideTopRight:
                return 'top-right';
            case Enums_1.Enums.AnnouncementPosition.SlideBottomLeft:
                return 'bottom-left';
            case Enums_1.Enums.AnnouncementPosition.SlideBottomRight:
                return 'bottom-right';
            case Enums_1.Enums.AnnouncementPosition.SlideLeftTop:
                return 'left-top';
            case Enums_1.Enums.AnnouncementPosition.SlideLeftCenter:
                return 'left-center';
            case Enums_1.Enums.AnnouncementPosition.SlideRightTop:
                return 'right-top';
            case Enums_1.Enums.AnnouncementPosition.SlideRightCenter:
                return 'right-center';
            case Enums_1.Enums.AnnouncementPosition.SlideRightBottom:
                return 'right-bottom';
            default:
                console.error("Unknown AnnouncementPositionId " + announcementPositionId);
                return 'bottom-center';
        }
    };
    /* Survey Utils */
    Herald.prototype.generateSurveyButtons = function (messageData) {
        var _this = this;
        if (!messageData || !messageData.buttons) {
            return undefined;
        }
        //add the nps urls
        var valueParam = messageData.responseUrl.indexOf('?') === -1 ? '?value=' : '&value=';
        return messageData.buttons.map(function (btn) {
            var style = '';
            if (btn.color)
                style += "background-color: " + btn.color + "!important;";
            if (messageData.wide)
                style += 'min-width: 100% !important;';
            return _this.appSvc.templater.populateTemplate(_this.templateCache.announcementSurveyButtonTemplate, {
                Style: style,
                TextStyle: btn.color ? 'color: #fff!important' : '',
                Url: messageData.responseUrl + valueParam + btn.score,
                Label: _this.formatSurveyButtonLabel(btn.label),
                Wide: messageData.wide,
            });
        }).join(messageData.wide ? '' : this.templateCache.announcementSurveyButtonSpacerTemplate);
    };
    Herald.prototype.formatSurveyButtonLabel = function (label) {
        //replace font-awesome class to prevent possible conflicts if hosting website also uses it
        return label.replace(/cz-survey-face far fa-/g, 'cz-survey-face-');
    };
    //Generate buttons for any announcements generated before new survey types were introduced
    Herald.prototype.generateDefaultNpsButtons = function (messageData) {
        var _this = this;
        var valueParam = messageData.responseUrl.indexOf('?') === -1 ? '?value=' : '&value=';
        return __spreadArray([], (Array(11)), true).map(function (v, i) { return _this.appSvc.templater.populateTemplate(_this.templateCache.announcementSurveyButtonTemplate, {
            Style: '',
            TextStyle: '',
            Url: messageData.responseUrl + valueParam + i,
            Label: _this.formatSurveyButtonLabel(i.toString()),
            Wide: messageData.wide,
        }); }).join(this.templateCache.announcementSurveyButtonSpacerTemplate);
    };
    /** WalkThrough Anchors **/
    Herald.prototype.CheckForWalkthroughAnchors = function () {
        if (this.sessionSvc.DevlessPanelEnabled) {
            return;
        }
        var anchors = this.walkthroughSvc.GetAnchorWalkthroughs();
        if (anchors && anchors.length) {
            anchors.forEach(this.setupWalkthroughAnchor);
        }
    };
    Herald.prototype.setupWalkthroughAnchor = function (walkthrough, metaData) {
        var _this = this;
        var id = this.generateWalkthroughAnchorId(walkthrough), triggerConfig = walkthrough.triggerConfig;
        var anchorFrame = this.windowSvc.document.getElementById(id), isPageTag = clientlibs_1.CoreUtils.Urls.checkUrlAgainstPageTag(this.windowSvc.href(), walkthrough.pageTag);
        if (isPageTag && !anchorFrame) {
            //dont add anchors for one time walkthroughs that have already been seen
            if (!walkthrough.recurrence && walkthrough.id && this.seenWalkthroughIds.indexOf(walkthrough.id) !== -1) {
                return;
            }
            //if the page tag matches and there is no anchor then add one
            var target_1 = this.windowSvc.document.querySelector(triggerConfig.targetSelector);
            //no target? bail
            if (!target_1) {
                this.appSvc.debug('[Devless Walkthrough Anchor target not found - bailing on walkthrough setup]', triggerConfig.targetSelector);
                return;
            }
            try {
                //if the target is not visible then bail
                var targetRect = target_1.getBoundingClientRect();
                if (!targetRect || !targetRect.height || !targetRect.width) {
                    this.appSvc.debug('[Devless Walkthrough Anchor target not visible - bailing on walkthrough setup]', triggerConfig.targetSelector);
                    return;
                }
            }
            catch (ex) {
                return;
            }
            var targetParent = target_1.parentElement;
            var anchorFrameConfig = {
                triggerConfig: triggerConfig,
                walkthroughStyleConfig: clientlibs_1.ModelUtils.create(new clientlibs_1.WalkthroughStyleConfig(), __assign(__assign({}, this.walkthroughSvc.walkthroughStyleConfig), walkthrough.styleConfig)),
                onClickCallback: function (e) {
                    _this.appSvc.debug('[Devless Walkthrough Anchor clicked]', id);
                    //this.appSvc.pubsub.publish(Enums.ChurnZeroAppEvents.WalkthroughStart, walkthrough);
                    _this.onStartWalkthrough(walkthrough, metaData);
                    //remove anchors for onetime walkthroughs
                    if (!walkthrough.recurrence) {
                        _this.appSvc.debug('[Devless Walkthrough Anchor onetime use - removing]', id);
                        _this.removeAnchorFrame(anchorFrame);
                    }
                },
                onLoadCallback: function (ctx) {
                    //position the anchor relative to the target
                    var pos = _this.calcAnchorPosition(triggerConfig, target_1);
                    anchorFrame.style.top = pos.top;
                    anchorFrame.style.left = pos.left;
                },
                onResizeCallback: function () {
                },
                cssLinks: [this.appSvc.addCdn('css/in_frame_anchor.css')],
                customCss: this.sessionSvc.CurrentAccountContent.css
            };
            anchorFrameConfig['testing'] = walkthrough['testing'];
            anchorFrame = this.frameBuilder.buildWalkthroughAnchorFrame(anchorFrameConfig);
            anchorFrame.id = id;
            //keep track of key info so we can reposition on window resize
            this.anchorFrames.push({ anchorFrame: anchorFrame, anchorFrameConfig: anchorFrameConfig, target: target_1 });
            var onlyOnHoverEnterListener = void 0, onlyOnHoverLeaveListener = void 0;
            if (triggerConfig.iconStyleConfig.displayTypeId === clientlibs_1.AnchorDisplayType.OnlyOnHover && targetParent) {
                anchorFrame.style.display = 'none';
                var currentTarget_1, currentTargetEnterHandler_1, currentTargetLeaveHandler_1, parentLeaveTimeout_1, leaveAnchorWithoutEnteringContainerTimeout_1;
                onlyOnHoverEnterListener = function (e) {
                    console.log('parent enter');
                    if (anchorFrame) {
                        //we are in the container
                        //show the anchor
                        anchorFrame.style.display = 'inline-block';
                        //stop the leave-anchor-without-entering-container timeout
                        if (leaveAnchorWithoutEnteringContainerTimeout_1) {
                            _this.windowSvc.window.clearTimeout(leaveAnchorWithoutEnteringContainerTimeout_1);
                            leaveAnchorWithoutEnteringContainerTimeout_1 = undefined;
                            console.log('cleared anchor leave timeout');
                        }
                        //add a listener for mousing into the anchor
                        if (currentTargetEnterHandler_1) {
                            anchorFrame.removeEventListener('mouseenter', currentTargetEnterHandler_1);
                        }
                        currentTargetEnterHandler_1 = function (e) {
                            console.log('anchor enter');
                            //we are in the anchor
                            currentTarget_1 = anchorFrame;
                            //stop the parent leave timeout from hiding anchor
                            if (parentLeaveTimeout_1) {
                                _this.windowSvc.window.clearTimeout(parentLeaveTimeout_1);
                                parentLeaveTimeout_1 = undefined;
                                console.log('cleared parent leave timeout');
                            }
                            //listen for leaving the anchor
                            //add a listener for mousing into the anchor
                            if (currentTargetLeaveHandler_1) {
                                anchorFrame.removeEventListener('mouseleave', currentTargetLeaveHandler_1);
                            }
                            currentTargetLeaveHandler_1 = function (e) {
                                console.log('anchor leave');
                                currentTarget_1 = undefined;
                                anchorFrame.removeEventListener('mouseleave', currentTargetLeaveHandler_1);
                                leaveAnchorWithoutEnteringContainerTimeout_1 = _this.windowSvc.window.setTimeout(function () {
                                    console.log('anchor leave timeout');
                                    anchorFrame.style.display = 'none';
                                    anchorFrame.removeEventListener('mouseenter', currentTargetEnterHandler_1);
                                }, 250);
                            };
                            anchorFrame.addEventListener('mouseleave', currentTargetLeaveHandler_1);
                        };
                        anchorFrame.addEventListener('mouseenter', currentTargetEnterHandler_1);
                    }
                };
                onlyOnHoverLeaveListener = function (e) {
                    console.log('parent leave');
                    parentLeaveTimeout_1 = _this.windowSvc.window.setTimeout(function () {
                        console.log('parent leave timeout');
                        if (anchorFrame) {
                            if (currentTarget_1 == anchorFrame) {
                                return;
                            }
                            //we have left the container and we are not in the anchor
                            anchorFrame.style.display = 'none';
                            anchorFrame.removeEventListener('mouseenter', currentTargetEnterHandler_1);
                        }
                    }, 100);
                };
                targetParent.addEventListener('mouseenter', onlyOnHoverEnterListener);
                targetParent.addEventListener('mouseleave', onlyOnHoverLeaveListener);
            }
            var container = void 0;
            if (triggerConfig.containerType === clientlibs_1.ContainerType.Parent && targetParent) {
                container = targetParent;
            }
            else {
                container = this.windowSvc.elementCache.body.get(0);
            }
            container.appendChild(anchorFrame);
            this.appSvc.debug('[Devless Walkthrough Anchor - adding to the page]', id);
        }
        else if (isPageTag && anchorFrame) {
            //check target still exists
            // if not then remove anchor frame
            var target = this.windowSvc.document.querySelector(triggerConfig.targetSelector);
            if (!target) {
                this.removeAnchorFrame(anchorFrame);
                this.appSvc.debug('[Devless Walkthrough Anchor no longer applicable (no target) - removing]', id);
                return;
            }
            var targetRect = target.getBoundingClientRect();
            var isTargetHidden = (!targetRect || !targetRect.height || !targetRect.width);
            if (isTargetHidden) {
                this.removeAnchorFrame(anchorFrame);
                this.appSvc.debug('[Devless Walkthrough Anchor no longer applicable (target has no size) - removing]', id);
            }
        }
        else if (!isPageTag && anchorFrame) {
            //if the page tag doesnt match and there is an anchor, then remove it
            this.removeAnchorFrame(anchorFrame);
            this.appSvc.debug('[Devless Walkthrough Anchor no longer applicable (incorrect pagetag) - removing]', id);
        }
    };
    Herald.prototype.generateWalkthroughAnchorId = function (walkthrough) {
        return "cz-wa-" + walkthrough.id;
    };
    Herald.prototype.calcAnchorPosition = function (triggerConfig, target) {
        var targetRect = target.getBoundingClientRect(), anchorSize = triggerConfig.iconStyleConfig.size * 1.5;
        var scrollTop = this.windowSvc.elementCache.window.scrollTop(), scrollLeft = this.windowSvc.elementCache.window.scrollLeft();
        var top, bottom, left, right;
        if (triggerConfig.containerType === clientlibs_1.ContainerType.Parent) {
            top = target.offsetTop;
            bottom = top + targetRect.height;
            left = target.offsetLeft;
            right = left + targetRect.width;
        }
        else {
            top = targetRect.top + scrollTop;
            bottom = targetRect.bottom + scrollTop;
            left = targetRect.left + scrollLeft;
            right = targetRect.right + scrollLeft;
        }
        var topPos, leftPos;
        //all positioning needs to use top & left only so the
        // tooltip positioning can read from there to get its relative position
        switch (triggerConfig.iconStyleConfig.positionTypeId) {
            case clientlibs_1.AnchorPositionType.Top:
                topPos = top - anchorSize;
                leftPos = left + (targetRect.width / 2) - (anchorSize / 2);
                break;
            case clientlibs_1.AnchorPositionType.TopRight:
                topPos = top - anchorSize;
                leftPos = right;
                break;
            case clientlibs_1.AnchorPositionType.Right:
                topPos = top + (targetRect.height / 2) - (anchorSize / 2);
                leftPos = right;
                break;
            case clientlibs_1.AnchorPositionType.BottomRight:
                topPos = bottom;
                leftPos = right;
                break;
            case clientlibs_1.AnchorPositionType.Bottom:
                topPos = bottom;
                leftPos = left + (targetRect.width / 2) - (anchorSize / 2);
                break;
            case clientlibs_1.AnchorPositionType.BottomLeft:
                topPos = bottom;
                leftPos = left - anchorSize;
                break;
            case clientlibs_1.AnchorPositionType.Left:
                topPos = top + (targetRect.height / 2) - (anchorSize / 2);
                leftPos = left - anchorSize;
                break;
            case clientlibs_1.AnchorPositionType.TopLeft:
                topPos = top - anchorSize;
                leftPos = left - anchorSize;
                break;
        }
        var offsets = triggerConfig.iconStyleConfig.offset || { top: 0, left: 0 };
        if (offsets.top) {
            topPos += parseInt(offsets.top.toString()) * -1; //invert because - value makes more sense to go down
        }
        if (offsets.left) {
            leftPos += parseInt(offsets.left.toString()); // dont invert because left makes sense as negative
        }
        return { top: topPos + 'px', left: leftPos + 'px' };
    };
    Herald.prototype.onWindowResizeForAnchors = function () {
        for (var i = 0; i < this.anchorFrames.length; i++) {
            if (this.anchorFrames[i]) {
                var _a = this.anchorFrames[i], anchorFrame = _a.anchorFrame, anchorFrameConfig = _a.anchorFrameConfig, target = _a.target;
                var pos = this.calcAnchorPosition(anchorFrameConfig.triggerConfig, target);
                anchorFrame.style.top = pos.top;
                anchorFrame.style.left = pos.left;
            }
        }
    };
    Herald.prototype.clearAllAnchors = function () {
        var _a, _b;
        var anchorFrames = this.windowSvc.getBodyElement().querySelectorAll('.cz-walk-anchor-frame');
        for (var i = 0; i < anchorFrames.length; i++) {
            (_b = (_a = anchorFrames[i]) === null || _a === void 0 ? void 0 : _a.parentElement) === null || _b === void 0 ? void 0 : _b.removeChild(anchorFrames[i]);
        }
        this.anchorFrames = [];
    };
    return Herald;
}());
exports["default"] = Herald;


/***/ }),

/***/ "./src/core/IndependentLauncher.ts":
/*!*****************************************!*\
  !*** ./src/core/IndependentLauncher.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IndependentLauncher = void 0;
var PanelDisplay_1 = __webpack_require__(/*! @src/core/PanelDisplay */ "./src/core/PanelDisplay.ts");
var errorLogger_1 = __importDefault(__webpack_require__(/*! @src/core/errorLogger */ "./src/core/errorLogger.ts"));
var IndependentLauncher = /** @class */ (function (_super) {
    __extends(IndependentLauncher, _super);
    function IndependentLauncher(parentDocument, appSvc, tenantSvc, windowSvc, storageSvc, sessionSvc, messageSvc, templateCache) {
        var _this = _super.call(this, appSvc, tenantSvc, windowSvc, storageSvc, sessionSvc, messageSvc, templateCache) || this;
        _this.parentDocument = parentDocument;
        _this.widgets = [];
        _this.haltOnError = false;
        _this.errorMessagePrefix = 'Independent Launcher Handle Error';
        return _this;
    }
    IndependentLauncher.prototype.setLauncherBoundingRectangle = function () {
        if (!this.panelLauncher)
            return;
        this.launcherBoundingRect = this.panelLauncher.getBoundingClientRect();
    };
    /**
     * Construct a useful error message from inputs and report error
     * @param err
     * @param additionalInfo
     * @protected
     */
    IndependentLauncher.prototype.handleError = function (err, additionalInfo) {
        if (this.haltOnError) {
            this.onHalt();
        }
        var msg = this.errorMessagePrefix;
        if (additionalInfo) {
            msg += ": " + additionalInfo;
        }
        errorLogger_1.default.report(msg, err);
    };
    return IndependentLauncher;
}(PanelDisplay_1.BasePanelDisplay));
exports.IndependentLauncher = IndependentLauncher;


/***/ }),

/***/ "./src/core/PanelDisplay.ts":
/*!**********************************!*\
  !*** ./src/core/PanelDisplay.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BasePanelDisplay = void 0;
/* global globalThis */
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var BasePanelDisplay = /** @class */ (function () {
    function BasePanelDisplay(appSvc, tenantSvc, windowSvc, storageSvc, sessionSvc, messageSvc, templateCache) {
        this.appSvc = appSvc;
        this.tenantSvc = tenantSvc;
        this.windowSvc = windowSvc;
        this.storageSvc = storageSvc;
        this.sessionSvc = sessionSvc;
        this.messageSvc = messageSvc;
        this.templateCache = templateCache;
        this.tabbedAvatarPosition = 'bottom'; // or ['top', 'center']
        this.panelOpenStatusKey = 'PANEL_OPEN_STATUS';
        this.panelWidgets = [];
    }
    Object.defineProperty(BasePanelDisplay.prototype, "basePanelVisible", {
        get: function () {
            //if the current IsPanelOpen does not exist,
            // try to load it from storage
            if (typeof (this._basePanelVisible) === 'undefined') {
                this._basePanelVisible = this.storageSvc.get(this.panelOpenStatusKey, this._basePanelVisible);
            }
            return this._basePanelVisible;
        },
        set: function (PanelOpenStatus) {
            this._basePanelVisible = PanelOpenStatus;
            //store current state of IsPanelOpen
            this.storageSvc.set(this.panelOpenStatusKey, this._basePanelVisible);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BasePanelDisplay.prototype, "basePanel", {
        //Common Elements
        get: function () {
            return this.windowSvc.czq('#cz-csm-panel');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BasePanelDisplay.prototype, "panelToggle", {
        get: function () {
            return this.windowSvc.czq('#czChatButtonWrapper');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BasePanelDisplay.prototype, "panelToggleContent", {
        get: function () {
            return this.panelToggle.find('.cz-chat-button-2');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BasePanelDisplay.prototype, "alertMessageBody", {
        //Click here to see that again container
        get: function () {
            return this.windowSvc.czq('.cz-alert-message-body');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BasePanelDisplay.prototype, "unreadBadge", {
        get: function () {
            return this.windowSvc.czq('.cz-unread-badge');
        },
        enumerable: false,
        configurable: true
    });
    BasePanelDisplay.prototype.getLauncherBoundingRectangle = function (forceUpdate) {
        if (this.launcherBoundingRect === null || forceUpdate)
            this.setLauncherBoundingRectangle();
        return this.launcherBoundingRect;
    };
    BasePanelDisplay.prototype.removeAllInjectedHtml = function () {
        // TODO: Remove CZE usage here
        this.windowSvc.czq('link#cz-styles, div#cz-panel-container').remove();
    };
    //inject the churnzero stylesheet for the button and panel
    BasePanelDisplay.prototype.loadCZStyles = function () {
        if (!this.baseStylesLoaded) {
            this.baseStylesLoaded = true;
        }
    };
    BasePanelDisplay.prototype.openBasePanel = function (forceOpen, onOpen) {
        if (this.basePanelVisible && !forceOpen) {
            return;
        }
        //hide the panel avatar
        this.hidePanelToggle();
        this.basePanel
            .removeClass('hidden')
            .removeClass("panel-" + this.sessionSvc.PanelPosition + "-collapsed")
            .addClass("panel-" + this.sessionSvc.PanelPosition)
            .one(clientlibs_1.StyleUtils.whichTransitionEvent(), function () {
            if (typeof onOpen === 'function') {
                onOpen();
            }
        });
        //hide the alert message
        this.alertMessageBody.attr('style', clientlibs_1.StyleUtils.replaceStyleValue('block', 'none'));
        this.basePanelVisible = true;
        //let others know panel was shown
        this.appSvc.pubsub.publish(clientlibs_1.ChurnZeroAppEvents.PanelShow);
    };
    BasePanelDisplay.prototype.closeBasePanel = function (onClose) {
        if (this.basePanelVisible) {
            this.showPanelToggle();
            this.basePanel
                .removeClass("panel-" + this.sessionSvc.PanelPosition)
                .addClass("panel-" + this.sessionSvc.PanelPosition + "-collapsed")
                .one(clientlibs_1.StyleUtils.whichTransitionEvent(), function () {
                if (typeof onClose === 'function') {
                    onClose();
                }
            });
            this.basePanelVisible = false;
            //let others know panel was hidden
            this.appSvc.pubsub.publish(clientlibs_1.ChurnZeroAppEvents.PanelHide);
        }
    };
    BasePanelDisplay.prototype.setupBasePanelFunctionality = function () {
        var _this = this;
        //add position classes to panel toggle and listener for clicks on toggle to call show
        this.setupBaseToggleFunctionality();
        //add position classes to panel container
        this.basePanel.addClass("panel-" + this.sessionSvc.PanelPosition + "-collapsed");
        if (this.sessionSvc.PanelEnabled) {
            //add position classes to Show More Info container
            var alertMessageBody = this.alertMessageBody;
            alertMessageBody.addClass('alert-message-' + this.sessionSvc.PanelPosition);
            alertMessageBody.addClass('alert-message-' + this.sessionSvc.AvatarType);
            //add listener for clicks on Show More Info container
            alertMessageBody.on(this.windowSvc.namespaceEvent('mousedown'), function () { return _this.show(); });
        }
    };
    BasePanelDisplay.prototype.setupBaseToggleFunctionality = function () {
        var _this = this;
        var panelToggle = this.panelToggle.get(0);
        if (this.sessionSvc.AvatarType === 'tabbed') {
            panelToggle.className += ' tabbed-avatar';
            panelToggle.className += ' ' + this.tabbedAvatarPosition + '-tab';
            panelToggle.className += ' ' + this.sessionSvc.PanelPosition + '-tab';
        }
        else {
            panelToggle.className += ' floating-avatar-' + this.sessionSvc.PanelPosition;
        }
        this.panelToggleContent.on(this.windowSvc.namespaceEvent('click'), function () { return _this.show(); });
    };
    //Based on the SP v/h offsets, these can be numbers or null...
    BasePanelDisplay.prototype.hasConfigOffsets = function (verticalOffset, horizontalOffset) {
        return (clientlibs_1.CoreUtils.Numbers.isNumeric(verticalOffset) || clientlibs_1.CoreUtils.Numbers.isNumeric(horizontalOffset));
    };
    BasePanelDisplay.prototype.addConfigOffsetsToElement = function (element, vOffset, hOffset) {
        var elementPosition = this.windowSvc.offset(element), 
        //When we have a positive vertical/horizontal offset,
        //the element moves up. Reverse if it's negative
        elementVerticalOffset = elementPosition.top + (vOffset * -1), elementHorizontalOffset = elementPosition.left + (hOffset * -1);
    };
    /**
     * Get the class name associated with a LaunchIconPosition
     * @param position
     * @protected
     */
    //So this might not be the best home for this, but
    //as we get away from using BasePanelDisplay in SC
    //and transition out of SPs, both can share this here until
    //the time comes to move it elsewhere..
    BasePanelDisplay.prototype.getPositionalClassFromConfig = function (position) {
        switch (position) {
            case clientlibs_1.LaunchIconPosition.TopCenter:
                return 'pos-top-center';
            case clientlibs_1.LaunchIconPosition.TopRight:
                return 'pos-top-right';
            case clientlibs_1.LaunchIconPosition.LeftCenter:
                return 'pos-left-center';
            case clientlibs_1.LaunchIconPosition.RightCenter:
                return 'pos-right-center';
            case clientlibs_1.LaunchIconPosition.BottomLeft:
                return 'pos-bottom-left';
            case clientlibs_1.LaunchIconPosition.BottomCenter:
                return 'pos-bottom-center';
            case clientlibs_1.LaunchIconPosition.BottomRight:
                return 'pos-bottom-right';
            default:
                return 'pos-top-left';
        }
    };
    return BasePanelDisplay;
}());
exports.BasePanelDisplay = BasePanelDisplay;


/***/ }),

/***/ "./src/core/SessionStorageQueue.ts":
/*!*****************************************!*\
  !*** ./src/core/SessionStorageQueue.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var SessionStorageQueue = /** @class */ (function () {
    function SessionStorageQueue(storageSvc, windowSvc, key) {
        this.storageSvc = storageSvc;
        this.windowSvc = windowSvc;
        this.key = key;
        //migrate old way to new way
        try {
            var q = this._getQueue();
            this.storageSvc.remove(this.key);
            this.key = this.storageSvc.encode(this.key);
            if (q.length) {
                this._setQueue(q);
            }
        }
        catch (e) {
            //meh
        }
    }
    SessionStorageQueue.prototype._getQueue = function () {
        var s = this.storageSvc.get(this.key, []);
        //if it is a string try parsing again...
        if (clientlibs_1.CoreUtils.isString(s)) {
            try {
                s = this.windowSvc.JSON.parse(s);
            }
            catch (ex) {
                //meh
                s = [];
            }
        }
        return s;
    };
    SessionStorageQueue.prototype._setQueue = function (queue) {
        var valueToStore = queue;
        if (queue.length === 0) {
            this.storageSvc.remove(this.key);
        }
        else {
            this.storageSvc.set(this.key, valueToStore);
        }
    };
    SessionStorageQueue.prototype.push = function (item) {
        try {
            var queueStorage = this._getQueue();
            queueStorage.push(item);
            this._setQueue(queueStorage);
        }
        catch (err) {
            return false;
        }
        return true;
    };
    Object.defineProperty(SessionStorageQueue.prototype, "length", {
        get: function () {
            try {
                var queueStorage = this._getQueue();
                return queueStorage.length;
            }
            catch (err) {
                return -1;
            }
        },
        enumerable: false,
        configurable: true
    });
    SessionStorageQueue.prototype.remove = function (item, filterFunc) {
        if (filterFunc === void 0) { filterFunc = null; }
        var queueStorage = this._getQueue();
        queueStorage = queueStorage.filter(function (q) {
            if (typeof filterFunc === 'function') {
                return filterFunc(q, item);
            }
            return q !== item;
        });
        this._setQueue(queueStorage);
    };
    SessionStorageQueue.prototype.removeAll = function (items, filterFunc) {
        if (filterFunc === void 0) { filterFunc = null; }
        var queueStorage = this._getQueue();
        queueStorage = queueStorage.filter(function (q) {
            if (typeof filterFunc === 'function') {
                return filterFunc(q);
            }
            return items.indexOf(q) !== -1;
        });
        this._setQueue(queueStorage);
    };
    SessionStorageQueue.prototype.shift = function () {
        var returnItem = null;
        try {
            var queueStorage = this._getQueue();
            returnItem = queueStorage.shift();
            this._setQueue(queueStorage);
        }
        catch (err) {
            return returnItem;
        }
        return returnItem;
    };
    SessionStorageQueue.prototype.unshift = function (item) {
        var returnItem = -1;
        try {
            var queueStorage = this._getQueue();
            returnItem = queueStorage.unshift(item);
            this._setQueue(queueStorage);
        }
        catch (err) {
            return returnItem;
        }
        return returnItem;
    };
    SessionStorageQueue.prototype.unshiftAll = function (items) {
        var returnItem = -1;
        try {
            var queueStorage = this._getQueue();
            this._setQueue(items.concat(queueStorage));
        }
        catch (err) {
            //meh
        }
    };
    SessionStorageQueue.prototype.empty = function () {
        try {
            this._setQueue([]);
        }
        catch (err) {
            // eslint-disable-line no-empty
        }
    };
    SessionStorageQueue.prototype.getAllItems = function () {
        return this._getQueue();
    };
    return SessionStorageQueue;
}());
exports["default"] = SessionStorageQueue;


/***/ }),

/***/ "./src/core/TemplateCache.ts":
/*!***********************************!*\
  !*** ./src/core/TemplateCache.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var TemplateCache = /** @class */ (function () {
    function TemplateCache() {
    }
    return TemplateCache;
}());
exports["default"] = TemplateCache;


/***/ }),

/***/ "./src/core/Templater.ts":
/*!*******************************!*\
  !*** ./src/core/Templater.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var ChurnZeroTemplater = /** @class */ (function () {
    function ChurnZeroTemplater(czq) {
        this.czq = czq;
        this.globals = {};
    }
    ChurnZeroTemplater.prototype.compile_template = function (url, replacementDictionary, callback) {
        var _this = this;
        this.czq.get(url, function (src) {
            var template = _this.populateTemplate(src, replacementDictionary);
            callback(template, replacementDictionary);
        });
    };
    ChurnZeroTemplater.prototype.populateTemplate = function (template, replacementDictionary, postPopulatePurge) {
        if (!template) {
            return;
        }
        //ensure the globals exists in the
        // replacement dictionary
        for (var x in this.globals) {
            if (!replacementDictionary[x]) {
                replacementDictionary[x] = this.globals[x];
            }
        }
        for (var x in replacementDictionary) {
            template = template.split('{{' + x + '}}').join((replacementDictionary[x] || ''));
        }
        if (postPopulatePurge === true) {
            template = this.purge(template);
        }
        return template;
    };
    ChurnZeroTemplater.prototype.addGlobal = function (key, value) {
        this.globals[key] = value;
    };
    ChurnZeroTemplater.prototype.purge = function (templateString) {
        if (!templateString) {
            return templateString;
        }
        return templateString.replace(ChurnZeroTemplater.PlaceHolderRegex, '');
    };
    ChurnZeroTemplater.PlaceHolderRegex = /{{[^}]*}}/g;
    return ChurnZeroTemplater;
}());
exports["default"] = ChurnZeroTemplater;


/***/ }),

/***/ "./src/core/UrlChangeHandler.ts":
/*!**************************************!*\
  !*** ./src/core/UrlChangeHandler.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var UrlChangeHandler = /** @class */ (function () {
    // eslint-disable-next-line @typescript-eslint/ban-types
    function UrlChangeHandler(onChangeEvent, stopOnChange, timeout) {
        var _this = this;
        if (timeout === void 0) { timeout = 100; }
        this.oldLocation = window.location.toString();
        this.onChangeEvent = onChangeEvent;
        this.stopOnChange = stopOnChange;
        this.Check = window.setInterval(function () {
            try {
                _this.detect();
            }
            catch (ex) {
                //meh
            }
        }, timeout);
    }
    UrlChangeHandler.prototype.detect = function () {
        if (this.oldLocation !== window.location.toString()) {
            console.log('URL Changed');
            this.onChangeEvent();
            if (this.stopOnChange) {
                this.Stop();
            }
            this.oldLocation = window.location.toString();
        }
    };
    UrlChangeHandler.prototype.Stop = function () {
        if (this.Check) {
            window.clearInterval(this.Check);
            this.Check = null;
        }
    };
    return UrlChangeHandler;
}());
exports["default"] = UrlChangeHandler;


/***/ }),

/***/ "./src/core/_ChurnZeroApp.ts":
/*!***********************************!*\
  !*** ./src/core/_ChurnZeroApp.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Enums_1 = __webpack_require__(/*! ./Enums */ "./src/core/Enums.ts");
var HashHandler_1 = __importDefault(__webpack_require__(/*! ./HashHandler */ "./src/core/HashHandler.ts"));
var TemplateCache_1 = __importDefault(__webpack_require__(/*! ./TemplateCache */ "./src/core/TemplateCache.ts"));
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var EventSpider_1 = __importDefault(__webpack_require__(/*! ./EventSpider */ "./src/core/EventSpider.ts"));
var ApplicationMarshal_1 = __webpack_require__(/*! @src/core/ApplicationMarshal */ "./src/core/ApplicationMarshal.ts");
var clientlibs_2 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var errorLogger_1 = __importDefault(__webpack_require__(/*! ./errorLogger */ "./src/core/errorLogger.ts"));
var tenant_service_1 = __importStar(__webpack_require__(/*! ../services/tenant.service */ "./src/services/tenant.service.ts"));
var Herald_1 = __importDefault(__webpack_require__(/*! ./Herald */ "./src/core/Herald.ts"));
var UrlChangeHandler_1 = __importDefault(__webpack_require__(/*! ./UrlChangeHandler */ "./src/core/UrlChangeHandler.ts"));
var window_service_1 = __importDefault(__webpack_require__(/*! ../services/window.service */ "./src/services/window.service.ts"));
var http_service_1 = __importDefault(__webpack_require__(/*! ../services/http.service */ "./src/services/http.service.ts"));
var storage_service_1 = __importDefault(__webpack_require__(/*! ../services/storage.service */ "./src/services/storage.service.ts"));
var simpleStorage_repository_1 = __importDefault(__webpack_require__(/*! ../repositories/simpleStorage.repository */ "./src/repositories/simpleStorage.repository.ts"));
var application_service_1 = __importDefault(__webpack_require__(/*! ../services/application.service */ "./src/services/application.service.ts"));
var socket_repository_1 = __importDefault(__webpack_require__(/*! ../repositories/socket.repository */ "./src/repositories/socket.repository.ts"));
var communication_service_1 = __importDefault(__webpack_require__(/*! ../services/communication.service */ "./src/services/communication.service.ts"));
var session_service_1 = __importDefault(__webpack_require__(/*! ../services/session.service */ "./src/services/session.service.ts"));
var message_service_1 = __importDefault(__webpack_require__(/*! ../services/message.service */ "./src/services/message.service.ts"));
var event_service_1 = __importDefault(__webpack_require__(/*! ../services/event.service */ "./src/services/event.service.ts"));
var pagetag_service_1 = __importDefault(__webpack_require__(/*! ../services/pagetag.service */ "./src/services/pagetag.service.ts"));
var walkthrough_service_1 = __importDefault(__webpack_require__(/*! ../services/walkthrough.service */ "./src/services/walkthrough.service.ts"));
var attribute_service_1 = __importDefault(__webpack_require__(/*! ../services/attribute.service */ "./src/services/attribute.service.ts"));
var subframe_repository_1 = __importDefault(__webpack_require__(/*! ../repositories/subframe.repository */ "./src/repositories/subframe.repository.ts"));
var clientlibs_3 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var checklist_service_1 = __webpack_require__(/*! @src/services/checklist.service */ "./src/services/checklist.service.ts");
var CZ_ANNOUNCEMENT_STYLES_ID = 'cz-external-announcement-styles';
var ChurnZeroApp = /** @class */ (function () {
    function ChurnZeroApp() {
        this.name = 'ChurnZeroApp';
        this.version = "localhost-2022-04-22T18:09:03.829Z"; //gets replaced by build task
        this.isRunning = false;
        this.isRegistered = false;
        this.sfSubIds = {};
        this.activityMonitorMapping = {};
        this.eventHandlers = {
            'connected': [],
            //'opened':[],
            //'closed':[],
            //'announcement':[],
            //'disconnected':[]
        };
        //DBDisconnected Properties
        this.lastReconnectPing = null;
        this.reconnectAttemptInterval = 1000 * 60 * 5;
        //PubSub subscriptions
        this.subIds = {};
        this.bootRetryMaxAttempts = 5;
        this.bootRetryCount = 5;
        this.reregisterRetryCount = 10;
        this.doAnyActiveActivityMonitorsExist = this.doAnyActiveActivityMonitorsExist.bind(this);
        this.templateCache = new TemplateCache_1.default();
        this.loadTemplates();
        this.appQueue = [];
        this.isMainFrame = true;
        this.booted = false;
        this.isConnecting = false;
        this.isUpdating = false;
    }
    Object.defineProperty(ChurnZeroApp.prototype, "lastPageTag", {
        //Last page tag that was active
        get: function () {
            return this.storageSvc.get('CZ_PageTag', null);
        },
        set: function (value) {
            if (value) {
                this.storageSvc.set('CZ_PageTag', value);
            }
            else {
                this.storageSvc.remove('CZ_PageTag');
            }
        },
        enumerable: false,
        configurable: true
    });
    /********************
     * Exposed API
     *********************/
    //boot sequence
    ChurnZeroApp.prototype.boot = function (previousAppState) {
        var _this = this;
        var _a;
        // Don't boot a boot!!
        if (this.booted)
            return;
        if (this.bootRetryCount === this.bootRetryMaxAttempts)
            console.time('BOOTTIME');
        /*if (!CoreUtils.areCookiesEnabled()) {
            console.info('**Cookies Disabled - Shut it down');
            console.timeEnd('BOOTTIME');
            return;
        }*/
        //detect if main frame
        this.isIniFrame = clientlibs_2.CoreUtils.FeatureDetection.inIframe();
        try {
            if (this.isIniFrame && window['czDontClimb'] !== true) {
                this.isMainFrame = false;
            }
        }
        catch (ex) {
            //meh
        }
        //set up core registries since we now know the dom is ready
        try {
            this.windowSvc = new window_service_1.default(window);
            this.httpSvc = new http_service_1.default(this.windowSvc.coder(), this.windowSvc.XMLHttpRequestReference);
            this.storageSvc = new storage_service_1.default(new simpleStorage_repository_1.default(this.windowSvc.coder()));
            this.applicationSvc = new application_service_1.default(this.storageSvc, this.windowSvc);
            this.applicationSvc.isMain = this.isMainFrame;
            this.tenantSvc = new tenant_service_1.default(this.storageSvc);
        }
        catch (e) {
            if (this.bootRetryCount--) {
                window.setTimeout(function () {
                    if (!_this.booted) {
                        console.info('Delaying boot, attempt #', (_this.bootRetryMaxAttempts - _this.bootRetryCount));
                        _this.boot(previousAppState);
                    }
                }, 1000);
            }
            else {
                console.timeEnd('BOOTTIME');
                errorLogger_1.default.report('ChurnZeroApp.boot.registryInit', e);
            }
            return;
        }
        if (!this.tenantSvc) {
            return;
        }
        //Unsupported Browser ... shut it down...
        if (!this.windowSvc.isSupportedBrowser()) {
            console.info('**Unsupported Browser - Shut it down');
            console.timeEnd('BOOTTIME');
            return;
        }
        var debuggingOn = this.windowSvc.window._czDebugging === true;
        if (debuggingOn) {
            this.applicationSvc.isDebugging = true;
        }
        this.applicationSvc.debug('Boot - Begin');
        //process any previous appState
        if (previousAppState) {
            this.applicationSvc.debug('Loading previous application state', previousAppState);
            var wasSimpleArray = Array.isArray(previousAppState), wasChurnZeroAppInstance = !wasSimpleArray && (previousAppState.name === this.name);
            //we need to set what was previously the event queue
            // to the apps queue so any events in the previous queue will get
            // processed
            if (wasSimpleArray) {
                for (var i = 0; i < previousAppState.length; i++) {
                    // Question: If item is falsy here, should we just "continue" the loop?
                    var item = previousAppState[i], itemLen = (_a = item === null || item === void 0 ? void 0 : item.length) !== null && _a !== void 0 ? _a : 0, theCmd = itemLen ? item[0] : '';
                    // Gracefully set command to an empty string if theCmd.toLowerCase() bombs out
                    var command = void 0;
                    try {
                        command = theCmd.toLowerCase();
                    }
                    catch (_b) {
                        command = '';
                    }
                    switch (command) {
                        case 'origins':
                            if (itemLen > 1) {
                                (item[1] || '').toString().split(',').forEach(function (o) {
                                    _this.windowSvc.addOrigin(o);
                                });
                                this.applicationSvc.debug('SubFrame Allowed Origins Expanded to:', this.windowSvc.origins);
                            }
                            break;
                        case 'setdomain':
                            if (itemLen > 1) {
                                var domain = (item[1] || '').toString();
                                this.setConnectionDomain(domain);
                                this.wasDomainSet = true;
                            }
                            break;
                        default:
                            this.appQueue.push(item);
                            break;
                    }
                }
            }
            else if (wasChurnZeroAppInstance) {
                //if the previousAppState was an instance of the ChurnZero App
                // we need to get some app state data to carry forward
                var previousQueue = previousAppState.getQueue();
                for (var i = 0; i < previousQueue.length; i++) {
                    this.appQueue.push(previousQueue[i]);
                }
            }
        }
        //setup the urls object
        this.applicationSvc.setupClientSideUrls();
        this.windowSvc.addOrigin(this.windowSvc.clientSideUrls.baseApiUrl.slice(0, -1));
        //add post message listener for frame communication
        if (this.applicationSvc.removeFrameComListener) {
            this.applicationSvc.removeFrameComListener();
        }
        this.applicationSvc.addFrameComListener();
        //if we are booting in an iframe
        // we need to check for a parent frame that has ChurnZero enabled
        // so we can leverage their connection instead of creating a duplicate
        if (this.isMainFrame) {
            this.bootMainFrame();
            this.booted = true;
            this.applicationSvc.debug('**Boot Finished - Main Frame');
            console.timeEnd('BOOTTIME');
        }
        else {
            this.bootSubFrame();
        }
    };
    //method for adding items to queue for processing
    ChurnZeroApp.prototype.push = function (arr) {
        this.appQueue.push(arr);
        if (this.booted) {
            this.processQueue();
        }
    };
    //stop all kernel functionality
    ChurnZeroApp.prototype.halt = function () {
        var _a;
        this.applicationSvc.debug('Halting');
        //check for exit modules
        this.checkPageTagExitModule();
        //stop the digest interval
        if (this.digestIntervalTimer) {
            this.windowSvc.window.clearInterval(this.digestIntervalTimer);
            this.digestIntervalTimer = null;
        }
        //also stop any registered sub-frames
        this.applicationSvc.messageSubFrames({
            code: Enums_1.Enums.FrameCommCodes.MainFramePassdown,
            data: { code: clientlibs_1.ChurnZeroAppEvents.HALT }
        });
        //remove the stuff
        //call any registered digest functions
        this.applicationSvc.pubsub.publish(clientlibs_1.ChurnZeroAppEvents.HALT);
        (_a = this._activityMonitor) === null || _a === void 0 ? void 0 : _a.Stop();
        //turn off events
        this.windowSvc.removeNamespacedEvents();
        if (this.hashHandler) {
            this.hashHandler.Stop();
            this.hashHandler = null;
        }
        // unload page monitor
        if (this.pageMonitorUrlChangeHandler) {
            this.pageMonitorUrlChangeHandler.Stop();
            this.pageMonitorUrlChangeHandler = null;
        }
        // unload event spider
        this.unloadEventSpider();
        // unload herald
        this.unloadHerald();
        // unload app marshal
        this.unloadApplicationMarshal();
        //disconnect from socket
        this.commSvc.disconnect();
        this.isConnecting = false;
        this.removeSubById('initialConnectionSubId');
        this.isRunning = false;
    };
    //verify the credentials
    ChurnZeroApp.prototype.verify = function () {
        var verifyObject = {
            AppHost: { value: this.commSvc.appHost },
            AppKey: { value: this.commSvc.appKey },
            AccountId: { value: null },
            ContactId: { value: null },
            IsConnected: { value: this.commSvc.isConnected() },
            'Active Devless Session': { value: this.sessionSvc.DevlessPanelEnabled },
            Module: { value: this.sessionSvc.CurrentModule || 'Unknown' },
            SilentMode: { value: true },
            State: { value: 'Main Frame' }
        };
        var ids = this.commSvc.splitContactKey(this.commSvc.contactKey);
        verifyObject.AccountId.value = ids.accountExternalId;
        verifyObject.ContactId.value = ids.contactExternalId;
        if (!this.sessionSvc.IsSilent) {
            delete verifyObject.SilentMode;
        }
        if (this.isMainFrame) {
            var count = Object.keys(this.applicationSvc.registeredSubFrames || {}).length;
            verifyObject.State.value += " w/ " + count + " sub-frame" + (count > 1 ? 's' : '');
        }
        else {
            verifyObject.State.value = 'Sub-frame';
            verifyObject.IsConnected.value = verifyObject.IsConnected.value + " via Main Frame";
        }
        var c = window['console']['table'];
        if (!c) {
            c = window['console']['info'];
        }
        c(verifyObject);
    };
    //toggle debug mode
    ChurnZeroApp.prototype.debug = function () {
        this.applicationSvc.isDebugging = !this.applicationSvc.isDebugging;
        if (this.applicationSvc.isDebugging) {
            this.windowSvc.window['console']['info']('ChurnZero debugging is now on. Any subsequent requests will be logged out to the console until ChurnZero.debug() is called again.');
            this.verify();
        }
        else {
            this.windowSvc.window['console']['info']('ChurnZero debugging is now off.');
        }
    };
    /********************
     * Setup Utils - Exposed
     *********************/
    //Expose internal Queue for updating app code
    ChurnZeroApp.prototype.getQueue = function () {
        return this.appQueue;
    };
    /********************
     * Public Functions Internals
     *********************/
    //main frame boot sub-routine
    ChurnZeroApp.prototype.bootMainFrame = function () {
        var _this = this;
        //remove any subframe subscriptions that might have been created
        if (this.sfSubIds) {
            for (var key in this.sfSubIds) {
                if (clientlibs_2.CoreUtils.hasOwnProp(this.sfSubIds, (key))) {
                    this.sfSubIds[key].remove();
                }
            }
        }
        //Setup Comm Service
        var commRepo = new socket_repository_1.default(this.storageSvc, this.httpSvc, this.windowSvc);
        this.commSvc = new communication_service_1.default(commRepo);
        //App Level
        this.setupInstanceServices();
        this.applicationSvc.debug("**Version - " + this.commSvc.appVersion);
        //try to emit any events
        this.processQueue();
        //wire up subframe boot handler
        this.subIds['subframeRegisteredSubId'] = this.applicationSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.SubframeRegistered, function (message) {
            var eMapConfig = {
                eventMaps: _this.eventSvc.eventMaps,
                eventMapVersion: _this.eventSvc.eventMapVersion
            };
            var responseData = {
                source: null,
                vcode: message.info.vcode,
                isRunning: _this.isRunning,
                tenantId: _this.tenantSvc.currentTenantId(),
                contact: _this.tenantSvc.contact,
                featureFlags: _this.tenantSvc.getFeatureFlags(),
                eventMapConfig: eMapConfig,
                //pageTagConfig: pageTagConfig
                //walkThroughConfig: walkThroughConfig
            };
            _this.applicationSvc.sendFrameCom(_this.applicationSvc.getRegisteredSubFrameById(message.info.source), {
                code: Enums_1.Enums.FrameCommCodes.SubframeBootResponse,
                data: responseData
            });
        });
        //wire up subframes mirror for incomming socket messages to get pushed downward
        this.commSvc.registerMirror(function (info) {
            var data = clientlibs_3.iFrameUtils.buildTransportMessage(clientlibs_3.TransportCodes.PubSubMirror, info);
            _this.applicationSvc.messageSubFrames({
                code: Enums_1.Enums.FrameCommCodes.MainFrameComRePublish,
                data: data
            });
        });
        //wire up listener for subframe to pass stuff back
        this.subIds['subframePassbackSubId'] = this.applicationSvc.pubsub.subscribe(Enums_1.Enums.FrameCommCodes.SubFramePassback, function (message) {
            switch (message.info.type) {
                case 'send':
                    _this.commSvc.send(message.info.data.socketMessageTypeId, message.info.data.messageContent, message.info.data.forcePoll);
                    break;
                case 'push':
                    _this.push(message.info.data);
                    break;
            }
        });
        //init the connection to the server
        console.log('initConnection from boot_main_frame');
        this.initConnection();
    };
    //sub frame boot sub-routine
    ChurnZeroApp.prototype.bootSubFrame = function () {
        var _this = this;
        var vcode = clientlibs_2.DataTypeUtils.newGuid();
        //wire up listener for main frame responses to boot announcement
        if (!this.sfSubIds['subframeBootResponseSubId']) {
            this.sfSubIds['subframeBootResponseSubId'] = this.applicationSvc.pubsub.subscribe(Enums_1.Enums.FrameCommCodes.SubframeBootResponse, function (message) {
                //iFrame boot process
                try {
                    var mainsResponse = message.info;
                    //if I didnt init the communication reject it
                    if (mainsResponse.vcode !== vcode) {
                        return;
                    }
                    if (!mainsResponse.source) {
                        window['console'].warn('Can only boot ChurnZero sub-frames if top has ChurnZero');
                        return;
                    }
                    _this.applicationSvc.debug('Main Frame Found. Sub Frame initializing');
                    _this.mainFrameResponded = true;
                    //Setup Comm Service
                    var subframeRepo = new subframe_repository_1.default(_this.windowSvc, _this.applicationSvc, mainsResponse.source);
                    _this.commSvc = new communication_service_1.default(subframeRepo);
                    //App Level
                    _this.setupInstanceServices();
                    _this.applicationSvc.debug("Version - " + _this.commSvc.appVersion);
                    //wire up listener for comm pubs from main
                    _this.sfSubIds['mainFrameComRepublishSubId'] = _this.applicationSvc.pubsub.subscribe(Enums_1.Enums.FrameCommCodes.MainFrameComRePublish, function (mirrorMessage) {
                        if (mirrorMessage.info.code === Enums_1.Enums.TransportCodes.PubSubMirror) {
                            _this.commSvc.publishMirrored(mirrorMessage.info.data);
                        }
                    });
                    //wire up listener for main frame application events
                    _this.sfSubIds['MainFramePassdownSubId'] = _this.applicationSvc.pubsub.subscribe(Enums_1.Enums.FrameCommCodes.MainFramePassdown, function (passdownMessage) {
                        switch (passdownMessage.info.code) {
                            case clientlibs_1.ChurnZeroAppEvents.HALT:
                                _this.halt();
                                break;
                            case clientlibs_1.ChurnZeroAppEvents.START:
                                _this.preStartLoad(passdownMessage.info.data);
                                _this.processQueue();
                                _this.startKernel();
                                break;
                        }
                    });
                    var config = {
                        tenantId: mainsResponse.tenantId,
                        contact: mainsResponse.contact,
                        featureFlags: mainsResponse.featureFlags,
                        eventMapConfig: mainsResponse.eventMapConfig
                    };
                    _this.preStartLoad(config);
                    //process anything that was queued during load
                    _this.processQueue();
                    //start the kernel if the main is already running
                    // otherwise the mains kernel start will trigger a MainFramePassdown:START
                    if (mainsResponse.isRunning) {
                        _this.startKernel();
                    }
                    _this.isRegistered = true;
                    _this.booted = true;
                    _this.applicationSvc.debug('**Boot Finished - Sub Frame');
                    console.timeEnd('BOOTTIME');
                }
                catch (ex) {
                    if (_this.reregisterRetryCount--) {
                        window.setTimeout(function () {
                            if (!_this.isRegistered) {
                                console.info('Delaying registration, attempt #', (10 - _this.reregisterRetryCount));
                                _this.bootSubFrame();
                            }
                        }, 1000);
                    }
                    else {
                        //only log errors not about registerSubFrame
                        if (ex && ex.message && ex.message.indexOf('registerSubFrame') !== -1) {
                            return;
                        }
                        var extraInfo = { retriesRemaining: _this.reregisterRetryCount };
                        errorLogger_1.default.report('ChurnZeroApp.bootsubFrame', ex, extraInfo);
                    }
                }
            });
        }
        //do boot announcement
        this.applicationSvc.debug('Doing boot announcement to top');
        this.applicationSvc.sendFrameCom({ window: this.windowSvc.window.top, origin: '*' }, {
            code: Enums_1.Enums.FrameCommCodes.SubframeBoot,
            data: vcode
        });
        //check for parent
        if (this.subframeParentTimeout) {
            this.windowSvc.window.clearTimeout(this.subframeParentTimeout);
            this.subframeParentTimeout = null;
        }
        this.subframeParentTimeout = this.windowSvc.window.setTimeout(function () {
            if (!_this.isMainFrame && !_this.mainFrameResponded) {
                _this.applicationSvc.debug('Doing boot announcement to parent');
                _this.applicationSvc.sendFrameCom({ window: _this.windowSvc.window.parent, origin: '*' }, {
                    code: Enums_1.Enums.FrameCommCodes.SubframeBoot,
                    data: vcode
                });
                //boot as main frame after 1050 ms timeout
                _this.windowSvc.window.setTimeout(function () {
                    if (!_this.isMainFrame && !_this.mainFrameResponded) {
                        _this.applicationSvc.debug('Main frame not present above. Booting as Main');
                        _this.isMainFrame = true;
                        _this.applicationSvc.isMain = true;
                        _this.bootMainFrame();
                        _this.booted = true;
                        _this.applicationSvc.debug('**Boot Finished - Main Frame');
                        console.timeEnd('BOOTTIME');
                    }
                }, 1050);
            }
        }, 1050);
    };
    ChurnZeroApp.prototype.processQueue = function () {
        console.info('Processing Queue', JSON.stringify(this.appQueue));
        while (this.appQueue.length > 0) {
            var queueItem = this.appQueue.shift();
            var method = void 0, args = [];
            if (Array.isArray(queueItem)) {
                method = queueItem.shift();
                args = queueItem;
            }
            else {
                method = queueItem;
            }
            var normalizedMethodName = void 0;
            try {
                normalizedMethodName = (method || '').toLowerCase();
            }
            catch (_a) {
                normalizedMethodName = '';
            }
            //case insensitivity helpers
            switch (normalizedMethodName) {
                case 'trackevent':
                    method = 'trackEvent';
                    break;
                case 'setattribute':
                    method = 'setAttribute';
                    break;
                case 'incrementattribute':
                    method = 'incrementAttribute';
                    break;
                case 'setappkey':
                    method = 'setAppKey';
                    break;
                case 'setcontact':
                    method = 'setContact';
                    break;
                case 'setmodule':
                    method = 'setModule';
                    break;
                case 'silent':
                    method = 'setSilent';
                    break;
                case 'setcontactfromcache':
                    method = 'setContactFromCache';
                    break;
                case 'stop':
                    method = 'stop';
                    break;
                case 'urltracking':
                    method = 'setUrlTracking';
                    break;
                case 'testannouncement':
                    method = 'testAnnouncement';
                    break;
                case 'replayannouncement':
                    method = 'replayAnnouncement';
                    break;
                case 'updateannouncement':
                    method = 'updateAnnouncement';
                    break;
                case 'hideannouncement':
                    method = 'hideAnnouncement';
                    break;
                case 'testwalkthrough':
                    method = 'testWalkthrough';
                    break;
                case 'testclearall':
                    method = 'testClearAll';
                    break;
                case 'open':
                    method = 'openPanel';
                    break;
                case 'close':
                    method = 'closePanel';
                    break;
                case 'churnzeroevent:on':
                    method = 'registerChurnZeroEventCallback';
                    break;
                case 'churnzeroevent:off':
                    method = 'deregisterChurnZeroEventCallback';
                    break;
                case 'triggerwalkthrough':
                    method = 'triggerWalkthrough';
                    break;
            }
            try {
                console.log('Trying:', method);
                this.applicationSvc.debug("Received " + method + ": ", args);
                // eslint-disable-next-line prefer-spread
                this[method].apply(this, args);
            }
            catch (err) {
                console.warn("Warning - " + method + " - " + err + " - " + args);
                console.warn(err);
            }
        }
    };
    ChurnZeroApp.prototype.setAppKey = function (appKey) {
        var currentKey = this.commSvc.appKey;
        if (currentKey && this.commSvc.isConnected() && appKey === currentKey) {
            console.info('Already connected and same appkey so no need to reconnect');
            return;
        }
        if (currentKey && currentKey !== appKey) {
            this.halt();
        }
        if (!this.isMainFrame) {
            //console.info("Not the main frame so no need for connection.(setAppKey)");
            this.pushToMain(['setAppKey', appKey]);
            return;
        }
        this.commSvc.appKey = appKey;
        console.info('App Key set to : ', this.commSvc.appKey);
        //during boot we call process queue so that the appKey can be set at anypoint during load
        // then we call initConnection so we want to avoid double connections. To do that we prevent set app key
        // from calling initConnection until after booting has completed.
        //
        // tldr: calling setAppKey after churnzero is ready will initConnection.
        // calling before will not as it is handled in the boot process.
        if (this.booted) {
            console.log('initConnection from setAppKey');
            this.initConnection();
        }
    };
    //retrieve the contactKey from the cache
    ChurnZeroApp.prototype.setContactFromCache = function () {
        var wouldBeFullKey = this.commSvc.getContactKeyFromCache();
        this._setContactKey(wouldBeFullKey);
    };
    //use supplied accountExternalId and contactExternalId for new contactKey
    ChurnZeroApp.prototype.setContact = function (accountExternalId, contactExternalId, accountExternalIdHash, contactExternalIdHash) {
        if (contactExternalId && contactExternalId.toString().trim().length === 0) {
            window['console']['warn']('Contact ExternalId can not be empty.');
            return;
        }
        var wouldBeFullKey = null;
        if (accountExternalId && contactExternalId) {
            if (accountExternalId && accountExternalId.length > 100) {
                window['console']['warn']('Account ExternalId can not be more than 100 characters.');
                return;
            }
            if (contactExternalId && contactExternalId.length > 100) {
                window['console']['warn']('Contact ExternalId can not be more than 100 characters.');
                return;
            }
            wouldBeFullKey = this.commSvc.generateContactKey(accountExternalId, contactExternalId);
        }
        else if (this.commSvc.isContactKeyValid(accountExternalId)) {
            wouldBeFullKey = accountExternalId;
        }
        //allow null wouldBeFullKey to be passed in so that
        // it is possible to clear out previous contactKey
        this._setContactKey(wouldBeFullKey, accountExternalIdHash, contactExternalIdHash);
    };
    ChurnZeroApp.prototype._setContactKey = function (wouldBeFullKey, accountExternalIdHash, contactExternalIdHash) {
        var currentKey = this.commSvc.contactKey;
        //if the new key is different than the old key
        // reset the app so we can start fresh with
        // the new key
        var keyChanged = currentKey && currentKey !== wouldBeFullKey;
        if (keyChanged) {
            this.stop();
        }
        if (!this.isMainFrame) {
            //console.info("Not the main frame so no need for connection.(setAppKey)");
            var keyParts = this.commSvc.splitContactKey(wouldBeFullKey);
            var items = ['setContact', keyParts.accountExternalId, keyParts.contactExternalId];
            if (accountExternalIdHash || contactExternalIdHash) {
                items = items.concat([accountExternalIdHash, contactExternalIdHash]);
            }
            this.pushToMain(items);
            return;
        }
        if (!wouldBeFullKey || wouldBeFullKey !== currentKey) {
            //if wouldBeFullKey is null, contactKey will be cleared (in mem and in storage)
            this.commSvc.contactKey = wouldBeFullKey;
            this.commSvc.accountHash = accountExternalIdHash;
            this.commSvc.contactHash = contactExternalIdHash;
        }
        console.info('Contact Unique Value set to : ', this.commSvc.contactKey);
        if (this.commSvc.isConnected() && wouldBeFullKey === currentKey) {
            console.info('Already connected and same contactkey so no need to reconnect');
            return;
        }
        //during boot we call process queue so that the contact can be set at any point during load
        // then we call initConnection so we want to avoid double connections. To do that we prevent set contact
        // from calling initConnection until after booting has completed.
        if (this.booted) {
            console.log('initConnection from _setContact');
            this.initConnection();
        }
    };
    ChurnZeroApp.prototype.pushToMain = function (items) {
        try {
            this.applicationSvc.debug('Pushing to Main:', items);
            this.applicationSvc.messageMain({
                code: Enums_1.Enums.FrameCommCodes.SubFramePassback,
                data: {
                    type: 'push',
                    data: items
                }
            });
        }
        catch (ex) {
            //meh
        }
    };
    //stop all churnzero functionality
    ChurnZeroApp.prototype.stop = function () {
        //flush
        this.commSvc.flush();
        //reset the contact
        this.tenantSvc.resetContact();
        // Clear cookie/session storage account & contact info
        this.commSvc.contactKey = null;
        this.commSvc.accountHash = null;
        this.commSvc.contactHash = null;
        //halt the app
        this.halt();
    };
    //Track an event that occurred in the UI
    ChurnZeroApp.prototype.trackEvent = function (eventName, description, quantity, customFields) {
        this.eventSvc.TrackEvent(eventName, description, quantity, customFields);
    };
    //Set an attribute about the current User
    ChurnZeroApp.prototype.setAttribute = function (entity, name, value) {
        this.attributeSvc.SetAttribute(entity, name, value);
    };
    //Increment an attribute about the current User
    ChurnZeroApp.prototype.incrementAttribute = function (entity, name, value) {
        this.attributeSvc.IncrementAttribute(entity, name, value);
    };
    //Set current Module for tracking purposes
    ChurnZeroApp.prototype.setModule = function (module) {
        if (this.isMainFrame) {
            this.wasModuleSet = true;
            this.sessionSvc.SetModule(module);
        }
        else {
            this.pushToMain(['setModule', module]);
        }
    };
    //Set Silent mode for force hiding the panel
    ChurnZeroApp.prototype.setSilent = function (isSilent) {
        this.sessionSvc.SetSilent(isSilent);
        this._appMarshal.setSilent(isSilent);
        if (isSilent) {
            this.unloadHerald();
        }
        else if (!this._herald) {
            this.loadHerald();
        }
    };
    //Set  URL Tracking Flag
    ChurnZeroApp.prototype.setUrlTracking = function (enabled) {
        this.commSvc.urlTracking = enabled;
    };
    //Set Connection Domain
    ChurnZeroApp.prototype.setConnectionDomain = function (connectionDomain) {
        if (clientlibs_2.CoreUtils.Strings.isNullOrEmpty(connectionDomain)) {
            this.applicationSvc.debug('Could not set connection domain to empty string');
            return;
        }
        this.applicationSvc.debug('Setting connection domain to ', connectionDomain);
        this.windowSvc.czHost = connectionDomain;
        //reparse the urls based on what was set
        this.applicationSvc.setupClientSideUrls();
        this.windowSvc.addOrigin(this.windowSvc.clientSideUrls.baseApiUrl.slice(0, -1));
        //if isConnected, disconnect and reconnect
        /*if (this.commSvc.isConnected()) {

            /!*!//add post message listener for frame communication
            if (this.applicationSvc.removeFrameComListener) {
                this.applicationSvc.removeFrameComListener();
            }
            this.applicationSvc.addFrameComListener();*!/

            //wire up initial connection listener
            this.subIds['initialConnectionSubId'] = this.commSvc.registerListener(Enums.SocketMessageTypes.SOCKETMESSAGETYPE_INITIAL_CONNECTION, (message: PubSubMessage<SocketIoInitialConnection>) => {
                try {
                    this.onInitialConnectionHandler(message.info);
                }
                catch (ex) {
                    //report?
                    ErrorLogger.report("ChurnZeroApp.setConnectionDomain.initialConnectionSub", ex);
                }
            });
            this.initConnection();
        }*/
    };
    //set panel state
    ChurnZeroApp.prototype.openPanel = function () {
        if (!this.isMainFrame) {
            return;
        }
        this._appMarshal.openSuccessPanel();
    };
    ChurnZeroApp.prototype.closePanel = function () {
        if (!this.isMainFrame) {
            return;
        }
        this._appMarshal.closeSuccessPanel();
    };
    ChurnZeroApp.prototype.triggerWalkthrough = function (id) {
        if (!this.tenantSvc.FeatureEnabled(tenant_service_1.FeatureFlags.Walkthroughs)) {
            return;
        }
        if (!id) {
            return;
        }
        //dont track events or engage walkthroughs if the devless panel enabled
        if (this.sessionSvc.ShouldPreventUsageSends) {
            return;
        }
        var walkthrough = undefined;
        for (var i = 0; i < this.walkthroughSvc.walkthroughs.length; i++) {
            var w = this.walkthroughSvc.walkthroughs[i];
            if (w && w.id === id) {
                walkthrough = w;
                break;
            }
        }
        if (walkthrough === undefined) {
            return;
        }
        //for now dont worry about checking the pageTag enabled state or if it matches
        this.applicationSvc.pubsub.publish(clientlibs_1.ChurnZeroAppEvents.WalkthroughStart, walkthrough);
    };
    //churnzero event callbacks
    ChurnZeroApp.prototype.registerChurnZeroEventCallback = function (type, callback) {
        //verify input
        if (!type || typeof type !== 'string' || !callback || typeof callback !== 'function') {
            return;
        }
        type = type.toLowerCase();
        if (!this.eventHandlers || !clientlibs_2.CoreUtils.hasOwnProp(this.eventHandlers, type)) {
            return;
        }
        this.eventHandlers[type].push(callback);
        //if its already connected call the callback immediately
        if (type === 'connected' && this.isRunning) {
            callback(this.getEventHandlerData(type));
        }
    };
    ChurnZeroApp.prototype.deregisterChurnZeroEventCallback = function (type, callback) {
        if (!type || typeof type !== 'string') {
            return;
        }
        type = type.toLowerCase();
        if (!this.eventHandlers || !clientlibs_2.CoreUtils.hasOwnProp(this.eventHandlers, type) || this.eventHandlers[type].length) {
            return;
        }
        //remove all
        if (clientlibs_2.CoreUtils.isNullOrUndefined(callback)) {
            this.eventHandlers[type].splice(0);
            return;
        }
        //remove specific callback
        var i = this.eventHandlers[type].indexOf(callback);
        if (i >= 0) {
            this.eventHandlers[type].splice(i, 1);
        }
    };
    //testing content
    ChurnZeroApp.prototype.testAnnouncement = function (type, message, includeInPanel, config, styleConfig, sequence, metaData) {
        if (this._herald) {
            this._herald.TestAnnouncement(type, message, includeInPanel, config, styleConfig, sequence, metaData);
        }
    };
    ChurnZeroApp.prototype.updateAnnouncement = function (type, message, includeInPanel, config, styleConfig, sequence, metaData) {
        if (this._herald) {
            this._herald.UpdateAnnouncement(type, message, includeInPanel, config, styleConfig, sequence, metaData);
        }
    };
    ChurnZeroApp.prototype.hideAnnouncement = function () {
        if (this._herald) {
            this._herald.HideAnyAnnouncement();
        }
    };
    ChurnZeroApp.prototype.replayAnnouncement = function (id, position) {
        if (this._herald) {
            this._herald.ReplayAnnouncement(id, position);
        }
    };
    ChurnZeroApp.prototype.testWalkthrough = function (walkthrough, metaData) {
        if (this._herald) {
            this._herald.TestWalkthrough(walkthrough, metaData);
        }
    };
    ChurnZeroApp.prototype.testClearAll = function () {
        if (this._herald) {
            this._herald.TestClearAll();
        }
    };
    /********************
     * Core Functionality
     *********************/
    //initializes kernel functionality
    ChurnZeroApp.prototype.preStartLoad = function (config) {
        var _a;
        //Set Feature Flags
        this.tenantSvc.setFeatureFlags(config.featureFlags);
        //Set the tenant data
        this.tenantSvc.setTenantId(config.tenantId);
        //Load contact data if not already present
        var currentContact = this.tenantSvc.contact;
        currentContact.id = config.contact.id;
        this.tenantSvc.SetContact(currentContact);
        this.tenantSvc.SetUIFontFamilyMapping(config.uiFontFamilyMapping);
        //Load Events Map
        this.eventSvc.LoadEventMapConfig(config.eventMapConfig);
        //Load Page Tags
        this.pagetagSvc.LoadPageTagConfig(config.pageTagConfig);
        //Load Walkthroughs
        this.walkthroughSvc.LoadWalkthroughConfig(config.walkthroughConfig);
        // Seed Checklist
        if (this.tenantSvc.FeatureEnabled(tenant_service_1.ReleaseGates.JourneyChecklistReleased) && config.journeyChecklistConfig)
            this.checklistSvc.SeedData(config.journeyChecklistConfig);
        //Ensure Success Center Click To See More Text is used for annoucnement closings
        if (this.tenantSvc.FeatureEnabled(tenant_service_1.ReleaseGates.SuccessCentersReleased) && ((_a = this.sessionSvc.SuccessCenterConfig) === null || _a === void 0 ? void 0 : _a.clickToSeeMoreText)) {
            this.sessionSvc.CurrentAccountContent.clickToSeeMoreText = this.sessionSvc.SuccessCenterConfig.clickToSeeMoreText;
        }
    };
    ChurnZeroApp.prototype.startKernel = function () {
        var _this = this;
        var _a;
        //if the app is already running don't start again
        if (this.isRunning) {
            this.applicationSvc.debug('Attempted to start but was already running.');
            return;
        }
        //reset the Kernel
        //if there is a digestInterval already clear it
        try {
            if (this.digestIntervalTimer) {
                this.windowSvc.window.clearInterval(this.digestIntervalTimer);
                this.digestIntervalTimer = null;
            }
        }
        catch (ex) {
            errorLogger_1.default.report('_ChurnZeroApp.startKernel.clearDigestInterval', ex);
            return;
        }
        this.applicationSvc.debug('Kernel Started');
        try {
            //Check DB state
            this.dbDisconnected = false;
            var currentContact = this.tenantSvc.contact;
            if (currentContact && clientlibs_2.CoreUtils.hasOwnProp(currentContact, 'id') && currentContact.id !== null) {
                this.dbDisconnected = currentContact.id.toString() === '0';
                this.dbMigrating = currentContact.id.toString() === '-1';
            }
            this.lastReconnectPing = this.windowSvc.Date.now();
        }
        catch (ex) {
            errorLogger_1.default.report('_ChurnZeroApp.startKernel.checkDBState', ex);
            return;
        }
        //load any new app objects here:
        try {
            this.loadEventSpider();
        }
        catch (ex) {
            errorLogger_1.default.report('_ChurnZeroApp.startKernel.loadEventSpider', ex);
            return;
        }
        try {
            this.loadPageMonitor();
        }
        catch (ex) {
            errorLogger_1.default.report('_ChurnZeroApp.startKernel.loadPageMonitor', ex);
            return;
        }
        if (this.isMainFrame) {
            if (!this.dbDisconnected && !this.dbMigrating) {
                try {
                    this.loadApplicationMarshal();
                }
                catch (ex) {
                    errorLogger_1.default.report('_ChurnZeroApp.startKernel.loadApplicationMarshal', ex);
                    return;
                }
            }
            try {
                this.loadActivityMonitor();
            }
            catch (ex) {
                errorLogger_1.default.report('_ChurnZeroApp.startKernel.loadActivityMonitor', ex);
                return;
            }
            try {
                this.loadHerald();
            }
            catch (ex) {
                errorLogger_1.default.report('_ChurnZeroApp.startKernel.loadHerald', ex);
                return;
            }
        }
        //tell everyone to start their engines
        try {
            this.applicationSvc.pubsub.publish(clientlibs_1.ChurnZeroAppEvents.START);
            (_a = this._activityMonitor) === null || _a === void 0 ? void 0 : _a.Start();
        }
        catch (ex) {
            errorLogger_1.default.report('_ChurnZeroApp.startKernel.publishStart', ex);
            return;
        }
        try {
            //set contact active status
            this.sessionSvc.triggerHeartbeat(this.isMainFrame);
        }
        catch (ex) {
            errorLogger_1.default.report('_ChurnZeroApp.startKernel.triggerHeartbeat', ex);
            return;
        }
        try {
            //setup the digest cycle
            // set to 2 seconds so unread messages are evaluated
            this.digestIntervalTimer = setInterval(function () {
                try {
                    _this.digestInterval();
                }
                catch (ex) {
                    //meh
                }
            }, 2000);
        }
        catch (ex) {
            errorLogger_1.default.report('_ChurnZeroApp.startKernel.digestInterval', ex);
        }
        this.isRunning = true;
    };
    //kernel loop
    ChurnZeroApp.prototype.digestInterval = function () {
        //console.info((this.isMainFrame ? "" : "iFrame ") + "Digest Interval");
        //if someone tried to dispose of the ChurnZeroObject without calling stop first
        // halt the instance to clean everything up
        if (this.windowSvc.wasDisposed()) {
            console.log('Was Disposed');
            this.halt();
            return;
        }
        //if unacceptable location, halt the app
        if (!this.windowSvc.isAcceptableLocation()) {
            this.halt();
            return;
        }
        //try to reconnect to the db
        if (this.isMainFrame && (this.dbDisconnected || this.dbMigrating) && +this.windowSvc.Date.now() - +this.lastReconnectPing > (this.reconnectAttemptInterval)) {
            this.lastReconnectPing = this.windowSvc.Date.now();
            this.initConnection();
        }
        if (this.isMainFrame) {
            //ping back that user is active still
            this.sessionSvc.triggerHeartbeat(this.isMainFrame);
        }
        //keep track of last digest time for more accurate module recordings
        this.sessionSvc.SetLastDigestTimestamp();
        //call any registered digest functions
        this.applicationSvc.pubsub.publish(clientlibs_1.ChurnZeroAppEvents.DIGEST);
    };
    //connect to the ChurnZero server
    ChurnZeroApp.prototype.initConnection = function () {
        var _this = this;
        if (this.isConnecting) {
            console.info('already connecting...');
            return;
        }
        if (!this.isMainFrame) {
            console.info('Not Main Frame so no need for connection.(initConnection)');
            return;
        }
        if (!this.subIds['initialConnectionSubId']) {
            //setup the server response handlers
            //wire up initial connection listener
            this.subIds['initialConnectionSubId'] = this.commSvc.registerListener(Enums_1.Enums.SocketMessageTypes.SOCKETMESSAGETYPE_INITIAL_CONNECTION, function (message) {
                try {
                    _this.onInitialConnectionHandler(message.info);
                }
                catch (ex) {
                    //report?
                    errorLogger_1.default.report('ChurnZeroApp.initConnection.initialConnectionSub', ex);
                }
            });
        }
        console.info('New connection requested');
        //make sure any hash change event setup for login redirect is turned off
        if (this.hashHandler) {
            this.hashHandler.Stop();
            this.hashHandler = null;
        }
        var acceptableLocation = this.windowSvc.isAcceptableLocation(), validContactKey = this.commSvc.isContactKeyValid(this.commSvc.contactKey), validAppKey = this.commSvc.isAppKeyValid(this.commSvc.appKey);
        if (acceptableLocation && validContactKey && validAppKey) {
            //disconnect from socket
            this.commSvc.disconnect();
            //locking connection
            this.isConnecting = true;
            this.applicationSvc.debug("Connecting - from: " + this.windowSvc.href() + " to: " + this.windowSvc.clientSideUrls.baseApiUrl);
            //connect new socket
            try {
                this.commSvc.connect(this.windowSvc.socketServerApiUrl, function (initialConnection) {
                    var _a;
                    _this.applicationSvc.debug('Connection Success');
                    //unlock connecting
                    _this.isConnecting = false;
                    //if a specific domain was not set prior to boot
                    // check for a connectionDomain and if so prevent the initialConnection from triggering
                    if (!_this.wasDomainSet && initialConnection.connectionDomain && initialConnection.connectionDomain !== _this.windowSvc.clientSideUrls.baseApiUrl) {
                        _this.setConnectionDomain(initialConnection.connectionDomain);
                        var cId = (((_a = initialConnection.contact) !== null && _a !== void 0 ? _a : { id: '' }).id || '').toString();
                        //implies that the connection was from the wrong region so we need to reconnect
                        if (cId === '-3') {
                            _this.initConnection();
                            return false;
                        }
                        if (cId === '-4') {
                            //Connection should be forced to be on vanity domain
                            //unlocking connection
                            _this.isConnecting = false;
                            window['console']['error']("Please Use The Domain '" + initialConnection.connectionDomain + "' For Loading The ChurnZero JS");
                            return false;
                        }
                        return _this.windowSvc.socketServerApiUrl;
                    }
                }, function (initialConnection) {
                    var _a;
                    _this.applicationSvc.debug('Connect Status Check');
                    //if a specific domain was not set prior to boot
                    // check for a connectionDomain and if so prevent the initialConnection from triggering
                    if (!_this.wasDomainSet && initialConnection.connectionDomain && initialConnection.connectionDomain !== _this.windowSvc.clientSideUrls.baseApiUrl) {
                        _this.setConnectionDomain(initialConnection.connectionDomain);
                        var cId = (((_a = initialConnection.contact) !== null && _a !== void 0 ? _a : { id: '' }).id || '').toString();
                        //implies that the connection was from the wrong region so we need to reconnect
                        if (cId === '-3') {
                            //unlocking connection
                            _this.isConnecting = false;
                            _this.initConnection();
                            return false;
                        }
                        if (cId === '-4') {
                            //Connection should be forced to be on vanity domain
                            //unlocking connection
                            _this.isConnecting = false;
                            window['console']['error']("Please Use The Domain '" + initialConnection.connectionDomain + "' For Loading The ChurnZero JS");
                            return false;
                        }
                        return _this.windowSvc.socketServerApiUrl;
                    }
                }, function () {
                    _this.applicationSvc.debug('Error Connecting');
                    //unlock connecting
                    _this.isConnecting = false;
                });
            }
            catch (e) {
                this.isConnecting = false;
            }
            //If it is not an acceptable location (Login/Logout/etc)
            // setup an on UrlChange handler to try to init
            // when the page changes
        }
        else if (!acceptableLocation) {
            this.hashHandler = new HashHandler_1.default(this.initConnection.bind(this), true);
        }
    };
    ChurnZeroApp.prototype.onInitialConnectionHandler = function (initialConnection) {
        var _this = this;
        //setup all of our services with
        // data from the server passed in on the
        // initial connection
        this.removeSubById('initialConnectionSubId');
        //Set Functionality Enabled Flags
        this.sessionSvc.SetFunctionality(initialConnection.functionality);
        //Set Success Center config
        this.sessionSvc.SetSuccessCenterConfig(initialConnection.successCenterConfig);
        //initialize the unread counts
        if (this.sessionSvc.SuccessCenterConfig) {
            this.sessionSvc.SuccessCenterConfig.unreadCounts['announcements'] = initialConnection.announcements.filter(function (a) { return !a.isRead && !_this.messageSvc.isSurveyAnnouncement(a); }).length || 0;
            this.sessionSvc.SuccessCenterConfig.unreadCounts['surveys'] = initialConnection.announcements.filter(function (a) { return !a.isRead && _this.messageSvc.isSurveyAnnouncement(a); }).length || 0;
        }
        this.applicationSvc.WebAppDomain = initialConnection.webAppDomain || this.windowSvc.clientSideUrls.baseApiUrl;
        if (this.applicationSvc.WebAppDomain) {
            this.windowSvc.addOrigin(this.applicationSvc.WebAppDomain.slice(0, -1));
            //rebind with webapp domain message listener for frame communication
            if (this.applicationSvc.removeFrameComListener) {
                this.applicationSvc.removeFrameComListener();
            }
            this.applicationSvc.addFrameComListener();
        }
        //Set Account Specific Content
        this.sessionSvc.SetAccountContent(initialConnection.functionality);
        if (this.sessionSvc.HasAccountOwner) {
            this.tenantSvc.setAccountOwner(initialConnection.contact.userAccount);
        }
        //Load seed data to services
        this.messageSvc.SeedAnnouncements(initialConnection.announcements);
        var preStartConfig = {
            tenantId: initialConnection.tenantId.toString(),
            contact: initialConnection.contact,
            featureFlags: initialConnection.featureFlags,
            eventMapConfig: initialConnection.eventMapConfig,
            pageTagConfig: initialConnection.pageTagConfig,
            walkthroughConfig: initialConnection.walkthroughConfig,
            uiFontFamilyMapping: initialConnection.uiFontFamilyMapping,
            journeyChecklistConfig: initialConnection.journeyChecklistConfig
        };
        //tell any sub-frames that are halted to start again
        this.applicationSvc.messageSubFrames({
            code: Enums_1.Enums.FrameCommCodes.MainFramePassdown,
            data: {
                code: clientlibs_1.ChurnZeroAppEvents.START,
                data: preStartConfig
            }
        });
        this.preStartLoad(preStartConfig);
        //start up the kernel
        try {
            this.startKernel();
        }
        catch (ex) {
            errorLogger_1.default.report('_ChurnZeroApp.startKernel', ex);
        }
        this.triggerEventHandlers('connected');
    };
    /**
     * Object Loaders
     */
    ChurnZeroApp.prototype.loadEventSpider = function () {
        // reset if previously existed
        this.unloadEventSpider();
        this._eventSpider = new EventSpider_1.default(this.applicationSvc, this.tenantSvc, this.eventSvc, this.walkthroughSvc, this.windowSvc, this.commSvc, this.sessionSvc);
    };
    ChurnZeroApp.prototype.unloadEventSpider = function () {
        if (this._eventSpider) {
            this._eventSpider.Stop();
            this._eventSpider = null;
        }
    };
    ChurnZeroApp.prototype.loadPageMonitor = function () {
        var _this = this;
        var lastUrl = this.windowSvc.href().toString();
        var monitorPageFunction = function () {
            try {
                var currentUrl = (_this.windowSvc.href() || '').toString();
                if (lastUrl === currentUrl) {
                    console.log('Same Url');
                    return;
                }
                lastUrl = currentUrl;
                //At this point we know the page changed
                _this.checkUrlAgainstPageTags(lastUrl);
                if (_this._herald) {
                    _this._herald.CheckForWalkthroughAnchors();
                    _this._herald.CompletelyAbandonAnyCurrentWalkthrough();
                }
                _this.checkUrlAgainstWalkthroughs(lastUrl);
                if (_this.isMainFrame && _this._appMarshal && _this._appMarshal.DevlessPanel) {
                    _this.applicationSvc.pubsub.publish(Enums_1.Enums.DevlessEvents.DevlessCurrentHref);
                }
            }
            catch (ex) {
                //report?
                errorLogger_1.default.report('ChurnZeroApp.loadPageMonitor', ex);
            }
        };
        //monitor hashchanges
        this.pageMonitorUrlChangeHandler = new UrlChangeHandler_1.default(monitorPageFunction, false, 500);
        //monitor history api
        this.windowSvc.window.addEventListener('popstate', monitorPageFunction, true);
        //check current url
        this.checkUrlAgainstPageTags(this.windowSvc.href());
        //wait for the panel to be ready then check for walkthroughs
        this.applicationSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.PanelReady, function () {
            _this.checkUrlAgainstWalkthroughs(_this.windowSvc.href());
        });
        //have the pagetag service evaluate if it should ping for an update
        this.applicationSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.DIGEST, function () {
            _this.pagetagSvc.RefreshPageTagConfig();
        });
        //respond to the server telling the client it has a new pagtagconfig to load
        this.commSvc.registerListener(Enums_1.Enums.SocketMessageTypes.SOCKETMESSAGETYPE_RefreshPageTagConfig, function (message) {
            _this.applicationSvc.debug('Updated PageTag Config Received', message.info);
            _this.pagetagSvc.LoadPageTagConfig(message.info);
        });
        // TODO: register pubsub subscriber on DIGEST event to check the checklist config (CheckChecklistConfig)
        // TODO: register comm listener here to load up checklist configs (RefreshChecklistConfig)
    };
    ChurnZeroApp.prototype.loadHerald = function () {
        var _this = this;
        // Don't load herald if we are in silent mode
        if (this.sessionSvc.IsSilent) {
            return;
        }
        this._herald = new Herald_1.default(this.applicationSvc, this.tenantSvc, this.sessionSvc, this.messageSvc, this.walkthroughSvc, this.windowSvc, this.commSvc, this.templateCache);
        /** Load announcement styles explicitly. **/
        var styleUrl = this.applicationSvc.addCdn('css/announcements.css'), link = this.windowSvc.createElement('link');
        link.id = CZ_ANNOUNCEMENT_STYLES_ID;
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = styleUrl;
        link.onload = function () {
            // Since we don't have a panel, manually check check current URL for WT firing
            setTimeout(function () {
                _this.checkUrlAgainstWalkthroughs(_this.windowSvc.href());
            }, 500);
        };
        this.windowSvc.document.getElementsByTagName('head')[0].appendChild(link);
    };
    ChurnZeroApp.prototype.unloadHerald = function () {
        // Remove the link from the DOM (if applicable)
        var announcementStyles = this.windowSvc.document.getElementById(CZ_ANNOUNCEMENT_STYLES_ID);
        // Old-school node removal, because IE
        if (announcementStyles && announcementStyles.parentNode) {
            announcementStyles.parentNode.removeChild(announcementStyles);
        }
        if (this._herald) {
            this._herald.onHalt();
            this._herald = null;
        }
    };
    ChurnZeroApp.prototype.loadApplicationMarshal = function () {
        this._appMarshal = new ApplicationMarshal_1.ApplicationMarshal(this.windowSvc, this.applicationSvc, this.commSvc, this.sessionSvc, this.storageSvc, this.tenantSvc, this.messageSvc, this.eventSvc, this.walkthroughSvc, this.checklistSvc, this.templateCache);
    };
    ChurnZeroApp.prototype.unloadApplicationMarshal = function () {
        if (!this._appMarshal)
            return;
        this._appMarshal.stop();
        this._appMarshal = null;
    };
    ChurnZeroApp.prototype.checkUrlAgainstPageTags = function (url) {
        if (!this.tenantSvc.FeatureEnabled(tenant_service_1.FeatureFlags.PageTags)) {
            return;
        }
        if (clientlibs_2.CoreUtils.Strings.isNullOrEmpty(url)) {
            return;
        }
        this.checkPageTagExitModule();
        if (this.pagetagSvc.pageTags) {
            for (var i = 0; i < this.pagetagSvc.pageTags.length; i++) {
                var pageTag = this.pagetagSvc.pageTags[i];
                //skip disabled page tags
                if (!pageTag.disabled) {
                    if (clientlibs_2.CoreUtils.Urls.checkUrlAgainstPageTag(url, pageTag)) {
                        this.applicationSvc.debug('[Devless Page Tagging]', 'Page Tag Active:', pageTag.pageName);
                        if (pageTag.shouldFireEvent) {
                            this.applicationSvc.debug('[Devless Page Tagging]', 'Track Event:', pageTag.eventName);
                            this.trackEvent(pageTag.eventName);
                        }
                        if (pageTag.shouldSetModule) {
                            this.applicationSvc.debug('[Devless Page Tagging]', 'Set Module:', pageTag.moduleName);
                            this.setModule(pageTag.moduleName);
                        }
                        this.lastPageTag = pageTag;
                    }
                }
            }
        }
    };
    ChurnZeroApp.prototype.checkPageTagExitModule = function () {
        //since we default shouldSetExitModule to true we need to check if shouldSetModule is also true
        // so that we are only setting the exit module when the entry module was set
        if (this.lastPageTag && this.lastPageTag.shouldSetModule && this.lastPageTag.shouldSetExitModule) {
            this.applicationSvc.debug('[Devless Page Tagging]', 'Set Exit Module:', this.lastPageTag.exitModuleName);
            this.setModule(this.lastPageTag.exitModuleName);
            this.lastPageTag = null;
        }
    };
    ChurnZeroApp.prototype.checkUrlAgainstWalkthroughs = function (url) {
        if (!this.tenantSvc.FeatureEnabled(tenant_service_1.FeatureFlags.Walkthroughs)) {
            return;
        }
        //dont track events or engage walkthroughs if the devless panel enabled
        if (this.sessionSvc.ShouldPreventUsageSends) {
            return;
        }
        var pageVisitWalkthroughs = this.walkthroughSvc.GetPageVisitWalkthroughs();
        for (var i = 0; i < pageVisitWalkthroughs.length; i++) {
            var walkthrough = pageVisitWalkthroughs[i];
            var pageTag = walkthrough.pageTag;
            var locationOptions = undefined;
            if (!pageTag.disabled) {
                if (pageTag.locationOptionsJson === null || pageTag.locationOptionsJson === undefined || !pageTag.isCustomLocation) {
                    locationOptions = new clientlibs_2.LocationOptions(clientlibs_2.CoreUtils.Urls.parseUrlToLocationParts(pageTag.location));
                    if (!pageTag.isCustomLocation && !(pageTag.locationOptionsJson === null || pageTag.locationOptionsJson === undefined)) {
                        var parsedOptions = clientlibs_2.LocationOptions.fromJson(pageTag.locationOptionsJson);
                        locationOptions.allowChildPaths = parsedOptions.allowChildPaths;
                        locationOptions.allowChildStates = parsedOptions.allowChildStates;
                        locationOptions.excludeSearchParts = parsedOptions.excludeSearchParts;
                    }
                }
                else {
                    locationOptions = clientlibs_2.LocationOptions.fromJson(pageTag.locationOptionsJson, this.windowSvc.JSON);
                }
                var regExString = clientlibs_2.CoreUtils.Urls.buildRegexFromLocationParts(pageTag.location, locationOptions);
                var regEx = new RegExp(regExString);
                if (url.match(regEx)) {
                    this.applicationSvc.pubsub.publish(clientlibs_1.ChurnZeroAppEvents.WalkthroughStart, walkthrough);
                }
            }
        }
    };
    ChurnZeroApp.prototype.loadActivityMonitor = function () {
        var _this = this;
        if (!this.isMainFrame) {
            return;
        }
        //reset if previously existed
        this.unloadActivityMonitor();
        var timeoutOverride = undefined;
        try {
            if (this.applicationSvc.isDebugging) {
                var overrideString = sessionStorage.getItem('czActivityMonitorTimeoutMS');
                if (overrideString) {
                    timeoutOverride = parseInt(overrideString, 10);
                }
            }
        }
        catch (ex) {
            //meh - GD
        }
        this._activityMonitor = new clientlibs_1.ActivityMonitor(this.windowSvc.window, errorLogger_1.default, timeoutOverride);
        var onIdleCallback = function () {
            _this.sessionSvc.SetModuleActivityInactive();
            _this.sessionSvc.triggerHeartbeat(_this.isMainFrame);
            _this.commSvc.setPollInterval(300000);
            _this.applicationSvc.debug('%cCZE Frame ActivityMonitor is idle...', 'color: orange');
        };
        var onActiveCallback = function () {
            _this.sessionSvc.SetModuleActivityActive();
            _this.sessionSvc.triggerHeartbeat(_this.isMainFrame);
            _this.commSvc.resetPollIntervalToDefault();
            _this.applicationSvc.debug('%cCZE Frame ActivityMonitor is active...', 'color: green');
        };
        var doIdleCallbackIfNoneActive = function () {
            if (_this._activityMonitor.isActive() || _this.doAnyActiveActivityMonitorsExist())
                return;
            // There are no active Activity Monitors (including this one). We can go idle
            onIdleCallback();
        };
        this._activityMonitor.addActiveCallback(onActiveCallback);
        this._activityMonitor.addIdleCallback(onIdleCallback);
        this._activityMonitor.addIdlePrecheck(this.doAnyActiveActivityMonitorsExist);
        // Subscribe to other ActivityMonitor "Active" events
        this.subIds['activityMonitorActiveSubId'] = this.applicationSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.ActivityMonitorActive, function (msg) {
            var _a;
            var theId = (_a = msg === null || msg === void 0 ? void 0 : msg.info) === null || _a === void 0 ? void 0 : _a.id;
            if (!theId)
                return;
            _this.activityMonitorMapping[theId] = true;
            // One of our activity monitors is active. We can go active
            if (!_this._activityMonitor.isActive())
                onActiveCallback();
        });
        // Subscribe to other ActivityMonitor "Idle" events
        this.subIds['activityMonitorIdleSubId'] = this.applicationSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.ActivityMonitorIdle, function (msg) {
            var _a;
            var theId = (_a = msg === null || msg === void 0 ? void 0 : msg.info) === null || _a === void 0 ? void 0 : _a.id;
            if (!theId)
                return;
            _this.activityMonitorMapping[theId] = false;
            doIdleCallbackIfNoneActive();
        });
        // Subscribe to other ActivityMonitor "Halt" events
        this.subIds['activityMonitorHaltSubId'] = this.applicationSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.ActivityMonitorHalt, function (msg) {
            var _a;
            var theId = (_a = msg === null || msg === void 0 ? void 0 : msg.info) === null || _a === void 0 ? void 0 : _a.id;
            delete _this.activityMonitorMapping[theId];
            doIdleCallbackIfNoneActive();
        });
        if (!this.wasModuleSet) {
            this.sessionSvc.SetModule('Default');
        }
    };
    ChurnZeroApp.prototype.doAnyActiveActivityMonitorsExist = function () {
        for (var prop in this.activityMonitorMapping) {
            if (clientlibs_2.CoreUtils.hasOwnProp(this.activityMonitorMapping, prop) && this.activityMonitorMapping[prop] === true)
                return true;
        }
        return false;
    };
    ChurnZeroApp.prototype.unloadActivityMonitor = function () {
        if (this._activityMonitor) {
            this._activityMonitor.Stop();
            this._activityMonitor = null;
        }
    };
    // noinspection JSMethodCanBeStatic
    ChurnZeroApp.prototype.loadTemplates = function () {
        this.templateCache.announcementNpsTemplate = __webpack_require__(/*! ../templateCache/announcementNpsTemplate.html */ "./src/templateCache/announcementNpsTemplate.html");
        this.templateCache.announcementNpsTemplatePanel = __webpack_require__(/*! ../templateCache/announcementNpsTemplatePanel.html */ "./src/templateCache/announcementNpsTemplatePanel.html");
        this.templateCache.announcementSurveyButtonTemplate = __webpack_require__(/*! ../templateCache/announcementSurveyButtonTemplate.html */ "./src/templateCache/announcementSurveyButtonTemplate.html");
        this.templateCache.announcementSurveyButtonSpacerTemplate = __webpack_require__(/*! ../templateCache/announcementSurveyButtonSpacerTemplate.html */ "./src/templateCache/announcementSurveyButtonSpacerTemplate.html");
        this.templateCache.announcementSurveyCustomTemplate = __webpack_require__(/*! ../templateCache/announcementSurveyCustomTemplate.html */ "./src/templateCache/announcementSurveyCustomTemplate.html");
        this.templateCache.announcementSliderTemplate = __webpack_require__(/*! ../templateCache/announcementSliderTemplate.html */ "./src/templateCache/announcementSliderTemplate.html");
        this.templateCache.announcementTemplate = __webpack_require__(/*! ../templateCache/announcementTemplate.html */ "./src/templateCache/announcementTemplate.html");
        this.templateCache.avatarImageTemplate = __webpack_require__(/*! ../templateCache/avatarImageTemplate.html */ "./src/templateCache/avatarImageTemplate.html");
        this.templateCache.avatarInitialsTemplate = __webpack_require__(/*! ../templateCache/avatarInitialsTemplate.html */ "./src/templateCache/avatarInitialsTemplate.html");
        this.templateCache.messageBubbleTemplate = __webpack_require__(/*! ../templateCache/messageBubbleTemplate.html */ "./src/templateCache/messageBubbleTemplate.html");
        this.templateCache.popoverContainerTemplate = __webpack_require__(/*! ../templateCache/popoverContainerTemplate.html */ "./src/templateCache/popoverContainerTemplate.html");
    };
    ChurnZeroApp.prototype.setupInstanceServices = function () {
        this.sessionSvc = new session_service_1.default(this.storageSvc, this.commSvc, this.applicationSvc, this.tenantSvc, this.windowSvc);
        this.messageSvc = new message_service_1.default(this.commSvc, this.windowSvc, this.storageSvc);
        this.eventSvc = new event_service_1.default(this.commSvc, this.windowSvc, this.applicationSvc, this.sessionSvc);
        this.pagetagSvc = new pagetag_service_1.default(this.commSvc, this.windowSvc, this.applicationSvc, this.sessionSvc);
        this.walkthroughSvc = new walkthrough_service_1.default(this.commSvc, this.windowSvc, this.applicationSvc, this.sessionSvc);
        this.attributeSvc = new attribute_service_1.default(this.commSvc, this.sessionSvc);
        this.checklistSvc = new checklist_service_1.ChecklistService(this.windowSvc, this.commSvc);
    };
    ChurnZeroApp.prototype.removeSubById = function (subId) {
        if (this.subIds[subId]) {
            this.subIds[subId].remove();
            this.subIds[subId] = undefined;
        }
    };
    ChurnZeroApp.prototype.triggerEventHandlers = function (eventHandlerType) {
        try {
            if (!this.eventHandlers[eventHandlerType]) {
                return;
            }
            for (var i = 0; i < this.eventHandlers[eventHandlerType].length; i++) {
                var onEventFn = this.eventHandlers[eventHandlerType][i];
                if (typeof onEventFn === 'function') {
                    try {
                        onEventFn(this.getEventHandlerData(eventHandlerType));
                    }
                    catch (ex) {
                        //eh
                    }
                }
            }
        }
        catch (ex) {
            errorLogger_1.default.report('_ChurnZeroApp.eventHandlersTrigger', ex);
        }
    };
    ChurnZeroApp.prototype.getEventHandlerData = function (eventHandlerType) {
        var data = undefined;
        switch (eventHandlerType) {
            case 'connected':
                data = { hasPanel: this.sessionSvc.PanelEnabled };
                break;
        }
        return data;
    };
    return ChurnZeroApp;
}());
exports["default"] = ChurnZeroApp;


/***/ }),

/***/ "./src/core/errorLogger.ts":
/*!*********************************!*\
  !*** ./src/core/errorLogger.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var http_service_1 = __importDefault(__webpack_require__(/*! @src/services/http.service */ "./src/services/http.service.ts"));
var ErrorLogger = /** @class */ (function () {
    function ErrorLogger(reportUrl, coder, dateConstructor) {
        this.reportUrl = reportUrl;
        this.coder = coder;
        this.dateConstructor = dateConstructor;
        this.throttleSet = null;
        this.throttleTime = 30 * 1000;
        //AppVersion
        this._appVersion = "localhost-2022-04-22T18:09:03.829Z"; //gets replaced by build task
        if (!this.reportUrl) {
            var src = clientlibs_1.CoreUtils.Urls.getChurnZeroScriptSrc(document);
            if (src) {
                this.reportUrl = clientlibs_1.CoreUtils.Urls.buildClientSideUrls(src).sockets;
            }
            else {
                this.reportUrl = '';
            }
        }
        if (!this.dateConstructor) {
            this.dateConstructor = Date;
        }
        if (!this.coder) {
            this.coder = { encode: JSON.stringify, decode: JSON.parse };
        }
        this.httpService = new http_service_1.default(this.coder);
    }
    /**
     * Add a new instance of ErrorLogger to the window object if it doesnt already exist or reset is true
     * @param reportUrl
     * @param reset
     */
    ErrorLogger.initLogger = function (reportUrl, reset) {
        if (reset === void 0) { reset = false; }
        if (reset || !window['__tracerCZ']) {
            window['__tracerCZ'] = new ErrorLogger(reportUrl);
        }
    };
    ErrorLogger.report = function (code, exception, extraInfo) {
        ErrorLogger.initLogger(""); //__CZHost__ gets set during build process
        //dont log freed script errors as they can occur when page navigates or is closed
        if (ErrorLogger.isFreedScriptError(exception)) {
            return;
        }
        if (ErrorLogger.isJSONRefError(exception)) {
            extraInfo = extraInfo || {};
            extraInfo['JSONRefInfo'] = true;
            try {
                extraInfo['docType'] = window.document.doctype.systemId;
            }
            catch (e) {
                //meh
            }
            try {
                extraInfo['cleanRoomExists'] = window.document.getElementById('cz-clean-room') !== null;
            }
            catch (e) {
                //meh
            }
        }
        window['__tracerCZ'].log(code, exception, extraInfo);
    };
    ErrorLogger.isFreedScriptError = function (ex) {
        if (ex && ex.number && ex.number.toString() === '-2146823277') {
            return true;
        }
        return false;
    };
    ErrorLogger.isJSONRefError = function (ex) {
        if (!ex) {
            return false;
        }
        try {
            var mess = (ex.toString() || '');
            if (mess.indexOf('\'JSON\'') > -1 || mess.indexOf('getOriginalJson') > -1) {
                return true;
            }
        }
        catch (e) {
            //meh
        }
        return false;
    };
    ErrorLogger.prototype.log = function (code, exception, extraInfo) {
        if (!this.reportUrl) {
            console.warn('No Report Url! Error Logging wont be working.');
            return;
        }
        var now = this.dateConstructor.now();
        if (this.throttleSet === null || (now - this.throttleSet) > this.throttleTime) {
            this.doLog(code, exception, extraInfo);
            this.throttleSet = now;
        }
        if (true) {
            throw exception;
        }
    };
    ErrorLogger.prototype.doLog = function (code, exception, extraInfo) {
        var queryString = {
            t: this.dateConstructor.now(),
            v: this.appVersion
        }, data = {
            code: code,
            message: '',
            stack: '',
            extraInfo: undefined
        }, url = this.reportUrl, queryStringString = clientlibs_1.CoreUtils.Urls.buildQueryStringString(queryString), urlBase = url + "error";
        data.message = (exception || 'Logged null or undefined exception').toString();
        data.stack = exception.stack || (exception.backtrace || exception.stacktrace);
        try {
            if (!data.stack) {
                data.stack = this.generateStackTrace();
            }
        }
        catch (ex) {
            data.stack = 'Generating Stack Trace caused error.';
        }
        data.stack = this.coder.encode(data.stack);
        if (extraInfo) {
            data.extraInfo = this.coder.encode(extraInfo);
        }
        this.httpService.Post(urlBase + queryStringString, data, false, clientlibs_1.CoreUtils.noop, clientlibs_1.CoreUtils.noop);
    };
    ErrorLogger.prototype.generateStackTrace = function () {
        var stackTraceLimit = 10, anonString = '[anonymous]', functionRegex = /function\s*([\w\-$]+)?\s*\(/i;
        var stackTrace;
        try {
            throw Error('');
        }
        catch (testError) {
            stackTrace = testError.stack || testError.backtrace || testError.stacktrace;
        }
        if (!stackTrace) {
            stackTrace = [];
            try {
                for (var t = arguments.callee.caller.caller; t && stackTrace.length < stackTraceLimit;) {
                    var g = functionRegex.test(t.toString()) ?
                        RegExp.$1 || anonString : anonString;
                    stackTrace.push(g);
                    t = t.caller;
                }
            }
            catch (n) {
                //this.log("ErrorLogger.generateStackTrace", n);
            }
            try {
                stackTrace = 'Manually Rebuilt\n' + stackTrace.join('\n');
            }
            catch (m) {
                stackTrace = 'Could not manually rebuild stack trace.';
            }
        }
        return stackTrace;
    };
    Object.defineProperty(ErrorLogger.prototype, "appVersion", {
        get: function () {
            //getter
            return this._appVersion;
        },
        enumerable: false,
        configurable: true
    });
    return ErrorLogger;
}());
exports["default"] = ErrorLogger;


/***/ }),

/***/ "./src/core/launchers/DevlessPanelLauncher.ts":
/*!****************************************************!*\
  !*** ./src/core/launchers/DevlessPanelLauncher.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Enums_1 = __webpack_require__(/*! @src/core/Enums */ "./src/core/Enums.ts");
var errorLogger_1 = __importDefault(__webpack_require__(/*! @src/core/errorLogger */ "./src/core/errorLogger.ts"));
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var IndependentLauncher_1 = __webpack_require__(/*! @src/core/IndependentLauncher */ "./src/core/IndependentLauncher.ts");
var DevlessPanelLauncher = /** @class */ (function (_super) {
    __extends(DevlessPanelLauncher, _super);
    function DevlessPanelLauncher(appSvc, tenantSvc, windowSvc, storageSvc, sessionSvc, messageSvc, templateCache, commSvc, openOnStart) {
        var _this = _super.call(this, windowSvc.document, appSvc, tenantSvc, windowSvc, storageSvc, sessionSvc, messageSvc, templateCache) || this;
        _this.commSvc = commSvc;
        _this.openOnStart = openOnStart;
        _this.fileNames = {
            CSMPanelTemplate: 'template/csmPanel.html'
        };
        _this.subIds = {};
        _this.onInit();
        return _this;
    }
    Object.defineProperty(DevlessPanelLauncher.prototype, "topWindow", {
        get: function () {
            var _a;
            return ((_a = this.parentDocument) === null || _a === void 0 ? void 0 : _a.defaultView) || null;
        },
        enumerable: false,
        configurable: true
    });
    DevlessPanelLauncher.prototype.onInit = function () {
        var _this = this;
        try {
            //attempt to add the container for all the parts
            if (!this.buildContainer()) {
                return;
            }
            this.addLauncherFrame(function () {
                _this.container.classList.remove('cz-hidden');
                _this.panelLauncher.classList.remove('cz-hidden');
            }, function (e) {
                _this.handleError(e, 'addLauncherFrame');
            });
        }
        catch (exc) {
            this.handleError(exc, 'DevlessPanelLauncher.onInit');
        }
        //this.subIds['digestSubId'] = this.appSvc.pubsub.subscribe(Enums.ChurnZeroAppEvents.DIGEST, () => this.onDigest());
        this.subIds['haltSubId'] = this.appSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.HALT, function () { return _this.onHalt(); });
        //listen for devless panel hide events to reshow the launcher icon
        this.subIds['DevlessHideSubId'] = this.appSvc.pubsub.subscribe(Enums_1.Enums.DevlessEvents.DevlessHide, function (message) {
            _this.hide();
        });
    };
    DevlessPanelLauncher.prototype.show = function (forceOpen) {
        try {
            this.hidePanelToggle();
            this.showDevlessPanel();
        }
        catch (ex) {
            //report?
            errorLogger_1.default.report('DevlessPanelLauncher.show', ex);
        }
    };
    DevlessPanelLauncher.prototype.hide = function () {
        try {
            this.showPanelToggle();
        }
        catch (ex) {
            //report?
            errorLogger_1.default.report('DevlessPanelLauncher.hide', ex);
        }
    };
    DevlessPanelLauncher.prototype.showPanelToggle = function () {
        var _a, _b;
        (_b = (_a = this.panelLauncher) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.remove('hidden');
    };
    DevlessPanelLauncher.prototype.hidePanelToggle = function () {
        var _a, _b;
        (_b = (_a = this.panelLauncher) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.add('hidden');
    };
    DevlessPanelLauncher.prototype.onDigest = function () { };
    //1. The overall container is added to the body
    DevlessPanelLauncher.prototype.buildContainer = function () {
        this.container = this.windowSvc.createElement('div');
        this.container.id = 'cz_devless_container';
        this.container.classList.add('cz-hidden');
        this.container.classList.add('cz-independent-frame-container');
        this.container.classList.add('sc-container');
        this.container.classList.add('no-transforms');
        this.container.classList.add('pos-bottom-right');
        this.container.classList.add('float');
        this.container.classList.add('in');
        var bod = this.parentDocument.querySelector('body');
        if (!bod) {
            this.appSvc.debug('No body element found to add success panel. Exiting early.');
            return false;
        }
        if (!this.topWindow) {
            this.appSvc.debug('No top window found when adding success center. Exiting early.');
            return false;
        }
        bod.appendChild(this.container);
        return true;
    };
    //2. The iframe used to launch the panel is added to the container
    DevlessPanelLauncher.prototype.addLauncherFrame = function (onReady, onError) {
        var _this = this;
        var html = "\n        <section id=\"cz-devless-launch-wrapper\">\n            <div class=\"cz-success-center-launch-avatar-img img-circle\"\n                style=\"background-image: url('" + this.appSvc.addCdn('img/ch0-icon-light-32x32.png') + "');\"></div>\n        </section>";
        this.panelLauncher = this.windowSvc.createElement('iframe');
        this.panelLauncher.id = 'cz_devless_launcher_frame';
        this.panelLauncher.classList.add('cz-hidden');
        this.panelLauncher.classList.add('cz-independent-frame');
        this.panelLauncher.classList.add('launcher');
        this.panelLauncher.classList.add('pos-bottom-right');
        this.panelLauncher.classList.add('float');
        this.panelLauncher.addEventListener('load', function (e) {
            try {
                var frame = e.target, frameDoc = frame.contentWindow.document, bod = frameDoc.body, styleLink = frameDoc.createElement('link');
                styleLink.id = 'cz-launcher-styles';
                styleLink.type = 'text/css';
                styleLink.rel = 'stylesheet';
                styleLink.href = _this.appSvc.addCdn('css/in_frame_success_center_launcher.css');
                frameDoc.head.appendChild(styleLink);
                // Add custom CSS
                //this.addCustomCssToFrame(frameDoc, 'launcher');
                bod.className = 'cz-launch-panel-body';
                bod.innerHTML = html;
                frameDoc.addEventListener('click', function () {
                    _this.show();
                });
            }
            catch (exc) {
                onError(exc);
            }
            // Execute "after load" stuff
            onReady();
        }, { once: true });
        this.container.appendChild(this.panelLauncher);
    };
    //3. The iframe display the panel is added to the container
    DevlessPanelLauncher.prototype.addPanelFrame = function (onReady, onError) {
        //nothing to do here?
        onReady();
    };
    DevlessPanelLauncher.prototype.getId = function () {
        return undefined;
    };
    DevlessPanelLauncher.prototype.onHalt = function () {
        console.log('Halting - DevlessPanelLauncher');
        this.hide();
        this.removeAllInjectedHtml();
        clientlibs_1.PubSuber.removeAll(this.subIds);
    };
    DevlessPanelLauncher.prototype.positionLauncher = function (styles) {
        //todo
        for (var key in styles) {
            this.container.style.setProperty(key, styles[key].toString(), 'important');
        }
    };
    DevlessPanelLauncher.prototype.showDevlessPanel = function () {
        try {
            this.appSvc.pubsub.publish(Enums_1.Enums.DevlessEvents.DevlessShow, true);
        }
        catch (ex) {
            //report?
            errorLogger_1.default.report('DevlessPanelLauncher.showDevlessPanelEvent', ex);
        }
    };
    return DevlessPanelLauncher;
}(IndependentLauncher_1.IndependentLauncher));
exports["default"] = DevlessPanelLauncher;


/***/ }),

/***/ "./src/core/launchers/JourneyChecklistLauncher.ts":
/*!********************************************************!*\
  !*** ./src/core/launchers/JourneyChecklistLauncher.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JourneyChecklistLauncher = void 0;
var IndependentLauncher_1 = __webpack_require__(/*! @src/core/IndependentLauncher */ "./src/core/IndependentLauncher.ts");
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var JourneyChecklistWidget_1 = __webpack_require__(/*! ../panel-widgets/JourneyChecklistWidget */ "./src/core/panel-widgets/JourneyChecklistWidget.ts");
var progress_gauge_1 = __webpack_require__(/*! @src/core/ui-elements/progress-gauge */ "./src/core/ui-elements/progress-gauge.ts");
var EMPTY_RECORD = {};
var JourneyChecklistLauncher = /** @class */ (function (_super) {
    __extends(JourneyChecklistLauncher, _super);
    function JourneyChecklistLauncher(data, settingsConfig, container, appSvc, tenantSvc, windowSvc, storageSvc, sessionSvc, messageSvc, templateCache, checklistSvc, metaData) {
        var _this = _super.call(this, windowSvc.document, appSvc, tenantSvc, windowSvc, storageSvc, sessionSvc, messageSvc, templateCache) || this;
        _this.data = data;
        _this.settingsConfig = settingsConfig;
        _this.container = container;
        _this.checklistSvc = checklistSvc;
        _this.metaData = metaData;
        _this.initialFrameHeightSet = false;
        _this.areFramePositionsCalculating = false;
        _this.onShowListeners = [];
        _this.haltOnError = true;
        _this.errorMessagePrefix = 'Checklist launcher error';
        _this.show = _this.show.bind(_this);
        _this.hide = _this.hide.bind(_this);
        _this.handleWidgetUpdate = _this.handleWidgetUpdate.bind(_this);
        _this.calculateFramePositions = _this.calculateFramePositions.bind(_this);
        if (!_this.settingsConfig.fontFamilyId)
            return _this;
        _this.fontFamilyUrl = _this.tenantSvc.buildUIFontFamilyCssRequestUrlFromConfig(_this.settingsConfig);
        _this.fontFamilyRule = _this.tenantSvc.getUIFontFamilyMappingDisplayValue(_this.settingsConfig.fontFamilyId);
        return _this;
    }
    JourneyChecklistLauncher.prototype.onInit = function () {
        var _this = this;
        var _a;
        if (!((_a = this.data) === null || _a === void 0 ? void 0 : _a.id)) {
            return;
        }
        try {
            this.addLauncherFrame(function () {
                _this.addPanelFrame(function () {
                    var _a = _this.metaData || EMPTY_RECORD, domOrder = _a.domOrder, isLastChild = _a.isLastChild;
                    if (typeof domOrder === 'number') {
                        _this.panelLauncher.style.setProperty('order', domOrder.toString(), 'important');
                    }
                    if (isLastChild === true) {
                        _this.panelLauncher.classList.add('last');
                    }
                    _this.panelLauncher.classList.remove('cz-invisible');
                    _this.panelFrame.classList.remove('cz-invisible');
                    _this.windowSvc.window.setTimeout(_this.calculateFramePositions, 500);
                }, function (e) {
                    _this.handleError(e, 'addPanelFrame');
                });
            }, function (e) {
                _this.handleError(e, 'addLauncherFrame');
            });
        }
        catch (exc) {
            this.handleError(exc, 'JourneyChecklistLauncher.onInit');
        }
    };
    JourneyChecklistLauncher.prototype.addLauncherFrame = function (onReady, onError) {
        var _this = this;
        this.panelLauncher = this.windowSvc.createElement('iframe');
        this.panelLauncher.id = "cl-launcher-launch-frame-" + this.data.id;
        this.panelLauncher.className = 'cz-invisible cz-independent-frame launcher';
        this.panelLauncher.classList.add(this.getPositionalClassFromConfig(this.settingsConfig.launchIconPosition));
        var isFloatingLauncher = this.settingsConfig.launchIconType === clientlibs_1.LaunchIconType.Float;
        var launcherClass = (isFloatingLauncher) ? 'float' : 'tabbed';
        this.panelLauncher.classList.add(launcherClass);
        this.panelLauncher.addEventListener('load', function (e) {
            try {
                var frame = e.target, win = frame.contentWindow, doc_1 = win.document, bod = doc_1.body;
                _this.progressGauge = new progress_gauge_1.ProgressGauge(_this.parentDocument, _this.windowSvc, 50, 50, 20, 'Click to interact with Checklist');
                bod.appendChild(_this.progressGauge.getContainer());
                // Event handlers
                var showHandler_1 = function () { _this.show(); };
                doc_1.addEventListener('click', showHandler_1);
                doc_1.defaultView.addEventListener('unload', function () {
                    doc_1.removeEventListener('click', showHandler_1);
                });
                var fontLink = doc_1.createElement('link');
                fontLink.type = 'text/css';
                fontLink.rel = 'stylesheet';
                fontLink.href = 'https://fonts.googleapis.com/css?family=Open+Sans';
                doc_1.head.appendChild(fontLink);
                doc_1.head.appendChild(_this.getFrameStyleLink('css/in_frame_independent_launcher.css', function () {
                    if (_this.fontFamilyUrl) {
                        var ffLink = doc_1.createElement('link');
                        ffLink.type = 'text/css';
                        ffLink.href = _this.fontFamilyUrl;
                        ffLink.rel = 'stylesheet';
                        doc_1.head.appendChild(ffLink);
                    }
                    var launcherStyles = '', bodyRules = '';
                    if (_this.fontFamilyRule)
                        bodyRules += "font-family:" + _this.fontFamilyRule + ";";
                    if (!isFloatingLauncher && _this.settingsConfig.launcherBackgroundColor) {
                        bodyRules += "background-color:" + _this.settingsConfig.launcherBackgroundColor + ";";
                    }
                    if (bodyRules)
                        launcherStyles += "body{" + bodyRules + "}";
                    launcherStyles += _this.getProgressGaugeStyles();
                    if (_this.settingsConfig.customCss) {
                        launcherStyles += _this.settingsConfig.customCss;
                    }
                    if (launcherStyles) {
                        var styleBlock = doc_1.createElement('style');
                        styleBlock.setAttribute('type', 'text/css');
                        styleBlock.textContent = launcherStyles;
                        doc_1.head.appendChild(styleBlock);
                    }
                    onReady();
                }, onError));
            }
            catch (exc) {
                onError(exc);
            }
        }, { once: true });
        this.container.appendChild(this.panelLauncher);
    };
    JourneyChecklistLauncher.prototype.addPanelFrame = function (onReady, onError) {
        var _this = this;
        this.panelFrame = this.windowSvc.createElement('iframe');
        this.panelFrame.id = "cl-launcher-content-frame-" + this.data.id;
        this.panelFrame.className = 'cz-invisible cz-independent-frame checklist-panel';
        this.panelFrame.classList.add(this.getPositionalClassFromConfig(this.settingsConfig.launchIconPosition));
        this.panelFrame.addEventListener('load', function (e) {
            var _a;
            try {
                var frame = e.target, win = frame.contentWindow, doc = win.document, bod = doc.body;
                bod.classList.add('checklist');
                var widget = new JourneyChecklistWidget_1.JourneyChecklistWidget(doc, _this.windowSvc, _this.appSvc, _this.checklistSvc, _this.handleWidgetUpdate);
                widget.setData(_this.data);
                widget.build();
                _this.widgets = [widget];
                _this.contentContainer = doc.createElement('section');
                var closeContainer = doc.createElement('p'), closeBtn = doc.createElement('i'), launchIconPosition = _this.settingsConfig.launchIconPosition;
                _this.contentContainer.classList.add('content-container');
                if (launchIconPosition === clientlibs_1.LaunchIconPosition.TopLeft
                    || launchIconPosition === clientlibs_1.LaunchIconPosition.TopRight
                    || launchIconPosition === clientlibs_1.LaunchIconPosition.TopCenter) {
                    _this.contentContainer.style.marginBottom = 'auto';
                }
                else {
                    _this.contentContainer.style.marginTop = 'auto';
                }
                closeContainer.classList.add('close-btn-container');
                closeContainer.appendChild(closeBtn);
                closeBtn.classList.add('close-btn');
                closeBtn.title = 'Click to hide the Checklist.';
                closeBtn.innerHTML = '&times';
                closeBtn.addEventListener('click', _this.hide);
                _this.contentContainer.appendChild(closeContainer);
                _this.contentContainer.appendChild(widget.getContainer());
                var xmlns = 'http://www.w3.org/2000/svg', svgArrow = doc.createElementNS(xmlns, 'svg'), polyLine = doc.createElementNS(xmlns, 'polyline'), atts = _this.getSvgAttributesFromConfigPosition();
                svgArrow.setAttributeNS(null, 'class', "arrow " + atts.className); // set SVG classname this way, because IE
                svgArrow.setAttributeNS(null, 'width', atts.width);
                svgArrow.setAttributeNS(null, 'height', atts.height);
                polyLine.setAttributeNS(null, 'points', atts.points);
                polyLine.setAttributeNS(null, 'style', 'fill:#fff;stroke:gray;stroke-width:1');
                if ((_a = _this.settingsConfig) === null || _a === void 0 ? void 0 : _a.backgroundColor) {
                    polyLine.style.fill = _this.settingsConfig.backgroundColor;
                    _this.contentContainer.style.backgroundColor = _this.settingsConfig.backgroundColor;
                }
                svgArrow.appendChild(polyLine);
                if (atts.appendFirst) {
                    bod.appendChild(svgArrow);
                    bod.appendChild(_this.contentContainer);
                }
                else {
                    bod.appendChild(_this.contentContainer);
                    bod.appendChild(svgArrow);
                }
                _this.svgArrow = svgArrow;
                if (atts.isParentFlexColumn)
                    bod.classList.add('flex-column');
                if (_this.progressGauge) {
                    var _b = widget.getItemCounts(), total = _b.total, completed = _b.completed, pc = (total > 0) ? Math.floor((completed / total) * 100) : 0;
                    _this.progressGauge.update(pc);
                }
                _this.panelFrameBody = bod;
                var fontLink = doc.createElement('link');
                fontLink.type = 'text/css';
                fontLink.rel = 'stylesheet';
                fontLink.href = 'https://fonts.googleapis.com/css?family=Open+Sans';
                doc.head.appendChild(fontLink);
                doc.head.appendChild(_this.getFrameStyleLink('css/in_frame_checklist_panel.css', onReady, onError));
                if (_this.fontFamilyUrl) {
                    var link = doc.createElement('link');
                    link.type = 'text/css';
                    link.href = _this.fontFamilyUrl;
                    link.rel = 'stylesheet';
                    doc.head.appendChild(link);
                }
                var checklistStyles = '';
                if (_this.fontFamilyRule)
                    checklistStyles += "body{font-family:" + _this.fontFamilyRule + ";}";
                var convertedStyles = _this.checklistSvc.mapChecklistBrandingToProperFormat(_this.settingsConfig);
                checklistStyles += _this.checklistSvc.buildStyleRulesFromCheckListStyleBranding(convertedStyles);
                checklistStyles += _this.getProgressGaugeStyles();
                if (_this.settingsConfig.customCss) {
                    checklistStyles += _this.settingsConfig.customCss;
                }
                if (checklistStyles.length) {
                    var styleBlock = doc.createElement('style');
                    styleBlock.setAttribute('type', 'text/css');
                    styleBlock.textContent = checklistStyles;
                    doc.head.appendChild(styleBlock);
                }
            }
            catch (exc) {
                onError(exc);
            }
        }, { once: true });
        this.container.appendChild(this.panelFrame);
    };
    JourneyChecklistLauncher.prototype.show = function () {
        if (!this.panelFrame)
            return;
        // TODO: If this event listener isn't needed, remove it!
        this.panelFrame.addEventListener('transitionend', function () { }, { once: true });
        this.panelFrame.classList.add('in');
        var sl = this.onShowListeners.length;
        for (var i = 0; i < sl; i++)
            this.onShowListeners[i](this.getId());
    };
    JourneyChecklistLauncher.prototype.hide = function () {
        this.panelFrame.classList.remove('in');
    };
    JourneyChecklistLauncher.prototype.showPanelToggle = function () {
        //checklist launchers toggle is always visible
    };
    JourneyChecklistLauncher.prototype.hidePanelToggle = function () {
        //checklist launchers toggle is always visible
    };
    JourneyChecklistLauncher.prototype.onDigest = function () {
    };
    JourneyChecklistLauncher.prototype.onHalt = function () {
        var _a, _b, _c, _d, _e;
        var wl = ((_a = this.widgets) === null || _a === void 0 ? void 0 : _a.length) || 0;
        for (var i = 0; i < wl; i++) {
            this.widgets[i].onHalt();
        }
        (_c = (_b = this.panelLauncher) === null || _b === void 0 ? void 0 : _b.parentElement) === null || _c === void 0 ? void 0 : _c.removeChild(this.panelLauncher);
        (_e = (_d = this.panelFrame) === null || _d === void 0 ? void 0 : _d.parentElement) === null || _e === void 0 ? void 0 : _e.removeChild(this.panelFrame);
        this.panelLauncher = null;
        this.panelFrameBody = null;
        this.panelFrame = null;
        this.contentContainer = null;
        this.svgArrow = null;
        this.onShowListeners = [];
    };
    JourneyChecklistLauncher.prototype.getId = function () {
        var _a;
        return ((_a = this.data) === null || _a === void 0 ? void 0 : _a.id) || 0;
    };
    JourneyChecklistLauncher.prototype.calculateFramePositions = function () {
        var _this = this;
        if (this.areFramePositionsCalculating) {
            return;
        }
        this.areFramePositionsCalculating = true;
        this.setLauncherBoundingRectangle();
        this.updatePanelFrameHeight();
        this.setPanelBoundingRect();
        this.setPanelFramePosition();
        // Wait 400ms in case we are waiting on the complete banner's transition to finish
        this.windowSvc.window.setTimeout(function () {
            _this.areFramePositionsCalculating = false;
        }, 400);
    };
    JourneyChecklistLauncher.prototype.registerShowListener = function (listener) {
        this.onShowListeners.push(listener);
    };
    JourneyChecklistLauncher.prototype.updateMetaData = function (meta) {
        this.metaData = __assign({}, meta);
        if (!this.panelLauncher)
            return;
        var _a = this.metaData || EMPTY_RECORD, domOrder = _a.domOrder, isLastChild = _a.isLastChild;
        if (typeof domOrder === 'number') {
            this.panelLauncher.style.setProperty('order', domOrder.toString(), 'important');
        }
        if (isLastChild === true) {
            this.panelLauncher.classList.add('last');
        }
        else {
            this.panelLauncher.classList.remove('last');
        }
        this.windowSvc.window.setTimeout(this.calculateFramePositions, 0);
    };
    JourneyChecklistLauncher.prototype.getSvgAttributesFromConfigPosition = function () {
        switch (this.settingsConfig.launchIconPosition) {
            case clientlibs_1.LaunchIconPosition.TopCenter:
                return { isParentFlexColumn: true, appendFirst: true, width: '30', height: '15', points: '0 15, 15 0, 30 15', className: 'arrow-top-center' };
            case clientlibs_1.LaunchIconPosition.BottomCenter:
                return { isParentFlexColumn: true, width: '30', height: '15', points: '0 0, 15 15, 30 0', className: 'arrow-bottom-center' };
            case clientlibs_1.LaunchIconPosition.TopLeft:
                return { appendFirst: true, width: '15', height: '30', points: '15 0, 0 15, 15 30', className: 'arrow-top-left' };
            case clientlibs_1.LaunchIconPosition.LeftCenter:
                return { appendFirst: true, width: '15', height: '30', points: '15 0, 0 15, 15 30', className: 'arrow-left-center' };
            case clientlibs_1.LaunchIconPosition.BottomLeft:
                return { appendFirst: true, width: '15', height: '30', points: '15 0, 0 15, 15 30', className: 'arrow-bottom-left' };
            case clientlibs_1.LaunchIconPosition.TopRight:
                return { width: '15', height: '30', points: '0 0, 15 15, 0 30', className: 'arrow-top-right' };
            case clientlibs_1.LaunchIconPosition.RightCenter:
                return { width: '15', height: '30', points: '0 0, 15 15, 0 30', className: 'arrow-right-center' };
            case clientlibs_1.LaunchIconPosition.BottomRight:
                return { width: '15', height: '30', points: '0 0, 15 15, 0 30', className: 'arrow-bottom-right' };
        }
    };
    JourneyChecklistLauncher.prototype.getFrameStyleLink = function (cssPath, onLoad, onError) {
        var styleLink = this.windowSvc.createElement('link');
        styleLink.onload = function () { onLoad(); };
        styleLink.onerror = function (event) { onError(event); };
        styleLink.type = 'text/css';
        styleLink.rel = 'stylesheet';
        styleLink.href = this.appSvc.addCdn(cssPath);
        return styleLink;
    };
    JourneyChecklistLauncher.prototype.getProgressGaugeStyles = function () {
        var ret = '';
        var _a = this.settingsConfig, progressBackgroundColor = _a.progressBackgroundColor, progressRemainingColor = _a.progressRemainingColor, progressCompleteColor = _a.progressCompleteColor, progressTextColor = _a.progressTextColor;
        var baseGaugeRules = '';
        if (progressBackgroundColor) {
            baseGaugeRules += "fill:" + progressBackgroundColor + ";";
        }
        if (progressRemainingColor) {
            baseGaugeRules += "stroke:" + progressRemainingColor + ";";
        }
        if (baseGaugeRules) {
            ret += ".cz-progress-gauge .gauge-base{" + baseGaugeRules + "}";
        }
        if (progressCompleteColor) {
            ret += ".cz-progress-gauge .gauge-progress{stroke:" + progressCompleteColor + ";}";
        }
        if (progressTextColor) {
            ret += ".cz-progress-gauge .gauge-text{stroke:" + progressTextColor + ";}";
        }
        return ret;
    };
    JourneyChecklistLauncher.prototype.updatePanelFrameHeight = function () {
        var _a, _b;
        if (!this.panelFrame || !this.panelFrameBody || this.widgets.length === 0)
            return;
        var bodyHeight = this.panelFrameBody.offsetHeight;
        var w = this.widgets[0], frameHeight = parseInt(this.panelFrame.style.height);
        if (!this.initialFrameHeightSet) {
            if (!w.isCompleteBannerVisible()) {
                bodyHeight += 55; // account for the expanding/collapsing complete banner
            }
            (_b = (_a = this.panelFrame.contentDocument.querySelector('html')) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.add('full-height');
            this.initialFrameHeightSet = true;
        }
        this.panelFrame.style.height = Math.max(frameHeight || 0, bodyHeight) + 'px';
    };
    JourneyChecklistLauncher.prototype.setPanelBoundingRect = function () {
        if (!this.panelFrame)
            return;
        this.panelBoundingRect = this.panelFrame.getBoundingClientRect();
    };
    JourneyChecklistLauncher.prototype.setPanelFramePosition = function () {
        if (!this.panelFrame || !this.panelBoundingRect)
            return;
        var arrowHeight = 0, arrowMargin = 0, t = 0, l = 0;
        if (this.svgArrow) {
            if (!this.svgComputedStyle) {
                this.svgComputedStyle = this.windowSvc.window.getComputedStyle(this.svgArrow);
            }
            arrowHeight = parseInt(this.svgComputedStyle.height);
            arrowMargin = parseInt(this.svgComputedStyle.marginTop) + parseInt(this.svgComputedStyle.marginBottom);
        }
        switch (this.settingsConfig.launchIconPosition) {
            case clientlibs_1.LaunchIconPosition.TopLeft: {
                t = this.launcherBoundingRect.top + (this.launcherBoundingRect.height / 2) - (arrowHeight / 2) - arrowMargin;
                l = this.launcherBoundingRect.left + this.launcherBoundingRect.width;
                break;
            }
            case clientlibs_1.LaunchIconPosition.LeftCenter: {
                t = this.launcherBoundingRect.top + (this.launcherBoundingRect.height / 2) - (this.panelBoundingRect.height / 2);
                l = this.launcherBoundingRect.left + this.launcherBoundingRect.width;
                break;
            }
            case clientlibs_1.LaunchIconPosition.BottomLeft: {
                t = this.launcherBoundingRect.top - this.panelBoundingRect.height + (this.launcherBoundingRect.height / 2) + (arrowHeight / 2) + arrowMargin;
                l = this.launcherBoundingRect.left + this.launcherBoundingRect.width;
                break;
            }
            case clientlibs_1.LaunchIconPosition.TopRight: {
                t = this.launcherBoundingRect.top + (this.launcherBoundingRect.height / 2) - (arrowHeight / 2) - arrowMargin;
                l = this.launcherBoundingRect.left - this.panelBoundingRect.width;
                break;
            }
            case clientlibs_1.LaunchIconPosition.RightCenter: {
                t = this.launcherBoundingRect.top + (this.launcherBoundingRect.height / 2) - (this.panelBoundingRect.height / 2);
                l = this.launcherBoundingRect.left - this.panelBoundingRect.width;
                break;
            }
            case clientlibs_1.LaunchIconPosition.BottomRight: {
                t = this.launcherBoundingRect.top - this.panelBoundingRect.height + (this.launcherBoundingRect.height / 2) + (arrowHeight / 2) + arrowMargin;
                l = this.launcherBoundingRect.left - this.panelBoundingRect.width;
                break;
            }
            case clientlibs_1.LaunchIconPosition.BottomCenter: {
                t = this.launcherBoundingRect.top - this.panelBoundingRect.height;
                l = this.launcherBoundingRect.left + (this.launcherBoundingRect.width / 2) - (this.panelBoundingRect.width / 2);
                break;
            }
            case clientlibs_1.LaunchIconPosition.TopCenter: {
                t = this.launcherBoundingRect.top + this.launcherBoundingRect.height;
                l = this.launcherBoundingRect.left + (this.launcherBoundingRect.width / 2) - (this.panelBoundingRect.width / 2);
                break;
            }
        }
        this.panelFrame.style.top = t + "px";
        this.panelFrame.style.left = l + "px";
    };
    JourneyChecklistLauncher.prototype.handleWidgetUpdate = function (updateInfo) {
        var _a;
        if (!this.progressGauge)
            return;
        var percentComplete = updateInfo.percentComplete, title = updateInfo.title;
        if ((_a = this.data) === null || _a === void 0 ? void 0 : _a.title)
            title = this.data.title + ": " + title;
        this.progressGauge.update(percentComplete, title);
        this.calculateFramePositions();
    };
    return JourneyChecklistLauncher;
}(IndependentLauncher_1.IndependentLauncher));
exports.JourneyChecklistLauncher = JourneyChecklistLauncher;


/***/ }),

/***/ "./src/core/launchers/SuccessCenterLauncher.ts":
/*!*****************************************************!*\
  !*** ./src/core/launchers/SuccessCenterLauncher.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuccessCenterLauncher = void 0;
var IndependentLauncher_1 = __webpack_require__(/*! @src/core/IndependentLauncher */ "./src/core/IndependentLauncher.ts");
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var errorLogger_1 = __importDefault(__webpack_require__(/*! @src/core/errorLogger */ "./src/core/errorLogger.ts"));
var enums_1 = __webpack_require__(/*! @churnzero/clientlibs/dist/main/enums */ "./node_modules/@churnzero/clientlibs/dist/main/enums.js");
var CZ_SUCCESS_CENTER_FRAMES_STYLES_ID = 'cz-success-frames-styles', CZ_CUSTOM_CSS_STYLE_ID_PREFIX = 'cz-custom-css-styles';
var PanelOpenState;
(function (PanelOpenState) {
    PanelOpenState[PanelOpenState["Closed"] = 0] = "Closed";
    PanelOpenState[PanelOpenState["Open"] = 1] = "Open";
})(PanelOpenState || (PanelOpenState = {}));
var SuccessCenterLauncher = /** @class */ (function (_super) {
    __extends(SuccessCenterLauncher, _super);
    function SuccessCenterLauncher(successCenterConfig, commSvc, appSvc, tenantSvc, windowSvc, storageSvc, sessionSvc, messageSvc, templateCache) {
        var _this = _super.call(this, windowSvc.document, appSvc, tenantSvc, windowSvc, storageSvc, sessionSvc, messageSvc, templateCache) || this;
        _this.successCenterConfig = successCenterConfig;
        _this.commSvc = commSvc;
        _this.subIds = {};
        _this.subs = [];
        _this.successCenterReadyEventReceived = false;
        _this.openOnStart = false;
        _this.centerUrl = '';
        _this.panelOpenState = PanelOpenState.Closed;
        _this.handleTransitionEnd = _this.handleTransitionEnd.bind(_this);
        _this.show = _this.show.bind(_this);
        _this.hide = _this.hide.bind(_this);
        _this.onDigest = _this.onDigest.bind(_this);
        _this.onHalt = _this.onHalt.bind(_this);
        _this.postMirroredMessage = _this.postMirroredMessage.bind(_this);
        _this.handleChecklistConfigRefresh = _this.handleChecklistConfigRefresh.bind(_this);
        _this.removeInjectedHtml = _this.removeInjectedHtml.bind(_this);
        // Assign a center width
        var width = successCenterConfig.width, widthUnit = successCenterConfig.widthUnit, widthSuffix = (widthUnit || clientlibs_1.SUCCESS_CENTER_DEFAULT_WIDTH_UNIT) === enums_1.WidthUnitType.Percentage ? '%' : 'px';
        _this.successCenterWidth = "" + (width || clientlibs_1.SUCCESS_CENTER_DEFAULT_WIDTH) + widthSuffix;
        _this.onInit();
        return _this;
    }
    SuccessCenterLauncher.prototype.onInit = function () {
        var _this = this;
        try {
            //early bail
            if (!this.successCenterConfig || !this.successCenterConfig.successCenterId) {
                return;
            }
            this.addPubSubSubscriptions();
            this.buildSuccessCenter(function () {
                //apply Branding needs to happen after
                // populate widgets so that any widget branding
                // gets properly applied
                //this.applyBranding();
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
                var positionClass = _this.getPositionalClassFromConfig(_this.successCenterConfig.launchIconPositionId);
                (_b = (_a = _this.successCenterContainer) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.add(positionClass);
                (_d = (_c = _this.panelLauncher) === null || _c === void 0 ? void 0 : _c.classList) === null || _d === void 0 ? void 0 : _d.add(positionClass);
                (_f = (_e = _this.launcherUnreadBadge) === null || _e === void 0 ? void 0 : _e.classList) === null || _f === void 0 ? void 0 : _f.add(positionClass);
                (_h = (_g = _this.alertFlyoutFrame) === null || _g === void 0 ? void 0 : _g.classList) === null || _h === void 0 ? void 0 : _h.add(positionClass);
                (_k = (_j = _this.seeMoreMessage) === null || _j === void 0 ? void 0 : _j.classList) === null || _k === void 0 ? void 0 : _k.add(positionClass);
                var isFloatingLauncher = _this.successCenterConfig.launchIconTypeId === clientlibs_1.LaunchIconType.Float;
                var launcherTypeClass = (isFloatingLauncher) ? 'float' : 'tabbed';
                (_m = (_l = _this.successCenterContainer) === null || _l === void 0 ? void 0 : _l.classList) === null || _m === void 0 ? void 0 : _m.add(launcherTypeClass);
                (_p = (_o = _this.panelLauncher) === null || _o === void 0 ? void 0 : _o.classList) === null || _p === void 0 ? void 0 : _p.add(launcherTypeClass);
                (_r = (_q = _this.alertFlyoutFrame) === null || _q === void 0 ? void 0 : _q.classList) === null || _r === void 0 ? void 0 : _r.add(launcherTypeClass);
                //make the panel launcher and panel uninvisible
                (_t = (_s = _this.successCenterContainer) === null || _s === void 0 ? void 0 : _s.classList) === null || _t === void 0 ? void 0 : _t.remove('cz-invisible');
                (_v = (_u = _this.successCenterContainer) === null || _u === void 0 ? void 0 : _u.classList) === null || _v === void 0 ? void 0 : _v.add('in');
                (_x = (_w = _this.panelLauncher) === null || _w === void 0 ? void 0 : _w.classList) === null || _x === void 0 ? void 0 : _x.remove('cz-invisible');
                if (_this.successCenterConfig.displayUnreadBadge && _this.successCenterConfig.launchTriggerId !== enums_1.LaunchTrigger.JavascriptEvent) {
                    var totalUnreadCount = _this.getTotalUnreadCount(_this.successCenterConfig.unreadCounts) || 0;
                    _this.updateUnreadBadge(totalUnreadCount);
                }
                // Digest and Halt subscriptions
                _this.subIds['digestSubId'] = _this.appSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.DIGEST, _this.onDigest);
                _this.subIds['haltSubId'] = _this.appSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.HALT, _this.onHalt);
                _this.windowSvc.window.setTimeout(function () {
                    try {
                        //if panel was open reopen it
                        if (_this.basePanelVisible || _this.openOnStart) {
                            _this.show(true);
                        }
                        if (clientlibs_1.CoreUtils.isNullOrUndefined(_this.launcherBoundingRect)) {
                            _this.setLauncherBoundingRectangle();
                            _this.appSvc.pubsub.publish(clientlibs_1.ChurnZeroAppEvents.PanelLauncherReady);
                        }
                        _this.appSvc.pubsub.publish(clientlibs_1.ChurnZeroAppEvents.PanelReady);
                        /*if (this.panelFrame) {
                            const loadCompleteEvt = this.parentDocument.createEvent('Event');
                            loadCompleteEvt.initEvent('czsuccesscenterloadcomplete', true, true);
                            this.panelFrame.dispatchEvent(loadCompleteEvt);
                        }*/
                    }
                    catch (ex) {
                        //report?
                        errorLogger_1.default.report('SuccessCenter.onAfterSuccessCenterFrameLoad timeout fn', ex);
                    }
                }, 500);
            });
        }
        catch (exc) {
            this.handleError(exc, 'SuccessCenterLauncher.onInit');
        }
    };
    SuccessCenterLauncher.prototype.onDigest = function () {
        //this.handleMessageDigest(this.basePanelVisible);
    };
    SuccessCenterLauncher.prototype.onHalt = function () {
        //remove all subscriptions
        clientlibs_1.PubSuber.removeAll(this.subIds);
        this.subs.forEach(function (s) { return s.remove(); });
        this.subs = [];
        //clean up center window
        this.centerWindow = undefined;
        this.successCenterReadyEventReceived = false;
        if (this.centerWindowInterval) {
            this.windowSvc.window.clearInterval(this.centerWindowInterval);
            this.centerWindowInterval = undefined;
        }
        //remove all injected html
        this.removeInjectedHtml();
    };
    SuccessCenterLauncher.prototype.getId = function () {
        return undefined;
    };
    SuccessCenterLauncher.prototype.hide = function () {
        var _a, _b;
        try {
            if (this.successCenterConfig.locationTypeId === clientlibs_1.SuccessCenterLocation.InAppOverlay) {
                //close base panel
                this.closeBasePanel();
                this.panelOpenState = PanelOpenState.Closed;
                var collapsedData = this.getCollapsedStyleData();
                (_b = (_a = this.panelFrameContainer) === null || _a === void 0 ? void 0 : _a.style) === null || _b === void 0 ? void 0 : _b.setProperty(collapsedData.property, collapsedData.value, 'important');
            }
        }
        catch (ex) {
            //report?
            errorLogger_1.default.report('SuccessCenter.hide', ex);
        }
    };
    SuccessCenterLauncher.prototype.show = function (forceOpen) {
        var _this = this;
        try {
            //hide the flyout
            this.hideMessageBubble();
            switch (this.successCenterConfig.locationTypeId) {
                case clientlibs_1.SuccessCenterLocation.NewTab:
                    this.centerWindow = this.windowSvc.window.open(this.centerUrl, '_blank ');
                    this.centerWindowInterval = this.windowSvc.window.setInterval(function () {
                        var _a;
                        if ((_a = _this.centerWindow) === null || _a === void 0 ? void 0 : _a.closed) {
                            _this.centerWindow = undefined;
                            _this.successCenterReadyEventReceived = false;
                            _this.windowSvc.window.clearInterval(_this.centerWindowInterval);
                            _this.centerWindowInterval = undefined;
                        }
                    }, 1000);
                    break;
                case clientlibs_1.SuccessCenterLocation.InAppOverlay: {
                    var collapsedData_1 = this.getCollapsedStyleData();
                    //success center frames dont get added until they are opened
                    if (!this.panelFrame) {
                        this.panelFrame = this.buildPanelIframe();
                        this.panelFrameContainer = this.buildPanelIframeContainer();
                        // set panel frame container to be collapsed by default
                        this.panelFrameContainer.style.setProperty(collapsedData_1.property, collapsedData_1.value, 'important');
                        this.panelFrameContainer.appendChild(this.panelFrame);
                        this.successCenterContainer.appendChild(this.panelFrameContainer);
                    }
                    //open base panel
                    this.openBasePanel(forceOpen);
                    this.panelOpenState = PanelOpenState.Open;
                    // Kick the style removal into the event loop so the transition logic has enough time to do its thing
                    // This fixes inconsistencies observed b/n V8-based browsers and FF
                    this.windowSvc.window.setTimeout(function () {
                        _this.panelFrameContainer.style.removeProperty(collapsedData_1.property);
                    }, 150);
                    break;
                }
            }
        }
        catch (ex) {
            //report?
            errorLogger_1.default.report('SuccessCenter.show', ex);
        }
    };
    SuccessCenterLauncher.prototype.hidePanelToggle = function () {
        var _a, _b;
        (_b = (_a = this.panelLauncher) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.add('cz-invisible');
    };
    SuccessCenterLauncher.prototype.showPanelToggle = function () {
        var _a, _b;
        (_b = (_a = this.panelLauncher) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.remove('cz-invisible');
    };
    /**
     * Show the extra message bubble on the side of the launcher icon
     * @param messageText
     * @private
     */
    SuccessCenterLauncher.prototype.showMessageBubble = function (messageText, announcement) {
        var _a, _b, _c, _d;
        //if the panel is open, short circuit
        if (this.basePanelVisible) {
            return;
        }
        if (!this.successCenterConfig.hasSurveysWidget && this.messageSvc.isSurveyAnnouncement(announcement)) {
            return;
        }
        //if the SuccessCenter has no Announcement Widget, short circuit
        if (!this.successCenterConfig.hasAnnouncementsWidget) {
            return;
        }
        //build the new message
        var messageHtml = this.appSvc.templater.populateTemplate(this.templateCache.messageBubbleTemplate, {}, true);
        //insert the message as text so that it is xss safe
        var messageElement = clientlibs_1.CoreUtils.createElementFromHTML(this.windowSvc.document, messageHtml);
        messageElement.textContent = messageText;
        if (this.seeMoreMessage) {
            //add the new message to the alert message
            this.seeMoreMessage.innerHTML = '';
            this.seeMoreMessage.appendChild(messageElement);
        }
        //make the flyout visible
        (_b = (_a = this.alertFlyoutFrame) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.remove('cz-invisible');
        //remove the inline animation=none so the shake animation will play
        (_d = (_c = this.seeMoreMessage) === null || _c === void 0 ? void 0 : _c.style) === null || _d === void 0 ? void 0 : _d.removeProperty('animation');
    };
    /**
     * Hide the extra message bubble on the side of the launcher icon
     * @private
     */
    SuccessCenterLauncher.prototype.hideMessageBubble = function () {
        var _a, _b;
        (_b = (_a = this.alertFlyoutFrame) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.add('cz-invisible');
        if (this.seeMoreMessage) {
            //add the inline animation=none so the shake animation wont play until shown
            this.seeMoreMessage.style.animation = 'none';
        }
    };
    /**
     * SuccessCenter build out methods
     */
    /**
     * Build out all the html needed for the SuccessCenter to exist within the parent frame
     * @param onReady
     * @private
     */
    SuccessCenterLauncher.prototype.buildSuccessCenter = function (onReady) {
        var _this = this;
        try {
            //Create the DOM Element to contain all pieces
            // and add it to the body of the parent document
            var bod = this.parentDocument.querySelector('body');
            if (!bod) {
                this.appSvc.debug('No body element found to add success panel. Exiting early.');
                return;
            }
            this.successCenterContainer = this.windowSvc.createElement('div');
            this.successCenterContainer.id = 'cz_success_center_container';
            this.successCenterContainer.className = 'cz-invisible cz-independent-frame-container sc-container no-transforms';
            bod.appendChild(this.successCenterContainer);
            // add styles to the parent frame
            // Load the launcher
            // load the panel
            this.loadTopStyles(function () {
                _this.addLauncherFrame(function () {
                    _this.addPanelFrame(function () {
                        _this.addSuccessCenterAlertFlyoutFrame(function () {
                            onReady();
                        });
                    }, function (e) {
                        _this.handleError(e, 'addPanelFrame');
                    });
                }, function (e) {
                    _this.handleError(e, 'addLauncherFrame');
                });
            }, function (e) {
                _this.handleError(e);
            });
        }
        catch (err) {
            this.handleError(err, 'buildSuccessCenter catch');
        }
    };
    /**
     * Add independent_frames.css if it isnt already in the parents head
     * @param onSuccess
     * @param onError
     * @private
     */
    SuccessCenterLauncher.prototype.loadTopStyles = function (onSuccess, onError) {
        var spFrameLinkHref = this.appSvc.addCdn('css/independent_frames.css');
        //ensure the independent frames css only gets added once
        var spFrameLinkExists = this.parentDocument.head.querySelector("[href='" + spFrameLinkHref + "']");
        if (spFrameLinkExists) {
            onSuccess();
            return;
        }
        var spFrameLink = this.windowSvc.createElement('link');
        spFrameLink.addEventListener('load', function () {
            onSuccess();
        });
        spFrameLink.addEventListener('error', function (ev) {
            var msg = '';
            if (ev) {
                // Event has an error. Use that and bail
                if (clientlibs_1.CoreUtils.hasOwnProp(ev, 'error') && ev.error) {
                    onError(ev.error);
                    return;
                }
                // Try and discern a meaningful message from the error event...
                if (typeof ev === 'string')
                    msg = ev;
                else if (clientlibs_1.CoreUtils.hasOwnProp(ev, 'message'))
                    msg = ev.message;
            }
            onError(new Error(msg || 'independent_frames.css failed to load.'));
        });
        spFrameLink.id = CZ_SUCCESS_CENTER_FRAMES_STYLES_ID;
        spFrameLink.type = 'text/css';
        spFrameLink.rel = 'stylesheet';
        spFrameLink.href = spFrameLinkHref;
        this.parentDocument.head.appendChild(spFrameLink);
    };
    /**
     * Add iframe to house launcher
     * @param onReady
     * @param onError
     */
    SuccessCenterLauncher.prototype.addLauncherFrame = function (onReady, onError) {
        var _this = this;
        var _a = this.successCenterConfig, launchTriggerId = _a.launchTriggerId, launchAvatarBackgroundColor = _a.launchAvatarBackgroundColor, launchAvatarGlowColor = _a.launchAvatarGlowColor, launchAvatarColor = _a.launchAvatarColor, launchIconTypeId = _a.launchIconTypeId;
        if (launchTriggerId === enums_1.LaunchTrigger.JavascriptEvent) {
            onReady();
            return;
        }
        this.panelLauncher = this.windowSvc.createElement('iframe');
        this.panelLauncher.id = 'cz_success_center_launcher_frame';
        this.panelLauncher.className = 'cz-invisible cz-independent-frame launcher last';
        var panelLauncherLoadEventHandler = function (e) {
            try {
                var frame = e.target, frameDoc_1 = frame.contentWindow.document, bod = frameDoc_1.body, innerHtml = "\n        <section id=\"cz-success-center-launch-wrapper\" class=\"cz-success-center-v3\">\n            <div class=\"cz-unread-badge\" style=\"display:none;\"></div>\n            <div class=\"cz-see-more-info\" style=\"display:none;\"></div>\n        </section>";
                var styleLink = frameDoc_1.createElement('link');
                styleLink.id = 'cz-launcher-styles';
                styleLink.type = 'text/css';
                styleLink.rel = 'stylesheet';
                styleLink.href = _this.appSvc.addCdn('css/in_frame_success_center_launcher.css');
                frameDoc_1.head.appendChild(styleLink);
                bod.className = 'cz-launch-panel-body';
                bod.innerHTML = innerHtml;
                if (launchAvatarBackgroundColor && launchIconTypeId === clientlibs_1.LaunchIconType.Tabbed) {
                    bod.style.backgroundColor = launchAvatarBackgroundColor;
                }
                var wrapper = frameDoc_1.querySelector('#cz-success-center-launch-wrapper');
                if (_this.successCenterConfig.launchAvatarTypeId === clientlibs_1.LaunchAvatarType.Custom) {
                    var avatar = frameDoc_1.createElement('div');
                    avatar.classList.add('cz-success-center-launch-avatar-img');
                    avatar.classList.add('img-circle');
                    avatar.style.backgroundImage = "url('" + _this.successCenterConfig.launchAvatarUrl + "')";
                    if (launchAvatarGlowColor) {
                        avatar.classList.add('avatar-glow');
                        avatar.style.color = launchAvatarGlowColor;
                    }
                    if (launchAvatarBackgroundColor)
                        avatar.style.backgroundColor = launchAvatarBackgroundColor;
                    wrapper.appendChild(avatar);
                }
                else {
                    var avatarWrapper = frameDoc_1.createElement('span'), avatar = frameDoc_1.createElement('i');
                    avatarWrapper.classList.add('cz-success-center-avatar-wrapper');
                    avatar.classList.add('czi');
                    if (launchAvatarColor) {
                        avatarWrapper.style.borderColor = launchAvatarColor;
                        //apply color directly to the icon here since its parent color
                        //controls the animated box-shadow.
                        avatar.style.color = launchAvatarColor;
                    }
                    if (launchAvatarGlowColor) {
                        avatarWrapper.classList.add('avatar-glow');
                        //we apply color here to apply to the box-shadow using currentColor in css.
                        //the icon itself got its color assigned in previous if block.
                        avatarWrapper.style.color = launchAvatarGlowColor;
                    }
                    if (launchAvatarBackgroundColor)
                        avatarWrapper.style.backgroundColor = launchAvatarBackgroundColor;
                    _this.addCziAvatarClassNameToElement(avatar);
                    avatarWrapper.appendChild(avatar);
                    wrapper.appendChild(avatarWrapper);
                }
                _this.launcherUnreadBadge = frameDoc_1.querySelector('.cz-unread-badge');
                _this.applyLauncherOffsets();
                //Click event handler setup
                var showHandler_1 = function () {
                    _this.show();
                };
                frameDoc_1.addEventListener('click', showHandler_1);
                frameDoc_1.defaultView.addEventListener('unload', function () {
                    frameDoc_1.removeEventListener('click', showHandler_1);
                });
            }
            catch (exc) {
                onError(exc);
                return;
            }
            // Execute "after load" stuff
            onReady();
        };
        this.panelLauncher.addEventListener('load', panelLauncherLoadEventHandler, { once: true });
        //todo : remove load listener in the event that it destruction happens before it loads
        this.successCenterContainer.appendChild(this.panelLauncher);
    };
    /**
     * Add iframe to house panel
     * @param onReady
     * @param onError
     */
    SuccessCenterLauncher.prototype.addPanelFrame = function (onReady, onError) {
        try {
            //build the url to load the success center
            this.centerUrl = "" + this.appSvc.WebAppDomain + this.successCenterConfig.url + "/";
            onReady();
        }
        catch (ex) {
            onError(ex);
        }
    };
    /**
     * Add iframe to house the flyout with the "Show more info" text
     * @param onAfterLoad
     * @private
     */
    SuccessCenterLauncher.prototype.addSuccessCenterAlertFlyoutFrame = function (onAfterLoad) {
        var _this = this;
        if (this.successCenterConfig.launchTriggerId === enums_1.LaunchTrigger.JavascriptEvent) {
            onAfterLoad();
            return;
        }
        var alertFlyoutHtml = "\n        <div class=\"cz-alert-message-body cz-invisible\" style=\"animation: none;\">\n            <p class=\"cz-alert-message-text\">" + (this.successCenterConfig.clickToSeeMoreText || 'Click here to see that info again!') + "</p>\n        </div>", _a = this.successCenterConfig, alertFlyoutBackgroundColor = _a.alertFlyoutBackgroundColor, alertFlyoutTextColor = _a.alertFlyoutTextColor;
        this.alertFlyoutFrame = this.windowSvc.createElement('iframe');
        this.alertFlyoutFrame.id = 'cz_success_center_alert_flyout_frame';
        this.alertFlyoutFrame.classList.add('cz-invisible');
        this.alertFlyoutFrame.addEventListener('load', function (e) {
            var err;
            try {
                var frame = e.target, frameDoc = frame.contentWindow.document, bod = frameDoc.body, styleLink = frameDoc.createElement('link'), fontLink = frameDoc.createElement('link');
                styleLink.rel = 'stylesheet';
                styleLink.type = 'text/css';
                styleLink.href = _this.appSvc.addCdn('css/in_frame_success_center_alert_flyout.css');
                fontLink.type = 'text/css';
                fontLink.rel = 'stylesheet';
                fontLink.href = 'https://fonts.googleapis.com/css?family=Open+Sans';
                frameDoc.head.appendChild(styleLink);
                frameDoc.head.appendChild(fontLink);
                // Add custom CSS
                _this.addCustomCssToFrame(frameDoc, 'flyout');
                bod.innerHTML = alertFlyoutHtml;
                _this.seeMoreMessage = frameDoc.querySelector('.cz-alert-message-body');
                if (alertFlyoutBackgroundColor) {
                    _this.seeMoreMessage.style.backgroundColor = alertFlyoutBackgroundColor;
                    _this.seeMoreMessage.style.borderColor = alertFlyoutBackgroundColor;
                }
                if (alertFlyoutTextColor)
                    _this.seeMoreMessage.style.color = alertFlyoutTextColor;
                // add listener for clicks on Show More Info container
                _this.seeMoreMessage.addEventListener('click', function () { return _this.show(); });
            }
            catch (exc) {
                err = exc;
            }
            // Execute "after load" stuff
            onAfterLoad(err);
        }, { once: true });
        this.successCenterContainer.appendChild(this.alertFlyoutFrame);
    };
    /**
     * Frame Event Handlers
     */
    SuccessCenterLauncher.prototype.handleTransitionEnd = function () {
        var _this = this;
        if (this.panelOpenState === PanelOpenState.Closed) {
            return;
        }
        if ((this.panelFrame.src || '').length === 0) {
            this.panelFrame.addEventListener('load', function () {
                var _a, _b;
                (_b = (_a = _this.panelFrameContainer) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.add('ready');
            }, { once: true });
            this.panelFrame.src = this.centerUrl;
        }
    };
    /**
     * wireup any subscriptions for app level pubsub events
     * @private
     */
    SuccessCenterLauncher.prototype.addPubSubSubscriptions = function () {
        var _this = this;
        //Add a mirror to the pubsub so core events get propagated to the devlessIframe
        this.appSvc.pubsub.addMirror(this.postMirroredMessage);
        //wire up listener so success center frame can message us
        this.appSvc.addChildFrameListener();
        //SuccessCenterReady: When the SuccessCenter iFrame is ready it will publish this event and expect to receive info about the current session
        var scr = this.appSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.SuccessCenterReady, function () {
            var _a, _b, _c, _d;
            _this.successCenterReadyEventReceived = true;
            //SuccessCenterSetSocketContext
            _this.appSvc.pubsub.publish(enums_1.InterfaceCommCodes.SuccessCenterSetSocketContext, { hasDevless: _this.sessionSvc.DevlessPanelEnabled });
            (_a = _this.panelFrameContainer) === null || _a === void 0 ? void 0 : _a.removeEventListener('transitionend', _this.handleTransitionEnd);
            // If applicable, remove the close icon used for when the success center isn't loaded since the center is now loaded
            (_b = _this.preloadCloseIcon) === null || _b === void 0 ? void 0 : _b.removeEventListener('click', _this.hide);
            (_d = (_c = _this.preloadCloseIcon) === null || _c === void 0 ? void 0 : _c.parentElement) === null || _d === void 0 ? void 0 : _d.removeChild(_this.preloadCloseIcon);
            _this.preloadCloseIcon = undefined; // mark for GC
        });
        this.subs.push(scr);
        //SuccessCenterSetStyles: When the SuccessCenter iFrame is loading and it is an in-app overlay it will publish the size it needs the iframe to be based on its content
        var scss = this.appSvc.pubsub.subscribe(enums_1.InterfaceCommCodes.SuccessCenterSetStyles, function (message) {
            var _a, _b, _c;
            var propsToSkip = ['width'];
            for (var prop in message.info) {
                if (propsToSkip.indexOf(prop.toLowerCase()) > -1) {
                    continue;
                }
                var styleRule = (_a = message.info) === null || _a === void 0 ? void 0 : _a[prop];
                if (styleRule) {
                    (_c = (_b = _this.panelFrame) === null || _b === void 0 ? void 0 : _b.style) === null || _c === void 0 ? void 0 : _c.setProperty(prop, styleRule, 'important');
                }
            }
        });
        this.subs.push(scss);
        //When an inapp announcement is closed the SuccessCenterLauncher should display the click to see more info alert
        var ac = this.appSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.AnnouncementClosed, function (message) {
            console.info('announcement closure received');
            _this.showMessageBubble(message.info.infoMessage, message.info.announcement);
        });
        this.subs.push(ac);
        //When the SuccessCenter iFrame denotes an announcement has been read it publishes this event telling the SuccessCenterLauncher to update its badge
        var scuub = this.appSvc.pubsub.subscribe(enums_1.InterfaceCommCodes.SuccessCenterUpdateUnreadBadge, function (message) {
            var key = message.info.name;
            if (!key) {
                return;
            }
            var unreadCount = message.info.count;
            _this.successCenterConfig.unreadCounts[key] = unreadCount || 0;
            var totalUnreadCount = _this.getTotalUnreadCount(_this.successCenterConfig.unreadCounts) || 0;
            _this.updateUnreadBadge(totalUnreadCount);
        });
        this.subs.push(scuub);
        var na = this.appSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.NewAnnouncement, function (message) {
            if (!_this.successCenterConfig.displayUnreadBadge || _this.successCenterReadyEventReceived) {
                return;
            }
            //if a new announcement or survey comes in
            // and its supposed to display in the center
            // and the center for this contact will display announcements or surveys
            // but the center has not been authenticated yet
            // increment the unread badge count
            var info = message.info;
            if (info.isRead)
                return;
            if (!_this.messageSvc.isPanelAnnouncement(info))
                return;
            var key = 'announcements';
            if (_this.messageSvc.isSurveyAnnouncement(info)) {
                key = 'surveys';
            }
            _this.successCenterConfig.unreadCounts[key] = (_this.successCenterConfig.unreadCounts[key] || 0) + 1;
            var totalUnreadCount = _this.getTotalUnreadCount(_this.successCenterConfig.unreadCounts);
            _this.updateUnreadBadge(totalUnreadCount);
        });
        this.subs.push(na);
        var ea = this.appSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.ExpireAnnouncement, function (message) {
            if (!_this.successCenterConfig.displayUnreadBadge || _this.successCenterReadyEventReceived) {
                return;
            }
            //if a new announcement or survey is to be expired
            // and it was supposed to displayed in the center
            // and the center for this contact will display announcements or surveys
            // but the center has not been authenticated yet
            // decrement the unread badge count
            var info = message.info;
            if (info.isRead)
                return;
            if (!_this.messageSvc.isPanelAnnouncement(info))
                return;
            var key = 'announcements';
            if (_this.messageSvc.isSurveyAnnouncement(info)) {
                key = 'surveys';
            }
            _this.successCenterConfig.unreadCounts[key] = (_this.successCenterConfig.unreadCounts[key] || 0) - 1;
            var totalUnreadCount = _this.getTotalUnreadCount(_this.successCenterConfig.unreadCounts);
            _this.updateUnreadBadge(totalUnreadCount);
        });
        this.subs.push(ea);
        var amar = this.appSvc.pubsub.subscribe(enums_1.InterfaceCommCodes.AnnouncementMarkAsRead, function (message) {
            _this.messageSvc.SendReadReceipt(message.info.id);
        });
        this.subs.push(amar);
        var aca = this.appSvc.pubsub.subscribe(enums_1.InterfaceCommCodes.AnnouncementClickAudit, function (message) {
            var theId = message.info.id;
            _this.appSvc.debug("[Click Audit " + theId + "]");
            _this.messageSvc.SendClickAudit(theId);
        });
        this.subs.push(aca);
        //When a socket message for refreshing the JourneyChecklistConfig is received, mirror it to the SuccessCenter iFrame so any in-panel JourneyChecklists can update
        var smrc = this.commSvc.registerListener(clientlibs_1.SocketMessageTypes.SOCKETMESSAGETYPE_RefreshChecklistConfig, this.handleChecklistConfigRefresh);
        this.subs.push(smrc);
    };
    SuccessCenterLauncher.prototype.handleChecklistConfigRefresh = function (msg) {
        this.postMirroredMessage(msg);
    };
    SuccessCenterLauncher.prototype.postMirroredMessage = function (message) {
        if (!this.centerWindow) {
            return;
        }
        var transportMessage = clientlibs_1.iFrameUtils.encrypt(this.windowSvc.JSON.stringify(clientlibs_1.iFrameUtils.buildTransportMessage(clientlibs_1.TransportCodes.PubSubMirror, message)));
        //this is the iframe we created for hosting the devless panel so * is fine here
        this.centerWindow.postMessage(transportMessage, '*');
    };
    SuccessCenterLauncher.prototype.buildPanelIframe = function () {
        var _this = this;
        //generate the iframe to house the panel
        var panelFrame = this.windowSvc.createElement('iframe');
        panelFrame.title = 'Success Center Frame';
        panelFrame.id = 'cz_success_center_frame';
        panelFrame.classList.add('cz-success-center-frame-iframe');
        panelFrame.addEventListener('load', function () {
            _this.centerWindow = panelFrame.contentWindow;
        });
        return panelFrame;
    };
    SuccessCenterLauncher.prototype.buildPanelIframeContainer = function () {
        var panelFrameContainer = this.windowSvc.createElement('div');
        panelFrameContainer.classList.add('success-center-panel-frame-container');
        panelFrameContainer.classList.add(this.getInAppOverlayPositionClassFromConfig());
        panelFrameContainer.style.setProperty('width', "" + this.successCenterWidth, 'important');
        panelFrameContainer.addEventListener('transitionend', this.handleTransitionEnd);
        // Build a loader container
        var loaderContainer = this.windowSvc.createElement('div');
        loaderContainer.className = 'sc-panel-frame-loader-container';
        // Build and append a loader element to the loader container
        var loader = this.windowSvc.createElement('div');
        loader.className = 'sc-panel-frame-loader';
        loader.innerHTML = '<p style="margin:0">Loading. Please wait...</p>';
        loaderContainer.appendChild(loader);
        /**
         * Build and append the "preload close icon" to the loader container
         *
         * add an x Icon to close the panel
         * the icon should be removed when the success center frame ready event is received
        **/
        this.preloadCloseIcon = this.windowSvc.createElement('span');
        this.preloadCloseIcon.id = 'cz_success_center_preload_close_icon';
        this.preloadCloseIcon.innerHTML = '&times;';
        this.preloadCloseIcon.title = 'Close the Success Center panel';
        this.preloadCloseIcon.addEventListener('click', this.hide);
        // Append the close icon to the iframe container
        panelFrameContainer.appendChild(this.preloadCloseIcon);
        // Append loader container to the iframe container
        panelFrameContainer.appendChild(loaderContainer);
        return panelFrameContainer;
    };
    /**
     * Setup Helpers
     */
    /**
     * Inject the Custom CSS from the session service into the given frame
     * @param frameDoc
     * @param idSuffix
     * @private
     */
    SuccessCenterLauncher.prototype.addCustomCssToFrame = function (frameDoc, idSuffix) {
        var _a;
        if (!((_a = this.sessionSvc.CurrentAccountContent) === null || _a === void 0 ? void 0 : _a.css)) {
            return;
        }
        var cssOverride = frameDoc.createElement('style');
        cssOverride.id = CZ_CUSTOM_CSS_STYLE_ID_PREFIX + "-" + idSuffix;
        cssOverride.textContent = this.sessionSvc.CurrentAccountContent.css;
        frameDoc.head.appendChild(cssOverride);
    };
    SuccessCenterLauncher.prototype.removeInjectedHtml = function () {
        var _a, _b, _c;
        //assumes everything is added into the successCenterContainer
        (_c = (_b = (_a = this.successCenterContainer) === null || _a === void 0 ? void 0 : _a.parentElement) === null || _b === void 0 ? void 0 : _b.removeChild) === null || _c === void 0 ? void 0 : _c.call(_b, this.successCenterContainer);
        this.panelFrameContainer = null;
        this.panelFrame = null;
        this.panelLauncher = null;
        this.launcherUnreadBadge = null;
        this.alertFlyoutFrame = null;
        this.seeMoreMessage = null;
    };
    SuccessCenterLauncher.prototype.updateUnreadBadge = function (unreadCount) {
        if (!this.launcherUnreadBadge) {
            return;
        }
        if (unreadCount > 0) {
            this.launcherUnreadBadge.textContent = (unreadCount > 9) ? '9+' : unreadCount.toString();
            this.launcherUnreadBadge.style.removeProperty('display');
        }
        else {
            this.launcherUnreadBadge.style.display = 'none';
        }
    };
    SuccessCenterLauncher.prototype.getInAppOverlayPositionClassFromConfig = function () {
        var panelPosition = this.successCenterConfig.inAppOverlayPositionId === clientlibs_1.InAppOverlayPosition.Left ? 'left' : 'right';
        var panelPosClass = "pos-" + panelPosition;
        return panelPosClass;
    };
    SuccessCenterLauncher.prototype.getTotalUnreadCount = function (unreadCounts) {
        var totalUnreadCount = 0;
        if (this.successCenterConfig && this.successCenterConfig.hasAnnouncementsWidget) {
            totalUnreadCount += unreadCounts['announcements'] || 0;
        }
        if (this.successCenterConfig && this.successCenterConfig.hasSurveysWidget) {
            totalUnreadCount += unreadCounts['surveys'] || 0;
        }
        return totalUnreadCount;
    };
    SuccessCenterLauncher.prototype.getCollapsedStyleData = function () {
        var prop = this.successCenterConfig.inAppOverlayPositionId === clientlibs_1.InAppOverlayPosition.Left ? 'left' : 'right';
        return {
            property: prop,
            value: "-" + this.successCenterWidth
        };
    };
    SuccessCenterLauncher.prototype.applyLauncherOffsets = function () {
        var _a = this.successCenterConfig, launchIconPositionId = _a.launchIconPositionId, launchIconTypeId = _a.launchIconTypeId, launchIconOffsetHorizontal = _a.launchIconOffsetHorizontal, launchIconOffsetVertical = _a.launchIconOffsetVertical, hasNoOffsets = (clientlibs_1.CoreUtils.isNullOrUndefined(launchIconOffsetHorizontal) && clientlibs_1.CoreUtils.isNullOrUndefined(launchIconOffsetVertical));
        var getPosWithOffsets = function (launchIconTypeId, launchIconPositionId, vOffset, hOffset) {
            var isBottomOrTopCenter = [clientlibs_1.LaunchIconPosition.BottomCenter, clientlibs_1.LaunchIconPosition.TopCenter].indexOf(launchIconPositionId) > -1, isLeftOrRightBottom = [clientlibs_1.LaunchIconPosition.BottomRight, clientlibs_1.LaunchIconPosition.BottomLeft].indexOf(launchIconPositionId) > -1, isLeftOrRightTop = [clientlibs_1.LaunchIconPosition.TopLeft, clientlibs_1.LaunchIconPosition.TopRight].indexOf(launchIconPositionId) > -1, isRightSide = [clientlibs_1.LaunchIconPosition.BottomRight, clientlibs_1.LaunchIconPosition.RightCenter, clientlibs_1.LaunchIconPosition.TopRight].indexOf(launchIconPositionId) > -1, isTop = [clientlibs_1.LaunchIconPosition.TopLeft, clientlibs_1.LaunchIconPosition.TopCenter, clientlibs_1.LaunchIconPosition.TopRight].indexOf(launchIconPositionId) > -1, isFloatIcon = launchIconTypeId === clientlibs_1.LaunchIconType.Float;
            //Depending on the position of the icon, we have different starting
            //top/bottom/left/right styles applied in scss...
            var ogVerticalPos = isFloatIcon && isBottomOrTopCenter ? 25 :
                (isLeftOrRightBottom || isLeftOrRightTop) ? 20 : 0;
            var ogHorizontalPos = isBottomOrTopCenter || !isFloatIcon ? 0 : 18;
            var hPos = isRightSide ? (hOffset * -1) : hOffset, vPos = isTop ? (vOffset * -1) : vOffset;
            return {
                hPos: hPos + ogHorizontalPos,
                vPos: vPos + ogVerticalPos
            };
        };
        if (hasNoOffsets) {
            return;
        }
        var _b = getPosWithOffsets(launchIconTypeId, launchIconPositionId, launchIconOffsetVertical, launchIconOffsetHorizontal), hPos = _b.hPos, vPos = _b.vPos;
        switch (launchIconPositionId) {
            case clientlibs_1.LaunchIconPosition.BottomLeft:
                this.successCenterContainer.style.setProperty('left', hPos + "px", 'important');
                this.successCenterContainer.style.setProperty('bottom', vPos + "px", 'important');
                break;
            case clientlibs_1.LaunchIconPosition.BottomRight:
                this.successCenterContainer.style.setProperty('right', hPos + "px", 'important');
                this.successCenterContainer.style.setProperty('bottom', vPos + "px", 'important');
                break;
            case clientlibs_1.LaunchIconPosition.TopLeft:
                this.successCenterContainer.style.setProperty('left', hPos + "px", 'important');
                this.successCenterContainer.style.setProperty('top', vPos + "px", 'important');
                break;
            case clientlibs_1.LaunchIconPosition.TopCenter:
                this.successCenterContainer.style.setProperty('left', "calc(50% + " + hPos + "px)", 'important');
                this.successCenterContainer.style.setProperty('top', vPos + "px", 'important');
                break;
            case clientlibs_1.LaunchIconPosition.TopRight:
                this.successCenterContainer.style.setProperty('right', hPos + "px", 'important');
                this.successCenterContainer.style.setProperty('top', vPos + "px", 'important');
                break;
            case clientlibs_1.LaunchIconPosition.RightCenter:
                this.successCenterContainer.style.setProperty('right', hPos + "px", 'important');
                this.successCenterContainer.style.setProperty('top', "calc(50% + " + vPos + "px)", 'important');
                break;
            case clientlibs_1.LaunchIconPosition.BottomCenter:
                this.successCenterContainer.style.setProperty('bottom', vPos + "px", 'important');
                this.successCenterContainer.style.setProperty('left', "calc(50% + " + hPos + "px)", 'important');
                break;
            case clientlibs_1.LaunchIconPosition.LeftCenter:
                this.successCenterContainer.style.setProperty('left', hPos + "px", 'important');
                this.successCenterContainer.style.setProperty('top', "calc(50% + " + vPos + "px)", 'important');
                break;
        }
    };
    SuccessCenterLauncher.prototype.addCziAvatarClassNameToElement = function (el) {
        switch (this.successCenterConfig.launchAvatarTypeId) {
            case clientlibs_1.LaunchAvatarType.Heartbeat: {
                el.classList.add('czi-heartbeat');
                break;
            }
            case clientlibs_1.LaunchAvatarType.ConciergeBell: {
                el.classList.add('czi-concierge-bell');
                break;
            }
            case clientlibs_1.LaunchAvatarType.LightBulb: {
                el.classList.add('czi-lightbulb');
                break;
            }
            case clientlibs_1.LaunchAvatarType.Info: {
                el.classList.add('czi-info-circle');
                break;
            }
            case clientlibs_1.LaunchAvatarType.Shield: {
                el.classList.add('czi-shield-alt');
                break;
            }
            case clientlibs_1.LaunchAvatarType.Heart:
            default: {
                el.classList.add('czi-heart');
                break;
            }
        }
    };
    return SuccessCenterLauncher;
}(IndependentLauncher_1.IndependentLauncher));
exports.SuccessCenterLauncher = SuccessCenterLauncher;


/***/ }),

/***/ "./src/core/launchers/SuccessPanelLauncher.ts":
/*!****************************************************!*\
  !*** ./src/core/launchers/SuccessPanelLauncher.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CZ_CUSTOM_CSS_TOP_WINDOW_SUFFIX = exports.CZ_CUSTOM_CSS_STYLE_ID_PREFIX = exports.SuccessPanelLauncher = void 0;
// Libs
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
// Classes / Utilities
var PanelDisplay_1 = __webpack_require__(/*! @src/core/PanelDisplay */ "./src/core/PanelDisplay.ts");
var errorLogger_1 = __importDefault(__webpack_require__(/*! @src/core/errorLogger */ "./src/core/errorLogger.ts"));
var AccountRepWidget_1 = __webpack_require__(/*! @src/core/panel-widgets/AccountRepWidget */ "./src/core/panel-widgets/AccountRepWidget.ts");
var AnnouncementsWidget_1 = __webpack_require__(/*! @src/core/panel-widgets/AnnouncementsWidget */ "./src/core/panel-widgets/AnnouncementsWidget.ts");
var tenant_service_1 = __webpack_require__(/*! @src/services/tenant.service */ "./src/services/tenant.service.ts");
var JourneyChecklistCollectionWidget_1 = __webpack_require__(/*! @src/core/panel-widgets/JourneyChecklistCollectionWidget */ "./src/core/panel-widgets/JourneyChecklistCollectionWidget.ts");
// Constants / Enums
var CZ_SUCCESS_CENTER_FRAMES_STYLES_ID = 'cz-success-frames-styles', CZ_CUSTOM_CSS_STYLE_ID_PREFIX = 'cz-custom-css-styles', CZ_BRANDING_STYLES_ID = 'cz-branding-styles', CZ_CUSTOM_CSS_TOP_WINDOW_SUFFIX = 'top-window', SUCCESS_CENTER_TEMPLATE_PATH = 'template/successPanelContent.html';
exports.CZ_CUSTOM_CSS_STYLE_ID_PREFIX = CZ_CUSTOM_CSS_STYLE_ID_PREFIX;
exports.CZ_CUSTOM_CSS_TOP_WINDOW_SUFFIX = CZ_CUSTOM_CSS_TOP_WINDOW_SUFFIX;
var SuccessPanelLauncher = /** @class */ (function (_super) {
    __extends(SuccessPanelLauncher, _super);
    function SuccessPanelLauncher(parentDocument, appSvc, tenantSvc, windowSvc, storageSvc, sessionSvc, messageSvc, templateCache, commSvc, checklistSvc, openOnStart) {
        var _this = _super.call(this, appSvc, tenantSvc, windowSvc, storageSvc, sessionSvc, messageSvc, templateCache) || this;
        _this.parentDocument = parentDocument;
        _this.commSvc = commSvc;
        _this.checklistSvc = checklistSvc;
        _this.openOnStart = openOnStart;
        _this.subIds = {};
        _this.isHalted = false;
        _this.isCustomAvatarPositioningEnabled = false;
        if (!_this.sessionSvc.PanelEnabled) {
            console.info('Panel Disabled via Functionality');
            return _this;
        }
        if (_this.sessionSvc.IsSilent) {
            console.info('Panel Silent');
            return _this;
        }
        _this.show = _this.show.bind(_this);
        _this.hide = _this.hide.bind(_this);
        _this.onDigest = _this.onDigest.bind(_this);
        _this.onHalt = _this.onHalt.bind(_this);
        _this.showDevlessPanel = _this.showDevlessPanel.bind(_this);
        _this.onAfterSuccessCenterFrameLoad = _this.onAfterSuccessCenterFrameLoad.bind(_this);
        _this.isCustomAvatarPositioningEnabled = _this.tenantSvc.FeatureEnabled(tenant_service_1.FeatureFlags.SuccessPanelAvatarPositionEnabled);
        _this.onInit();
        return _this;
    }
    Object.defineProperty(SuccessPanelLauncher.prototype, "topWindow", {
        get: function () {
            var _a;
            return ((_a = this.parentDocument) === null || _a === void 0 ? void 0 : _a.defaultView) || null;
        },
        enumerable: false,
        configurable: true
    });
    SuccessPanelLauncher.prototype.onInit = function () {
        var _this = this;
        //Build Data Context for Templating Full Panel
        var data = {};
        // Manipulate initialConnection for merge
        data.avatarUrl = this.sessionSvc.LaunchAvatarUrl;
        //Map Account Owner data to be templated
        var currentUserAccount = this.tenantSvc.accountOwner;
        if (currentUserAccount) {
            data.userAccountName = currentUserAccount.firstName + " " + currentUserAccount.lastName;
            data.userAccountTitle = currentUserAccount.title || '';
            data.userAccountPhone = currentUserAccount.officePhone || '';
            data.userAccountEmail = currentUserAccount.email || '';
        }
        //add the headerHtml content
        data.headerContent = this.sessionSvc.CurrentAccountContent.header;
        //add the footerHtml content
        data.footerContent = this.sessionSvc.CurrentAccountContent.footer;
        // Success Panel V2 (in a frame)
        this.loadTopStyles(function () {
            // Add custom css to PARENT DOCUMENT
            _this.addCustomCssToFrame(_this.parentDocument, CZ_CUSTOM_CSS_TOP_WINDOW_SUFFIX);
            var templateCdn = _this.appSvc.addCdn(SUCCESS_CENTER_TEMPLATE_PATH + '?ak=' + encodeURIComponent(_this.commSvc.appKey));
            _this.appSvc.templater.compile_template(templateCdn, data, function (result) {
                _this.buildSuccessCenter(result);
            });
        }, function (e) {
            //if we got there it means the success Center css failed to load
            // so there is nothing that can be done except shutdown the success Center
            // (note that announcements and usage tracking will still run)
            errorLogger_1.default.report('SuccessPanelLauncher.loadTopStyles', e);
            _this.onHalt();
        });
    };
    // Satisfy parent class abstract methods...
    SuccessPanelLauncher.prototype.show = function (forceOpen) {
        var _this = this;
        try {
            //open base panel
            this.openBasePanel(forceOpen, function () {
                //CSM specific open changes
                _this.panelBody.scrollTop = 0;
            });
        }
        catch (ex) {
            //report?
            errorLogger_1.default.report('SuccessPanelLauncher.show', ex);
        }
    };
    SuccessPanelLauncher.prototype.hide = function () {
        try {
            //close base panel
            this.closeBasePanel();
        }
        catch (ex) {
            //report?
            errorLogger_1.default.report('SuccessPanelLauncher.hide', ex);
        }
    };
    SuccessPanelLauncher.prototype.hidePanelToggle = function () {
        var _a, _b;
        (_b = (_a = this.launcherFrame) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.add('cz-hidden');
    };
    SuccessPanelLauncher.prototype.showPanelToggle = function () {
        var _a, _b;
        // If a devless panel is currently open, don't show the panel launcher
        if (this.sessionSvc.IsDevlessPanelOpen) {
            return;
        }
        (_b = (_a = this.launcherFrame) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.remove('cz-hidden');
    };
    SuccessPanelLauncher.prototype.setLauncherBoundingRectangle = function () {
        if (this.launcherFrame)
            this.launcherBoundingRect = this.launcherFrame.getBoundingClientRect();
    };
    /**
     * Loads success center styles into the topmost window's document <head>.
     */
    SuccessPanelLauncher.prototype.loadTopStyles = function (onSuccess, onError) {
        var spFrameLink = this.windowSvc.createElement('link');
        spFrameLink.addEventListener('load', function () {
            onSuccess();
        });
        spFrameLink.addEventListener('error', function (ev) {
            var msg = '';
            if (ev) {
                // Event has an error. Use that and bail
                if (clientlibs_1.CoreUtils.hasOwnProp(ev, 'error') && ev.error) {
                    onError(ev.error);
                    return;
                }
                // Try and discern a meaningful message from the error event...
                if (typeof ev === 'string')
                    msg = ev;
                else if (clientlibs_1.CoreUtils.hasOwnProp(ev, 'message'))
                    msg = ev.message;
            }
            onError(new Error(msg || 'success_center_frames.css failed to load.'));
        });
        spFrameLink.id = CZ_SUCCESS_CENTER_FRAMES_STYLES_ID;
        spFrameLink.type = 'text/css';
        spFrameLink.rel = 'stylesheet';
        spFrameLink.href = this.appSvc.addCdn('css/success_center_frames.css');
        this.parentDocument.head.appendChild(spFrameLink);
    };
    SuccessPanelLauncher.prototype.buildSuccessCenter = function (panelContent) {
        var _this = this;
        try {
            this.successCenterContainer = this.windowSvc.createElement('div');
            this.successCenterContainer.id = 'cz_success_center_container';
            this.successCenterContainer.classList.add('cz-hidden');
            var bod = this.parentDocument.querySelector('body');
            if (!bod) {
                this.appSvc.debug('No body element found to add success panel. Exiting early.');
                return;
            }
            if (!this.topWindow) {
                this.appSvc.debug('No top window found when adding success center. Exiting early.');
                return;
            }
            bod.appendChild(this.successCenterContainer);
            // Load the launcher
            this.addSuccessCenterLauncherFrame(function (err) {
                if (err) {
                    _this.handleFrameLoadError(err, 'addSuccessCenterLauncherFrame load');
                    return;
                }
                // Load the flyout
                _this.addSuccessCenterAlertFlyoutFrame(function (err) {
                    if (err) {
                        _this.handleFrameLoadError(err, 'addSuccessCenterAlertFlyoutFrame load');
                        return;
                    }
                    // Load the content panel
                    _this.addSuccessCenterFrame(panelContent, _this.onAfterSuccessCenterFrameLoad);
                });
            });
        }
        catch (err) {
            this.handleFrameLoadError(err, 'buildSuccessCenter catch');
        }
    };
    SuccessPanelLauncher.prototype.addSuccessCenterLauncherFrame = function (onAfterLoad) {
        var _this = this;
        var html = "\n        <section id=\"cz-success-center-launch-wrapper\">\n            <div class=\"cz-unread-badge\" style=\"display:none;\"></div>\n            <div class=\"cz-success-center-launch-avatar-img img-circle\"\n                style=\"background-image: url('" + this.sessionSvc.LaunchAvatarUrl + "');\"></div>\n        </section>";
        this.launcherFrame = this.windowSvc.createElement('iframe');
        this.launcherFrame.id = 'cz_success_center_launcher_frame';
        this.launcherFrame.addEventListener('load', function (e) {
            var error;
            try {
                var frame = e.target, frameDoc = frame.contentWindow.document, bod = frameDoc.body, styleLink = frameDoc.createElement('link');
                styleLink.id = 'cz-launcher-styles';
                styleLink.type = 'text/css';
                styleLink.rel = 'stylesheet';
                styleLink.href = _this.appSvc.addCdn('css/in_frame_success_center_launcher.css');
                frameDoc.head.appendChild(styleLink);
                // Add custom CSS
                _this.addCustomCssToFrame(frameDoc, 'launcher');
                bod.className = 'cz-launch-panel-body';
                bod.innerHTML = html;
                _this.launcherUnreadBadge = frameDoc.querySelector('.cz-unread-badge');
                frameDoc.addEventListener('click', function () {
                    _this.show();
                });
            }
            catch (exc) {
                error = exc;
            }
            // Execute "after load" stuff
            onAfterLoad(error);
        }, { once: true });
        this.successCenterContainer.appendChild(this.launcherFrame);
    };
    SuccessPanelLauncher.prototype.addSuccessCenterAlertFlyoutFrame = function (onAfterLoad) {
        var _this = this;
        var alertFlyoutHtml = "\n        <div class=\"cz-alert-message-body\">\n            <p class=\"cz-alert-message-text\">Click here to see that info again!</p>\n        </div>";
        this.alertFlyoutFrame = this.windowSvc.createElement('iframe');
        this.alertFlyoutFrame.id = 'cz_success_center_alert_flyout_frame';
        this.alertFlyoutFrame.classList.add('cz-hidden');
        this.alertFlyoutFrame.addEventListener('load', function (e) {
            var err;
            try {
                var frame = e.target, frameDoc = frame.contentWindow.document, bod = frameDoc.body, styleLink = frameDoc.createElement('link'), fontLink = frameDoc.createElement('link');
                styleLink.rel = 'stylesheet';
                styleLink.type = 'text/css';
                styleLink.href = _this.appSvc.addCdn('css/in_frame_success_center_alert_flyout.css');
                fontLink.type = 'text/css';
                fontLink.rel = 'stylesheet';
                fontLink.href = 'https://fonts.googleapis.com/css?family=Open+Sans';
                frameDoc.head.appendChild(styleLink);
                frameDoc.head.appendChild(fontLink);
                // Add custom CSS
                _this.addCustomCssToFrame(frameDoc, 'flyout');
                bod.innerHTML = alertFlyoutHtml;
                _this.seeMoreMessage = frameDoc.querySelector('.cz-alert-message-body');
                if (_this.isCustomAvatarPositioningEnabled) {
                    var avatarPosition = _this.getPositionalClassFromConfig(_this.sessionSvc.LaunchIconPositionId);
                    var launchIconHorizontalPosition = avatarPosition.indexOf('top-center') > -1 ||
                        avatarPosition.indexOf('bottom-center') > -1 ? 'left' :
                        avatarPosition.indexOf('right') > -1 ? 'right' : 'left';
                    bod.classList.add("pos-" + launchIconHorizontalPosition);
                    _this.seeMoreMessage.classList.add("alert-message-" + launchIconHorizontalPosition);
                    _this.seeMoreMessage.classList.add('alert-message-' + _this.sessionSvc.AvatarType);
                }
                else {
                    bod.classList.add("pos-" + _this.sessionSvc.PanelPosition);
                    _this.seeMoreMessage.classList.add('alert-message-' + _this.sessionSvc.PanelPosition);
                    _this.seeMoreMessage.classList.add('alert-message-' + _this.sessionSvc.AvatarType);
                }
                // add listener for clicks on Show More Info container
                _this.seeMoreMessage.addEventListener('click', function () { return _this.show(); });
            }
            catch (exc) {
                err = exc;
            }
            // Execute "after load" stuff
            onAfterLoad(err);
        }, { once: true });
        this.successCenterContainer.appendChild(this.alertFlyoutFrame);
    };
    SuccessPanelLauncher.prototype.addSuccessCenterFrame = function (panelContent, onAfterLoad) {
        var _this = this;
        this.contentFrame = this.windowSvc.createElement('iframe');
        this.contentFrame.id = 'cz_success_center_frame';
        this.contentFrame.classList.add('collapsed');
        this.contentFrame.addEventListener('load', function (e) {
            var error;
            try {
                var frame = e.target, win = frame.contentWindow, doc = win.document, bod = doc.body, czStyleLink = doc.createElement('link'), fontLink = doc.createElement('link');
                czStyleLink.id = 'cz-styles';
                czStyleLink.type = 'text/css';
                czStyleLink.rel = 'stylesheet';
                czStyleLink.href = _this.appSvc.addCdn('css/in_frame_success_center.css');
                fontLink.type = 'text/css';
                fontLink.rel = 'stylesheet';
                fontLink.href = 'https://fonts.googleapis.com/css?family=Open+Sans';
                doc.head.appendChild(czStyleLink);
                doc.head.appendChild(fontLink);
                // Add custom CSS
                _this.addCustomCssToFrame(doc, 'sc');
                bod.innerHTML = panelContent;
                _this.contentFrameCloseButton = doc.querySelector('.cz-close');
                _this.contentFrameCloseButton && _this.contentFrameCloseButton.addEventListener('click', _this.hide);
                _this.devlessWrench = doc.querySelector('.cz-admin');
                _this.panelBody = doc.querySelector('.cz-sidebar-panel');
                _this.panelHeader = doc.getElementById('cz-success-center-header');
                _this.panelFooter = doc.querySelector('.cz-footer');
                //devless panel toggle event handler
                if (_this.sessionSvc.DevlessPanelEnabled) {
                    //listen for devless gear icon clicks
                    _this.devlessWrench.addEventListener('click', _this.showDevlessPanel);
                    //listen for devless panel hide events to reshow the gear icon
                    _this.subIds['DevlessHideSubId'] = _this.appSvc.pubsub.subscribe(clientlibs_1.DevlessEvents.DevlessHide, function () {
                        _this.devlessWrench && _this.devlessWrench.classList.remove('hidden');
                    });
                    if (!_this.sessionSvc.IsDevlessPanelOpen) {
                        _this.devlessWrench && _this.devlessWrench.classList.remove('hidden');
                    }
                }
                else {
                    // If devless functionality is not enabled, make sure we're not using a cached version of the "open" state from session storage
                    _this.sessionSvc.IsDevlessPanelOpen = false;
                }
                // Widget logic...
                _this.populateWidgets(doc);
                var czHeader = doc.getElementById('cz-header'), _a = _this.sessionSvc, ShowAccountOwner = _a.ShowAccountOwner, _b = _a.CurrentAccountContent, header = _b.header, footer = _b.footer;
                if (czHeader && !header) {
                    czHeader.style.display = 'none';
                }
                // Shadow element used to house additional html content (header, footer) and determine additional UI fonts that are needed
                var shadowEl = _this.windowSvc.createElement('div');
                if (ShowAccountOwner || header) {
                    bod.classList.add('has-header-content');
                }
                if (header)
                    shadowEl.innerHTML = _this.sessionSvc.CurrentAccountContent.header;
                if (footer)
                    shadowEl.innerHTML += _this.sessionSvc.CurrentAccountContent.footer;
                if (shadowEl.innerHTML) {
                    var additionalFontFamilyIds = [];
                    var styledElements = shadowEl.querySelectorAll('[style]'), sel = styledElements.length;
                    // Loop the node list and find any elements with font family styles applied
                    for (var i = 0; i < sel; i++) {
                        var el = styledElements[i];
                        if (!el.style.fontFamily)
                            continue;
                        // Determine if this element's font family style maps to a UIFontFamily we care about
                        var foundFamilyId = _this.tenantSvc.getUIFontFamilyMappingId(el.style.fontFamily);
                        // If a font family is found, add it to our font family id collection
                        if (foundFamilyId && additionalFontFamilyIds.indexOf(foundFamilyId) === -1)
                            additionalFontFamilyIds.push(foundFamilyId);
                    }
                    // Try to build out a google font request url based on the ui font family id collection from above
                    var additionalFontUrl = _this.tenantSvc.buildUIFontFamilyCssRequestUrl(additionalFontFamilyIds);
                    // Append a google font <link> tag to our success center content panel, if applicable
                    if (additionalFontUrl) {
                        var fontLink_1 = doc.createElement('link');
                        fontLink_1.id = 'cz-additional-panel-fonts';
                        fontLink_1.rel = 'stylesheet';
                        fontLink_1.href = additionalFontUrl;
                        doc.head.appendChild(fontLink_1);
                    }
                }
                // mark shadowEl for gc
                shadowEl = null;
            }
            catch (exc) {
                error = exc;
            }
            // Execute "after load" stuff
            onAfterLoad(error);
        }, { once: true });
        this.successCenterContainer.appendChild(this.contentFrame);
    };
    SuccessPanelLauncher.prototype.addCustomCssToFrame = function (frameDoc, idSuffix) {
        var _a;
        if (!((_a = this.sessionSvc.CurrentAccountContent) === null || _a === void 0 ? void 0 : _a.css)) {
            return;
        }
        var cssOverride = frameDoc.createElement('style');
        cssOverride.id = CZ_CUSTOM_CSS_STYLE_ID_PREFIX + "-" + idSuffix;
        cssOverride.textContent = this.sessionSvc.CurrentAccountContent.css;
        frameDoc.head.appendChild(cssOverride);
    };
    SuccessPanelLauncher.prototype.onAfterSuccessCenterFrameLoad = function (err) {
        var _this = this;
        if (err) {
            this.handleFrameLoadError(err, 'addSuccessCenterFrame load');
            return;
        }
        //apply Branding needs to happen after
        // populate widgets so that any widget branding
        // gets properly applied
        this.applyBranding();
        var launcherBody = this.launcherFrame.contentDocument.body;
        var panelPosClass = "pos-" + this.sessionSvc.PanelPosition;
        if (this.isCustomAvatarPositioningEnabled) {
            var launcherIconPositionClass = this.getPositionalClassFromConfig(this.sessionSvc.LaunchIconPositionId);
            this.launcherFrame.classList.add('cz-independent-frame-container');
            this.launcherFrame.classList.add('cz-independent-frame');
            this.launcherFrame.classList.add(launcherIconPositionClass);
            this.launcherFrame.classList.add('launcher');
            this.alertFlyoutFrame.classList.add(launcherIconPositionClass);
            if (this.sessionSvc.AvatarType === 'tabbed') {
                this.launcherFrame.classList.add('tabbed');
                this.launcherFrame.classList.add('tabbed-avatar');
                launcherBody.classList.add('tabbed'); // class for launch frame styling context
                this.alertFlyoutFrame.classList.add('tabbed-avatar');
            }
            else {
                launcherBody.classList.add('float'); // class for launch frame styling context
            }
            //below follows the original class adding instructions...
        }
        else {
            this.alertFlyoutFrame.classList.add(panelPosClass);
            launcherBody.classList.add(panelPosClass);
            this.contentFrame.classList.add(panelPosClass);
            if (this.sessionSvc.AvatarType === 'tabbed') {
                this.launcherFrame.classList.add('tabbed-avatar');
                this.launcherFrame.classList.add(this.tabbedAvatarPosition + "-tab");
                this.launcherFrame.classList.add(this.sessionSvc.PanelPosition + "-tab");
                launcherBody.classList.add('tabbed'); // class for launch frame styling context
                this.alertFlyoutFrame.classList.add('tabbed');
            }
            else {
                this.launcherFrame.classList.add("floating-avatar-" + this.sessionSvc.PanelPosition);
                launcherBody.classList.add('floating'); // class for launch frame styling context
                this.alertFlyoutFrame.classList.add('floating'); // class for flyout frame styling context
            }
        }
        this.contentFrame.classList.add(panelPosClass);
        this.successCenterContainer.classList.remove('cz-hidden');
        // Digest and Halt subscriptions
        this.subIds['digestSubId'] = this.appSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.DIGEST, this.onDigest);
        this.subIds['haltSubId'] = this.appSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.HALT, this.onHalt);
        this.windowSvc.window.setTimeout(function () {
            try {
                //if panel was open reopen it
                if (_this.basePanelVisible || _this.openOnStart) {
                    _this.show(true);
                }
                _this.appSvc.pubsub.publish(clientlibs_1.ChurnZeroAppEvents.PanelReady);
                if (_this.contentFrame) {
                    var loadCompleteEvt = _this.parentDocument.createEvent('Event');
                    loadCompleteEvt.initEvent('czsuccesscenterloadcomplete', true, true);
                    _this.contentFrame.dispatchEvent(loadCompleteEvt);
                }
            }
            catch (ex) {
                //report?
                errorLogger_1.default.report('SuccessPanelLauncher.onAfterSuccessCenterFrameLoad timeout fn', ex);
            }
        }, 500);
    };
    SuccessPanelLauncher.prototype.handleFrameLoadError = function (err, additionalInfo) {
        this.onHalt();
        var msg = 'Success Center frame load error';
        if (additionalInfo)
            msg += ": " + additionalInfo;
        errorLogger_1.default.report(msg, err);
    };
    SuccessPanelLauncher.prototype.populateWidgets = function (doc) {
        var _this = this;
        var _a, _b, _c, _d, _e;
        /** Account Rep */
        var accountRepWidget = new AccountRepWidget_1.AccountRepWidget(this.sessionSvc, this.tenantSvc, doc);
        this.panelWidgets.push(accountRepWidget);
        //TEMP: hack to get around having to alter the template; should be removed once released to all
        var oldPane = doc.getElementById('cz-account-rep-pane');
        if (oldPane) {
            (_a = oldPane.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(oldPane);
        }
        (_b = this.panelHeader) === null || _b === void 0 ? void 0 : _b.appendChild(accountRepWidget.getContainer());
        /** Journey Checklists **/
        if (this.tenantSvc.FeatureEnabled(tenant_service_1.ReleaseGates.JourneyChecklistReleased)) {
            var jcWidget = new JourneyChecklistCollectionWidget_1.JourneyChecklistCollectionWidget(doc, this.sessionSvc, this.checklistSvc, this.windowSvc, this.commSvc, this.appSvc, this.tenantSvc);
            this.panelWidgets.push(jcWidget);
            (_c = this.panelBody) === null || _c === void 0 ? void 0 : _c.insertBefore(jcWidget.getContainer(), this.panelBody.firstChild);
        }
        /** Announcements **/
        var announcementsWidget = new AnnouncementsWidget_1.AnnouncementsWidget(doc, this.messageSvc, this.sessionSvc, this.appSvc, this.windowSvc, this.templateCache);
        this.panelWidgets.push(announcementsWidget);
        //TEMP: hack to get around having to alter the template; should be removed once released to all
        oldPane = doc.getElementById('cz-announcements');
        if (oldPane) {
            (_d = oldPane.parentElement) === null || _d === void 0 ? void 0 : _d.removeChild(oldPane);
        }
        (_e = this.panelBody) === null || _e === void 0 ? void 0 : _e.insertBefore(announcementsWidget.getContainer(), this.panelFooter);
        //set up listener for when announcements are closed
        this.subIds['announcementListenerId'] = this.appSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.AnnouncementClosed, function (message) {
            console.info('announcement closure received');
            _this.showMessageBubble(message.info.infoMessage);
        });
        //set up listener for when announcements are added to the panel
        this.subIds['announcementAddedToPanelListenerId'] = this.appSvc.pubsub.subscribe(AnnouncementsWidget_1.AnnouncementsWidget.AnnouncementAddedToPanelEvent, function () {
            _this.panelBody.scrollTop = 0;
        });
        //set up listener for unread count changes
        this.subIds['unreadAnnouncementCountChangeEventListenerId'] = this.appSvc.pubsub.subscribe(AnnouncementsWidget_1.AnnouncementsWidget.UnreadAnnouncementCountChangeEvent, function (message) {
            var unreadCount = message.info.count;
            if (unreadCount > 0) {
                _this.launcherUnreadBadge.textContent = (unreadCount > 9) ? '9+' : unreadCount.toString();
                _this.launcherUnreadBadge.style.removeProperty('display');
            }
            else {
                _this.launcherUnreadBadge.style.display = 'none';
            }
        });
    };
    SuccessPanelLauncher.prototype.applyBranding = function () {
        var _a, _b;
        var branding = (_b = (_a = this.sessionSvc) === null || _a === void 0 ? void 0 : _a.CurrentAccountContent) === null || _b === void 0 ? void 0 : _b.branding;
        if (!branding) {
            return;
        }
        var parentDocStyles = '', launcherStyles = '', flyoutStyles = '', scStyles = '';
        var avatar = branding.avatar, moreInfo = branding.moreInfo, panel = branding.panel, checklist = branding.checklist;
        var wrapInRule = function (selector, rules) {
            return selector + " { " + rules.join(' ') + " }";
        };
        var brandingItemsToIgnore = ['fontFamilyId'];
        //[NOTE] This might be a good addition to styleUtils? Added here to test this out
        //without having to edit clientlibs for the time being.
        //(just a suggestion, no biggie if we punt this.
        var appendCssUnit = function (brandingItemKey, brandingItem) {
            switch (brandingItemKey) {
                case 'fontSize':
                    return brandingItem[brandingItemKey] + "px";
                default:
                    return brandingItem[brandingItemKey];
            }
        };
        var mapBrandingItemToCSSProps = function (brandingItem) {
            var rules = [];
            for (var k in brandingItem) {
                if (clientlibs_1.CoreUtils.hasOwnProp(brandingItem, k) && (brandingItem[k] || '').toString().trim().length > 0 && brandingItemsToIgnore.indexOf(k) === -1) {
                    rules.push(clientlibs_1.StyleUtils.camelCaseToDash(k) + ':' + appendCssUnit(k, brandingItem) + ' !important;');
                }
            }
            return rules;
        };
        var inheritValue = function (to, property, from) {
            if (!to || !from || !property) {
                return;
            }
            to[property] = to[property] || from[property];
        };
        // Success center launcher frame styles
        if (avatar) {
            var glowColor = avatar.glowColor, tabBackgroundColor = avatar.tabBackgroundColor;
            //Avatar Glow Color
            if ((glowColor || '').trim().length) {
                var glowStyle = "@keyframes czGlowCustom { 20% { box-shadow: 0 0 10px " + branding.avatar.glowColor + " ; }} ";
                glowStyle += '.cz-success-center-launch-avatar-img {animation-name: czGlowCustom !important;}';
                // brandingStyleSheet += glowStyle;
                launcherStyles += glowStyle;
            }
            //Tabbed Avatar Background Color
            if ((tabBackgroundColor || '').trim().length) {
                // let tabStyles = mapBrandingItemToCSSProps({ backgroundColor: branding.avatar.tabBackgroundColor });
                // brandingStyleSheet += wrapInRule('#czChatButtonWrapper.tabbed-avatar', tabStyles);
                // launcherStyles += wrapInRule('.cz-launch-panel-body.tabbed', tabStyles);
                // tabStyles = mapBrandingItemToCSSProps({ borderColor: branding.avatar.tabBackgroundColor });
                // brandingStyleSheet += wrapInRule('#czChatButtonWrapper.tabbed-avatar .cz-chat-button-2', tabStyles);
                // launcherStyles += wrapInRule('.cz-launch-panel-body.tabbed .cz-success-center-launch-avatar-img', tabStyles);
                var tabBackgroundColor_1 = branding.avatar.tabBackgroundColor, tabStyles = mapBrandingItemToCSSProps({
                    backgroundColor: tabBackgroundColor_1,
                    borderColor: tabBackgroundColor_1
                });
                parentDocStyles += wrapInRule('#cz_success_center_launcher_frame.tabbed-avatar', tabStyles);
            }
        }
        // Success center alert flyout frame styles
        if (moreInfo) {
            //More Info Bubble Background Color
            var _c = branding.moreInfo, backgroundColor = _c.backgroundColor, color = _c.color;
            if ((backgroundColor || '').trim().length) {
                //now that we use inherit in success_center_alert_flyout.scss, we can apply border color here...
                var tabStyles = mapBrandingItemToCSSProps({
                    backgroundColor: backgroundColor,
                    borderColor: backgroundColor,
                });
                flyoutStyles += wrapInRule('.cz-alert-message-body', tabStyles);
            }
            if ((color || '').trim().length) {
                var tabStyles = mapBrandingItemToCSSProps({ color: color });
                flyoutStyles += wrapInRule('.cz-alert-message-body', tabStyles);
            }
        }
        // Success center frame styles
        if (panel) {
            var zIndex = panel.zIndex, backgroundColor = panel.backgroundColor;
            //Apply whole panel z-index to launcher, panel and flyout frames
            if (zIndex) {
                var zIndexStyles = mapBrandingItemToCSSProps({ zIndex: zIndex });
                // brandingStyleSheet += wrapInRule('#czChatButtonWrapper', zIndexStyles);
                parentDocStyles += wrapInRule('#cz_success_center_container, #cz_success_center_container #cz_success_center_launcher_frame, #cz_success_center_container #cz_success_center_alert_flyout_frame, #cz_success_center_container #cz_success_center_frame', zIndexStyles);
            }
            if (backgroundColor) {
                branding.header = branding.header || {};
                inheritValue(branding.header, 'backgroundColor', panel);
                branding.accountRepPane = branding.accountRepPane || {};
                inheritValue(branding.accountRepPane, 'backgroundColor', panel);
                branding.announcements = branding.announcements || {};
                inheritValue(branding.announcements, 'backgroundColor', panel);
                branding.footer = branding.footer || {};
                inheritValue(branding.footer, 'backgroundColor', panel);
            }
            //convert fontFamily from a UIFontFamilyId to a style value
            if (panel.fontFamilyId) {
                panel.fontFamily = this.tenantSvc.getUIFontFamilyMappingDisplayValue(panel.fontFamilyId);
            }
        }
        //success center checklist styles
        if (checklist) {
            var convertedStyles = this.checklistSvc.mapChecklistBrandingToProperFormat(checklist);
            var checkListStyles = this.checklistSvc.buildStyleRulesFromCheckListStyleBranding(convertedStyles);
            scStyles += checkListStyles;
        }
        var standardItemsSelectors = {
            panel: 'div#cz-success-center-panel',
            closeIcon: '#cz-success-center-panel .cz-widget-controls span',
            header: '#cz-header',
            accountRepPane: '#cz-account-rep-pane',
            accountRepPaneName: '#cz-account-rep-pane .cz-user-account-name',
            accountRepPaneDetails: '#cz-account-rep-pane .cz-user-account-name small, #cz-account-rep-pane .cz-message-preview',
            announcements: '#cz-announcements .cz-announcement',
            announcementLinks: '#cz-announcements .cz-announcement a, #cz_popover_content .cz-announcement a, .cz-slide-announcement .cz-announcement a',
            announcementLinksHover: '#cz-announcements .cz-announcement a:hover, #cz_popover_content .cz-announcement a:hover, .cz-slide-announcement .cz-announcement a:hover',
            footer: '#cz-success-center-panel .cz-footer',
            footerLinks: '#cz-success-center-panel .cz-footer a',
            footerLinksHover: '#cz-success-center-panel .cz-footer a:hover',
            moreInfo: '#cz-success-center-launch-wrapper .cz-alert-message-body'
        };
        for (var k in standardItemsSelectors) {
            if (clientlibs_1.CoreUtils.hasOwnProp(standardItemsSelectors, k) && clientlibs_1.CoreUtils.hasOwnProp(branding, k)) {
                var styles = mapBrandingItemToCSSProps(branding[k]);
                // brandingStyleSheet += wrapInRule(standardItemsSelectors[k], styles);
                scStyles += wrapInRule(standardItemsSelectors[k], styles);
            }
        }
        var scStyleBlock = this.contentFrame.contentDocument.createElement('style'), scHead = this.contentFrame.contentDocument.head, launcherStyleBlock = this.launcherFrame.contentDocument.createElement('style'), launcherHead = this.launcherFrame.contentDocument.head, flyoutStyleBlock = this.alertFlyoutFrame.contentDocument.createElement('style'), flyoutHead = this.alertFlyoutFrame.contentDocument.head;
        scStyleBlock.textContent = scStyles;
        launcherStyleBlock.textContent = launcherStyles;
        flyoutStyleBlock.textContent = flyoutStyles;
        if (scStyles.length)
            scHead.appendChild(scStyleBlock);
        if (launcherStyles.length)
            launcherHead.appendChild(launcherStyleBlock);
        if (flyoutStyles.length)
            flyoutHead.appendChild(flyoutStyleBlock);
        if (parentDocStyles.length) {
            var pdStyle = this.windowSvc.createElement('style');
            pdStyle.textContent = parentDocStyles;
            pdStyle.id = CZ_BRANDING_STYLES_ID;
            this.parentDocument.head.appendChild(pdStyle);
        }
        if (branding === null || branding === void 0 ? void 0 : branding.panel) {
            var fontLinkHref = this.tenantSvc.buildUIFontFamilyCssRequestUrlFromConfig(branding.panel);
            if (!fontLinkHref)
                return;
            var fontLink = this.contentFrame.contentDocument.createElement('link');
            fontLink.id = 'cz-panel-branding-font-family';
            fontLink.href = fontLinkHref;
            fontLink.rel = 'stylesheet';
            scHead === null || scHead === void 0 ? void 0 : scHead.appendChild(fontLink);
        }
    };
    //show the extra message bubble on the side of the launcher icon
    SuccessPanelLauncher.prototype.showMessageBubble = function (messageText) {
        //if the panel is open, short circuit
        if (this.basePanelVisible) {
            return;
        }
        //build the new message
        var messageHtml = this.appSvc.templater.populateTemplate(this.templateCache.messageBubbleTemplate, {}, true);
        //insert the message as text so that it is xss safe
        var messageElement = clientlibs_1.CoreUtils.createElementFromHTML(this.windowSvc.document, messageHtml);
        messageElement.textContent = messageText;
        //add the new message to the alert message
        this.seeMoreMessage.innerHTML = '';
        this.seeMoreMessage.appendChild(messageElement);
        if (this.isCustomAvatarPositioningEnabled) {
            this.alertFlyoutFrame.style.visibility = 'hidden';
        }
        this.alertFlyoutFrame.classList.remove('cz-hidden');
        //show the panel toggle
        this.panelToggleContent.css('display', '');
    };
    SuccessPanelLauncher.prototype.showDevlessPanel = function () {
        try {
            this.appSvc.pubsub.publish(clientlibs_1.DevlessEvents.DevlessShow, true);
            this.devlessWrench && this.devlessWrench.classList.add('hidden');
        }
        catch (ex) {
            //report?
            errorLogger_1.default.report('SuccessPanelLauncher.showDevlessPanelEvent', ex);
        }
    };
    SuccessPanelLauncher.prototype.onBeforeHalt = function () {
        var _a;
        this.hide();
        //trigger halt of widgets
        var pl = (_a = this.panelWidgets) === null || _a === void 0 ? void 0 : _a.length;
        for (var i = 0; i < pl; i++) {
            this.panelWidgets[i].onHalt();
        }
        this.removeAllInjectedHtml();
    };
    // Base class overrides...
    SuccessPanelLauncher.prototype.removeAllInjectedHtml = function () {
        try {
            // Remove launcher frame refs...
            this.launcherUnreadBadge = null;
            this.launcherFrame = null;
            // Remove flyout frame refs...
            this.seeMoreMessage = null;
            this.alertFlyoutFrame = null;
            // Remove content frame refs...
            this.contentFrameCloseButton = null;
            this.devlessWrench = null;
            this.panelBody = null;
            this.panelHeader = null;
            this.panelFooter = null;
            this.contentFrame = null;
            // Remove SC container from DOM...
            if (this.successCenterContainer && this.successCenterContainer.parentNode)
                this.successCenterContainer.parentNode.removeChild(this.successCenterContainer);
            // Remove SC container ref...
            this.successCenterContainer = null;
            // Remove stylesheets from the parent DOM...
            var sfStyles = this.parentDocument.getElementById(CZ_SUCCESS_CENTER_FRAMES_STYLES_ID), brandingStyles = this.parentDocument.getElementById(CZ_BRANDING_STYLES_ID), customStyles = this.parentDocument.getElementById(CZ_CUSTOM_CSS_STYLE_ID_PREFIX + "-" + CZ_CUSTOM_CSS_TOP_WINDOW_SUFFIX);
            sfStyles && this.parentDocument.head.removeChild(sfStyles);
            brandingStyles && this.parentDocument.head.removeChild(brandingStyles);
            customStyles && this.parentDocument.head.removeChild(customStyles);
        }
        catch (err) {
            console.error("removeAllInjectedHtml Exception: " + (err.stack || 'Unknown'));
        }
    };
    SuccessPanelLauncher.prototype.openBasePanel = function (forceOpen, onOpen) {
        if (this.basePanelVisible && !forceOpen) {
            return;
        }
        //hide the panel avatar
        this.hidePanelToggle();
        // show the content frame
        this.contentFrame.addEventListener('transitionend', function () {
            typeof onOpen === 'function' && onOpen();
        }, { once: true });
        this.contentFrame.classList.remove('collapsed');
        this.alertFlyoutFrame.classList.add('cz-hidden');
        this.basePanelVisible = true;
        //let others know panel was shown
        this.appSvc.pubsub.publish(clientlibs_1.ChurnZeroAppEvents.PanelShow);
    };
    SuccessPanelLauncher.prototype.closeBasePanel = function (onClose) {
        if (!this.basePanelVisible || !this.contentFrame) {
            return;
        }
        this.showPanelToggle();
        this.contentFrame.addEventListener('transitionend', function () {
            typeof onClose === 'function' && onClose();
        }, { once: true });
        this.contentFrame.classList.add('collapsed');
        this.basePanelVisible = false;
        //let others know panel was hidden
        this.appSvc.pubsub.publish(clientlibs_1.ChurnZeroAppEvents.PanelHide);
    };
    SuccessPanelLauncher.prototype.onDigest = function () {
        var _a;
        //do widget digests first so that they may update any shared services
        //trigger digest of widgets
        var pl = (_a = this.panelWidgets) === null || _a === void 0 ? void 0 : _a.length;
        for (var i = 0; i < pl; i++) {
            this.panelWidgets[i].onDigest(this.basePanelVisible);
        }
        //react to any changes
        var panelAnnouncements = this.messageSvc.Announcements.filter(this.messageSvc.isPanelAnnouncement), zeroAnnouncements = panelAnnouncements.length === 0;
        if (!this.launcherFrame)
            return;
        //onDigest, we want to go ahead and set the boundingRect prop
        //and publish that the panel is ready...
        //if I recall it right, this would be the "first" onDigest hit for the launcher.
        if (clientlibs_1.CoreUtils.isNullOrUndefined(this.launcherBoundingRect)) {
            //So now this is a legit boundingRect and we can set it...
            this.setLauncherBoundingRectangle();
            //Moved this from onAfterSuccessCenterFrameLoad since there is not
            //a guarantee that the launcherBoundingRect is not set before frame load...
            if (this.hasLaunchIconOffsets() && this.isCustomAvatarPositioningEnabled) {
                this.addLauncherOffsetsFromConfig();
            }
            //let any subbers know the launcher is ready...
            // ! NOTE: Think we need to publish this event even when the panel is only set to show when there's announcements available.
            this.appSvc.pubsub.publish(clientlibs_1.ChurnZeroAppEvents.PanelLauncherReady);
        }
        !this.launcherFrame.classList.contains('in') && this.launcherFrame.classList.add('in');
        //from convo with George, Alex & Jordo:
        //cleaned up logic that was previously here,
        //making sure the launcher is hidden when
        // a basePanel is open...
        if ((zeroAnnouncements && this.sessionSvc.OnlyShowWhenMessagesExist && !this.sessionSvc.DevlessPanelEnabled) || this.basePanelVisible) {
            this.hidePanelToggle();
        }
        else {
            this.showPanelToggle();
            //Added once QA found a bug with the alert flyout getting
            //a miscalculated offset.
            if (this.isCustomAvatarPositioningEnabled && this.alertFlyoutFrame && this.alertFlyoutFrame.style.getPropertyValue('visibility') === 'hidden') {
                if (this.hasLaunchIconOffsets()) {
                    if (!clientlibs_1.CoreUtils.isNullOrUndefined(this.launcherBoundingRect)) {
                        this.addAlertFlyoutOffsets();
                        this.alertFlyoutFrame.style.visibility = 'visible';
                    }
                }
                else {
                    this.alertFlyoutFrame.style.visibility = 'visible';
                }
            }
        }
    };
    SuccessPanelLauncher.prototype.onHalt = function () {
        // Guard against multiple halts
        if (this.isHalted) {
            return;
        }
        console.log('Halting - Success Center');
        this.onBeforeHalt();
        clientlibs_1.PubSuber.removeAll(this.subIds);
        this.launcherBoundingRect = null;
        this.isHalted = true;
    };
    SuccessPanelLauncher.prototype.addLauncherOffsetsFromConfig = function () {
        //launcherFrame styles, followed by announcementFlyout styles...
        var isFloat = this.sessionSvc.AvatarType === 'float';
        var vOffset = this.sessionSvc.LaunchIconPositionOffsetVertical, hOffset = this.sessionSvc.LaunchIconPositionOffsetHorizontal, floatX = 18, floatY = 25, 
        //launcherFrame X/Y coords...
        _a = this.launcherBoundingRect, lfLeft = _a.left, lfTop = _a.top, topOffset = (vOffset * -1), bottomOffset = vOffset, leftOffset = hOffset, rightOffset = (hOffset * -1);
        switch (this.sessionSvc.LaunchIconPositionId) {
            case clientlibs_1.LaunchIconPosition.TopLeft:
                this.launcherFrame.style.setProperty('top', topOffset + (20) + "px", 'important');
                this.launcherFrame.style.setProperty('left', leftOffset + (isFloat ? floatX : 0) + "px", 'important');
                break;
            case clientlibs_1.LaunchIconPosition.TopCenter:
                this.launcherFrame.style.setProperty('top', topOffset + (isFloat ? floatY : 0) + "px", 'important');
                this.launcherFrame.style.setProperty('left', "calc(50% + " + leftOffset + "px)", 'important');
                break;
            case clientlibs_1.LaunchIconPosition.TopRight:
                this.launcherFrame.style.setProperty('top', topOffset + (20) + "px", 'important');
                this.launcherFrame.style.setProperty('right', rightOffset + (isFloat ? floatX : 0) + "px", 'important');
                break;
            case clientlibs_1.LaunchIconPosition.RightCenter:
                this.launcherFrame.style.setProperty('top', "calc(50% + " + topOffset + "px)", 'important');
                this.launcherFrame.style.setProperty('right', rightOffset + (isFloat ? floatX : 0) + "px", 'important');
                break;
            case clientlibs_1.LaunchIconPosition.BottomRight:
                this.launcherFrame.style.setProperty('bottom', bottomOffset + 20 + "px", 'important');
                this.launcherFrame.style.setProperty('right', rightOffset + (isFloat ? floatX : 0) + "px", 'important');
                break;
            case clientlibs_1.LaunchIconPosition.BottomCenter:
                this.launcherFrame.style.setProperty('bottom', bottomOffset + (isFloat ? floatY : 0) + "px", 'important');
                this.launcherFrame.style.setProperty('left', "calc(50% + " + leftOffset + "px)", 'important');
                break;
            case clientlibs_1.LaunchIconPosition.BottomLeft:
                this.launcherFrame.style.setProperty('bottom', bottomOffset + 20 + "px", 'important');
                this.launcherFrame.style.setProperty('left', leftOffset + (isFloat ? floatX : 0) + "px", 'important');
                break;
            case clientlibs_1.LaunchIconPosition.LeftCenter:
                this.launcherFrame.style.setProperty('top', "calc(50% + " + topOffset + "px)", 'important');
                this.launcherFrame.style.setProperty('left', leftOffset + (isFloat ? floatX : 0) + "px", 'important');
                break;
        }
        this.setLauncherBoundingRectangle();
    };
    SuccessPanelLauncher.prototype.addAlertFlyoutOffsets = function () {
        var isFloat = this.sessionSvc.AvatarType === 'float';
        var vOffset = this.sessionSvc.LaunchIconPositionOffsetVertical, hOffset = this.sessionSvc.LaunchIconPositionOffsetHorizontal, _a = this.launcherBoundingRect, lfLeft = _a.left, lfTop = _a.top, lfRight = _a.right, topOffset = (vOffset * -1), bottomOffset = vOffset, leftOffset = hOffset, rightOffset = (hOffset * -1), avatarWidth = 40;
        switch (this.sessionSvc.LaunchIconPositionId) {
            case clientlibs_1.LaunchIconPosition.TopLeft:
                this.alertFlyoutFrame.style.setProperty('top', lfTop + 10 + "px", 'important');
                this.alertFlyoutFrame.style.setProperty('left', lfRight + (isFloat ? -20 : -10) + "px", 'important');
                break;
            case clientlibs_1.LaunchIconPosition.TopCenter:
                this.alertFlyoutFrame.style.setProperty('top', lfTop + (isFloat ? 10 : 15) + "px", 'important');
                this.alertFlyoutFrame.style.setProperty('left', "calc(50% + " + hOffset + "px)", 'important');
                break;
            case clientlibs_1.LaunchIconPosition.TopRight:
                this.alertFlyoutFrame.style.setProperty('top', lfTop + (10) + "px", 'important');
                this.alertFlyoutFrame.style.setProperty('right', rightOffset + avatarWidth + (isFloat ? 20 : 10) + "px", 'important');
                break;
            case clientlibs_1.LaunchIconPosition.RightCenter:
                this.alertFlyoutFrame.style.setProperty('top', "calc(50% + " + vOffset * -1 + "px)", 'important');
                this.alertFlyoutFrame.style.setProperty('right', rightOffset + (avatarWidth + (isFloat ? 20 : 10)) + "px", 'important');
                break;
            case clientlibs_1.LaunchIconPosition.BottomRight:
                this.alertFlyoutFrame.style.setProperty('bottom', bottomOffset + 40 + "px", 'important');
                this.alertFlyoutFrame.style.setProperty('right', rightOffset + (avatarWidth + (isFloat ? 20 : 10)) + "px", 'important');
                break;
            case clientlibs_1.LaunchIconPosition.BottomCenter:
                this.alertFlyoutFrame.style.setProperty('bottom', bottomOffset + (isFloat ? 35 : 10) + "px", 'important');
                this.alertFlyoutFrame.style.setProperty('left', "calc(50% + " + hOffset + "px)", 'important');
                break;
            case clientlibs_1.LaunchIconPosition.BottomLeft:
                this.alertFlyoutFrame.style.setProperty('bottom', bottomOffset + 40 + "px", 'important');
                this.alertFlyoutFrame.style.setProperty('left', lfRight + (isFloat ? -20 : -10) + "px", 'important');
                break;
            case clientlibs_1.LaunchIconPosition.LeftCenter:
                this.alertFlyoutFrame.style.setProperty('top', "calc(50% + " + vOffset * -1 + "px)", 'important');
                this.alertFlyoutFrame.style.setProperty('left', lfRight + (isFloat ? -20 : -10) + "px", 'important');
                break;
        }
    };
    SuccessPanelLauncher.prototype.hasLaunchIconOffsets = function () {
        return this.hasConfigOffsets(this.sessionSvc.LaunchIconPositionOffsetVertical, this.sessionSvc.LaunchIconPositionOffsetHorizontal);
    };
    return SuccessPanelLauncher;
}(PanelDisplay_1.BasePanelDisplay));
exports.SuccessPanelLauncher = SuccessPanelLauncher;


/***/ }),

/***/ "./src/core/panel-widgets/AccountRepWidget.ts":
/*!****************************************************!*\
  !*** ./src/core/panel-widgets/AccountRepWidget.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

/*
<div id="cz-account-rep-pane" class="cz-header-section">
            <h5 class="cz-user-account-name">{{userAccountName}}
                <small>{{userAccountTitle}}</small>
            </h5>
            <p class="cz-message-preview">
                phone: {{userAccountPhone}}
                <br/>
                email: {{userAccountEmail}}
            </p>
        </div>
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AccountRepWidget = void 0;
var AccountRepWidget = /** @class */ (function () {
    function AccountRepWidget(sessionSvc, tenantSvc, parentDoc) {
        this.sessionSvc = sessionSvc;
        this.tenantSvc = tenantSvc;
        this.parentDoc = parentDoc;
        this.setupAccountRep('classic');
    }
    AccountRepWidget.prototype.getContainer = function () {
        return this.accountRepPane;
    };
    AccountRepWidget.prototype.onDigest = function () {
    };
    AccountRepWidget.prototype.onHalt = function () {
    };
    AccountRepWidget.prototype.setupAccountRep = function (panelTemplate) {
        //build the html appropriate for the given template
        switch (panelTemplate) {
            case 'classic':
            default:
                this.accountRepPane = this.buildClassicAccountRepInfoWidget();
                break;
        }
        //TODO: look at not adding the account rep html if show Account owner is false;
        // need to verify what else references the html
        if (this.sessionSvc.ShowAccountOwner) {
            this.accountRepPane.style.removeProperty('display');
        }
        else {
            this.accountRepPane.style.display = 'none';
        }
    };
    /** Widget Template Builders */
    AccountRepWidget.prototype.buildClassicAccountRepInfoWidget = function () {
        var accountOwner = this.tenantSvc.accountOwner || {
            firstName: '',
            lastName: '',
            title: '',
            officePhone: '',
            email: ''
        }, accountRepPane = this.parentDoc.createElement('div');
        accountRepPane.classList.add('cz-header-section');
        accountRepPane.id = 'cz-account-rep-pane';
        var uaName = this.parentDoc.createElement('h5');
        uaName.classList.add('cz-user-account-name');
        uaName.innerText = accountOwner.firstName + ' ' + accountOwner.lastName;
        var uaTitle = this.parentDoc.createElement('small');
        uaTitle.innerText = accountOwner.title;
        uaTitle.style.marginLeft = '5px';
        uaName.appendChild(uaTitle);
        accountRepPane.appendChild(uaName);
        var uaInfo = this.parentDoc.createElement('p');
        uaInfo.classList.add('cz-message-preview');
        uaInfo.innerHTML = 'phone: ' + accountOwner.officePhone;
        uaInfo.innerHTML += '<br />';
        uaInfo.innerHTML += 'email: ' + accountOwner.email;
        accountRepPane.appendChild(uaInfo);
        var accountRepImgDiv = this.parentDoc.createElement('div');
        var avatarContainer = this.parentDoc.createElement('span');
        avatarContainer.classList.add('cz-avatar');
        if (this.sessionSvc.AccountOwnerAvatarUrl) {
            /*
            <span class="cz-avatar">
                <img !inline class="cz-avatar-img" src="{{avatarSrc}}" alt="...">
            </span>
            */
            var avatarImg = this.parentDoc.createElement('img');
            avatarImg.classList.add('cz-avatar-img');
            avatarImg.src = this.sessionSvc.AccountOwnerAvatarUrl;
            avatarContainer.appendChild(avatarImg);
        }
        else if (accountOwner) {
            /*
            <span class="cz-avatar">
                <span class="cz-avatar-name">{{avatarSrc}}</span>
            </span>

             */
            var avatarInitilas = this.parentDoc.createElement('span');
            avatarInitilas.innerText = (accountOwner.firstName || ' ').substring(0, 1) + (accountOwner.lastName || ' ').substring(0, 1);
            avatarInitilas.classList.add('cz-avatar-name');
            avatarContainer.appendChild(avatarInitilas);
        }
        accountRepImgDiv.appendChild(avatarContainer);
        accountRepPane.insertBefore(accountRepImgDiv, accountRepPane.firstChild);
        return accountRepPane;
    };
    return AccountRepWidget;
}());
exports.AccountRepWidget = AccountRepWidget;


/***/ }),

/***/ "./src/core/panel-widgets/AnnouncementsWidget.ts":
/*!*******************************************************!*\
  !*** ./src/core/panel-widgets/AnnouncementsWidget.ts ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnnouncementsWidget = void 0;
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var FrameComm_util_1 = __webpack_require__(/*! @src/utils/FrameComm.util */ "./src/utils/FrameComm.util.ts");
var AnnouncementsWidget = /** @class */ (function () {
    function AnnouncementsWidget(parentDoc, messageSvc, sessionSvc, appSvc, windowSvc, templateCache) {
        this.parentDoc = parentDoc;
        this.messageSvc = messageSvc;
        this.sessionSvc = sessionSvc;
        this.appSvc = appSvc;
        this.windowSvc = windowSvc;
        this.templateCache = templateCache;
        this.previousUnreadCount = 0;
        this.isDefaultAnnouncementActive = false;
        // Event Handler Variables
        this.hoveredVideoAnnouncementId = 0;
        this.clickDelegate = this.clickDelegate.bind(this);
        this.mouseEnterDelegate = this.mouseEnterDelegate.bind(this);
        this.mouseLeaveDelegate = this.mouseLeaveDelegate.bind(this);
        this.blurDelegate = this.blurDelegate.bind(this);
        this.build('classic');
    }
    AnnouncementsWidget.prototype.getContainer = function () {
        return this.announcementsContainer;
    };
    AnnouncementsWidget.prototype.onDigest = function (panelVisible) {
        this.handleMessageDigest(panelVisible);
    };
    AnnouncementsWidget.prototype.onHalt = function () {
        var bod = this.parentDoc.body, win = this.parentDoc.defaultView;
        if (bod) {
            bod.removeEventListener('click', this.clickDelegate);
            bod.removeEventListener('mouseenter', this.mouseEnterDelegate, true);
            bod.removeEventListener('mouseleave', this.mouseLeaveDelegate, true);
        }
        if (win) {
            win.removeEventListener('blur', this.blurDelegate);
        }
        if (win && win.parent) {
            var topWindow = win.parent;
            topWindow.removeEventListener('blur', this.blurDelegate);
        }
    };
    AnnouncementsWidget.prototype.build = function (panelTemplate) {
        //build the html appropriate for the given template
        switch (panelTemplate) {
            case 'classic':
            default:
                this.announcementsContainer = this.buildClassicAnnouncementsWidget();
                break;
        }
        this.setupAnnouncements({
            announcements: this.messageSvc.Announcements,
            showMoreText: this.sessionSvc.CurrentAccountContent.clickToSeeMoreText
        });
        var bod = this.parentDoc.body, win = this.parentDoc.defaultView, topWindow = win.parent;
        bod.addEventListener('click', this.clickDelegate);
        bod.addEventListener('mouseenter', this.mouseEnterDelegate, true);
        bod.addEventListener('mouseleave', this.mouseLeaveDelegate, true);
        win.addEventListener('blur', this.blurDelegate);
        topWindow.addEventListener('blur', this.blurDelegate);
    };
    AnnouncementsWidget.prototype.setupAnnouncements = function (announcementSetup) {
        //add announcements to csm panel
        for (var i = announcementSetup.announcements.length - 1; i >= 0; i--) {
            var current = announcementSetup.announcements[i];
            if (this.messageSvc.isPanelAnnouncement(current)) {
                this.addAnnouncementToPanelUi(current);
            }
        }
        //display the default announcement
        if (announcementSetup.announcements.length === 0) {
            this.displayDefaultAnnouncement();
        }
    };
    AnnouncementsWidget.prototype.displayDefaultAnnouncement = function () {
        if (this.sessionSvc.CurrentAccountContent.defaultAnnouncement) {
            var defaultAnnouncement = {
                messageContent: this.sessionSvc.CurrentAccountContent.defaultAnnouncement,
                deliveryDate: new Date(),
                isRead: true // this is set so the digest wont emit a read event
            };
            this.addAnnouncementToPanelUi(defaultAnnouncement);
            //set after calling addAnnouncement because addAnnouncement resets default
            this.isDefaultAnnouncementActive = true;
        }
    };
    AnnouncementsWidget.prototype.addAnnouncementToPanelUi = function (announcement) {
        // let announcementsContainer = this.windowSvc.czq('#cz-announcements'); // OLD LOGIC
        //if the default is active, remove it and turn off
        if (this.isDefaultAnnouncementActive) {
            // announcementsContainer.empty(); // OLD LOGIC
            this.announcementsContainer.innerHTML = '';
            this.isDefaultAnnouncementActive = false;
        }
        //template the announcement,
        // remove any unreplaced placeholders,
        // and then add it to the top of the announcements container
        var messageTemplate = this.templateCache.announcementTemplate;
        this.messageSvc.normalizeMessageData(announcement);
        var announcementType = this.messageSvc.getAnnouncementType(announcement);
        if (announcementType === clientlibs_1.AnnouncementType.Nps ||
            announcementType === clientlibs_1.AnnouncementType.CustomSurvey) {
            messageTemplate = this.templateCache.announcementNpsTemplatePanel;
            announcement.npsUrl = announcement.messageData.responseUrl;
            announcement.npsQuestion = announcement.messageData.question;
            announcement.wide = announcement.messageData.wide;
            announcement.showNewWindow = announcement.messageData.showNewWindow;
        }
        var messageHtml = this.appSvc.templater.populateTemplate(messageTemplate, announcement);
        if (messageHtml && typeof this.parentDoc.createElement === 'function') {
            messageHtml = this.appSvc.templater.purge(messageHtml);
            var announcementsSection = this.parentDoc.createElement('section');
            announcementsSection.innerHTML = messageHtml;
            this.announcementsContainer.insertBefore(announcementsSection, this.announcementsContainer.firstChild);
        }
        //let anyone listening know a new announcement was added to the panel
        this.appSvc.pubsub.publish(AnnouncementsWidget.AnnouncementAddedToPanelEvent);
    };
    AnnouncementsWidget.prototype.handleMessageDigest = function (panelVisible) {
        var unreadCount = 0;
        for (var i = 0; i < this.messageSvc.Announcements.length; i++) {
            var msg = this.messageSvc.Announcements[i];
            if (!msg) {
                continue;
            }
            var sideBarId = "#cz-sidebar-note-" + msg.sequence;
            var msgDom = this.windowSvc.czq(sideBarId, this.announcementsContainer);
            if (msg.announcementIncludeInPanel) {
                if (msgDom.length === 0) {
                    this.addAnnouncementToPanelUi(msg);
                    msgDom = this.windowSvc.czq(sideBarId, this.announcementsContainer);
                }
                //if the panel is open check for read items
                //mark any visible announcements as read
                if (panelVisible) {
                    if (!msg.isRead) {
                        //console.info("Checking Visiblilty #cz-sidebar-note-" + msg.sequence);
                        // TODO: Figure out how to get this to work WITHOUT CZQ
                        if (this.windowSvc.isVisible(msgDom, true)) {
                            //console.info(`Visible #cz-sidebar-note-${msg.sequence}`);
                            this.messageSvc.SendReadReceipt(msg.id);
                        }
                        else {
                            //console.info(`NOT Visible #cz-sidebar-note-${msg.sequence}`);
                        }
                    }
                }
                else if (!msg.isRead) { //count unread for badge
                    unreadCount++;
                }
            }
            //expire any content
            //expiryDate
            if (msg.expiryDate) {
                var isExpired = new this.windowSvc.Date() > new this.windowSvc.Date(msg.expiryDate);
                if (isExpired) {
                    /* if (!this.messageSvc.isNPSAnnouncement(msg)) {
                         if (this.messageSvc.isPopupAnnouncement(msg)) {
                             //if popup, close
                             this.closePopUpAnnouncement();
                         } else if (this.messageSvc.isSliderAnnouncement(msg)) {
                             //if slider, close
                             this.closeSlider();
                         }
                     }*/
                    // remove from panel ui (DOM Version)
                    // if (msgDom && msgDom.parentElement) {
                    //     msgDom.parentElement.removeChild(msgDom);
                    // }
                    //remove from panel ui (Temp CZQ version)
                    msgDom.remove();
                    this.messageSvc.Announcements[i] = undefined;
                }
            }
        }
        if (unreadCount !== this.previousUnreadCount) {
            this.appSvc.pubsub.publish(AnnouncementsWidget.UnreadAnnouncementCountChangeEvent, { count: unreadCount });
        }
        this.previousUnreadCount = unreadCount;
        //sanitize the Announcements array
        this.messageSvc.SanitizeAnnouncements();
        var panelAnnouncements = this.messageSvc.Announcements.filter(this.messageSvc.isPanelAnnouncement), zeroAnnouncements = panelAnnouncements.length === 0;
        if (zeroAnnouncements && !this.isDefaultAnnouncementActive) {
            //show default announcement if no panel announcements
            this.displayDefaultAnnouncement();
        }
    };
    /***** BEGIN CLICK AUDIT LOGIC *****/
    AnnouncementsWidget.prototype.clickDelegate = function (e) {
        var target = e.target, t = target;
        if (this.tryHandleNpsClick(t)) {
            return;
        }
        if (this.tryHandleAnchorClick(t)) {
            return;
        }
    };
    AnnouncementsWidget.prototype.tryHandleNpsClick = function (el) {
        var npsAnchor = clientlibs_1.CoreUtils.closest(el, '.cz-nps-click');
        if (!npsAnchor) {
            return false;
        }
        var url = npsAnchor.getAttribute('data-nps-url'), wide = npsAnchor.getAttribute('data-wide') === 'true', showNewWindow = (npsAnchor.getAttribute('data-show-new-window') || '').toLowerCase() === 'true', announcement = clientlibs_1.CoreUtils.closest(el, '.cz-announcement'), showMessageBubble = announcement && announcement.getAttribute('data-info-message') !== 'false', socketAnnouncement = this.messageSvc.GetAnnouncementFromAnnouncementHtml(announcement);
        var data = {
            code: clientlibs_1.InterfaceCommCodes.NpsAnnouncementLinkClicked,
            url: url,
            wide: wide,
            showNewWindow: showNewWindow,
            showMessageBubble: showMessageBubble,
            id: socketAnnouncement.id
        }, transportPod = clientlibs_1.iFrameUtils.buildTransportMessage(clientlibs_1.TransportCodes.InterfaceComm, data);
        FrameComm_util_1.FrameCommUtil.postEncryptedMessage(this.parentDoc.defaultView.top, transportPod, '*');
        return true;
    };
    AnnouncementsWidget.prototype.tryHandleAnchorClick = function (el) {
        var anchor = clientlibs_1.CoreUtils.closest(el, '.cz-click-audit a');
        // Not an anchor, bail
        if (!anchor) {
            return false;
        }
        var container = clientlibs_1.CoreUtils.closest(anchor, '.cz-click-audit');
        // We don't care about this anchor, bail
        if (!container) {
            return false;
        }
        var msgId = container.getAttribute('data-message-id'), data = {
            code: clientlibs_1.InterfaceCommCodes.AnnouncementClickAudit,
            id: msgId
        }, tp = clientlibs_1.iFrameUtils.buildTransportMessage(clientlibs_1.TransportCodes.InterfaceComm, data);
        FrameComm_util_1.FrameCommUtil.postEncryptedMessage(this.parentDoc.defaultView.top, tp, '*');
        return true;
    };
    AnnouncementsWidget.prototype.mouseEnterDelegate = function (e) {
        var target = e.target, el = target;
        // Not an iframe or not concerned with this iframe, bail
        if (el.tagName.toLowerCase() !== 'iframe' || !el.parentElement.classList.contains('fr-video'))
            return;
        var container = clientlibs_1.CoreUtils.closest(el, '.cz-click-audit');
        // Can't find audit container, bail
        if (!container) {
            return;
        }
        var msgId = parseInt(container.getAttribute('data-message-id'), 10);
        this.hoveredVideoAnnouncementId = msgId || 0;
    };
    AnnouncementsWidget.prototype.mouseLeaveDelegate = function (e) {
        var target = e.target, el = target;
        // Not an iframe or not concerned with this iframe, bail
        if (el.tagName.toLowerCase() !== 'iframe' || !el.parentElement.classList.contains('fr-video'))
            return;
        var container = clientlibs_1.CoreUtils.closest(el, '.cz-click-audit');
        // Can't find audit container, bail
        if (!container) {
            return;
        }
        this.hoveredVideoAnnouncementId = 0;
    };
    AnnouncementsWidget.prototype.blurDelegate = function (e) {
        // Make sure we have hovered over an announcement video frame AND the event is originating from a trusted window
        var t = e.target, shouldContinue = this.hoveredVideoAnnouncementId && (t === this.parentDoc.defaultView.top || t === this.parentDoc.defaultView);
        if (!shouldContinue) {
            return;
        }
        var data = {
            code: clientlibs_1.InterfaceCommCodes.AnnouncementClickAudit,
            id: this.hoveredVideoAnnouncementId
        }, tp = clientlibs_1.iFrameUtils.buildTransportMessage(clientlibs_1.TransportCodes.InterfaceComm, data);
        FrameComm_util_1.FrameCommUtil.postEncryptedMessage(this.parentDoc.defaultView.top, tp, '*');
    };
    /***** END CLICK AUDIT LOGIC *****/
    /** Widget Template Builders */
    AnnouncementsWidget.prototype.buildClassicAnnouncementsWidget = function () {
        var container = this.parentDoc.createElement('article');
        container.id = 'cz-announcements';
        return container;
    };
    AnnouncementsWidget.AnnouncementAddedToPanelEvent = 'cz.announcementswidget.announcementaddedtopanel';
    AnnouncementsWidget.UnreadAnnouncementCountChangeEvent = 'cz.announcementswidget.unreadannouncementcountchange';
    return AnnouncementsWidget;
}());
exports.AnnouncementsWidget = AnnouncementsWidget;


/***/ }),

/***/ "./src/core/panel-widgets/JourneyChecklistCollectionWidget.ts":
/*!********************************************************************!*\
  !*** ./src/core/panel-widgets/JourneyChecklistCollectionWidget.ts ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JourneyChecklistCollectionWidget = void 0;
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var JourneyChecklistWidget_1 = __webpack_require__(/*! ./JourneyChecklistWidget */ "./src/core/panel-widgets/JourneyChecklistWidget.ts");
var tenant_service_1 = __webpack_require__(/*! @src/services/tenant.service */ "./src/services/tenant.service.ts");
var EMPTY_COLLECTION = [];
var JourneyChecklistCollectionWidget = /** @class */ (function () {
    function JourneyChecklistCollectionWidget(parentDoc, sessionSvc, checklistSvc, windowSvc, commSvc, appSvc, tenantSvc) {
        this.parentDoc = parentDoc;
        this.sessionSvc = sessionSvc;
        this.checklistSvc = checklistSvc;
        this.windowSvc = windowSvc;
        this.commSvc = commSvc;
        this.appSvc = appSvc;
        this.tenantSvc = tenantSvc;
        this.collection = [];
        this.subIds = {};
        this.build = this.build.bind(this);
        this.domContainer = this.parentDoc.createElement('section');
        this.subIds['checklistRefreshedSub'] = this.appSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.JourneyChecklistRefreshed, this.build);
        this.build();
    }
    JourneyChecklistCollectionWidget.prototype.getContainer = function () {
        return this.domContainer;
    };
    JourneyChecklistCollectionWidget.prototype.onDigest = function () { };
    JourneyChecklistCollectionWidget.prototype.onHalt = function () {
        var _a;
        var cl = (_a = this.collection) === null || _a === void 0 ? void 0 : _a.length;
        for (var i = 0; i < cl; i++)
            this.collection[i].onHalt();
        if (!this.domContainer)
            return;
        while (this.domContainer.firstChild) {
            this.domContainer.removeChild(this.domContainer.lastChild);
        }
        if (this.domContainer.parentElement)
            this.domContainer.parentElement.removeChild(this.domContainer);
        this.domContainer = null; // mark for GC
    };
    JourneyChecklistCollectionWidget.prototype.build = function () {
        // Phase II
        if (this.tenantSvc.FeatureEnabled(tenant_service_1.ReleaseGates.JourneyChecklistPhaseTwoReleased)) {
            this.buildForPhaseTwo();
            return;
        }
        // Phase I
        this.buildForPhaseOne();
    };
    // TODO Remove this conditional method once phase 2 becomes the norm
    JourneyChecklistCollectionWidget.prototype.buildForPhaseOne = function () {
        var _a, _b;
        var panelItems = (((_a = this.checklistSvc.getChecklistConfig()) === null || _a === void 0 ? void 0 : _a.items) || EMPTY_COLLECTION).concat();
        // We got nothing. Remove any collection items and bail
        if (panelItems.length === 0) {
            var cl = this.collection.length;
            for (var i = 0; i < cl; i++) {
                this.collection[i].onHalt();
            }
            this.collection = [];
            return;
        }
        // only worried about the first item from the checklist config server data
        var target = panelItems[0];
        // If our collection is empty, add the new widget
        if (this.collection.length === 0) {
            var w = new JourneyChecklistWidget_1.JourneyChecklistWidget(this.parentDoc, this.windowSvc, this.appSvc, this.checklistSvc);
            this.collection.push(w);
            (_b = this.domContainer) === null || _b === void 0 ? void 0 : _b.appendChild(this.collection[0].getContainer());
        }
        // Set the widget config data based on target
        this.collection[0].setData(target);
        this.collection[0].build();
    };
    // TODO Remove this conditional method once phase 2 becomes the norm
    JourneyChecklistCollectionWidget.prototype.buildForPhaseTwo = function () {
        var _this = this;
        var _a, _b;
        var clConfigItems = ((_a = this.checklistSvc.getChecklistConfig()) === null || _a === void 0 ? void 0 : _a.items) || EMPTY_COLLECTION, panelItems = clConfigItems.filter(function (c) { return _this.sessionSvc.PanelEnabled && c.uiPositionId === 1; }), pil = panelItems.length;
        // We got nothing. Remove any collection items and bail
        if (pil === 0) {
            var cl = this.collection.length;
            for (var i = 0; i < cl; i++) {
                this.collection[i].onHalt();
            }
            this.collection = [];
            return;
        }
        var sourceIds = panelItems.map(function (p) { return p.id; });
        var idx = this.collection.length;
        while (idx--) {
            var existing = this.collection[idx];
            if (sourceIds.indexOf(existing.getId()) > -1)
                continue;
            existing.onHalt();
            this.collection.splice(idx, 1);
        }
        var existingIds = this.collection.map(function (c) { return c.getId(); }), updatedCollection = [];
        for (var i = 0; i < pil; i++) {
            var item = panelItems[i];
            var w = void 0;
            var existingIdx = existingIds.indexOf(item.id);
            if (existingIdx > -1) {
                w = this.collection[existingIdx];
            }
            else {
                w = new JourneyChecklistWidget_1.JourneyChecklistWidget(this.parentDoc, this.windowSvc, this.appSvc, this.checklistSvc);
            }
            updatedCollection.push(w);
            w.setData(item);
            w.build();
            (_b = this.domContainer) === null || _b === void 0 ? void 0 : _b.appendChild(w.getContainer());
        }
        this.collection = updatedCollection;
    };
    return JourneyChecklistCollectionWidget;
}());
exports.JourneyChecklistCollectionWidget = JourneyChecklistCollectionWidget;


/***/ }),

/***/ "./src/core/panel-widgets/JourneyChecklistWidget.ts":
/*!**********************************************************!*\
  !*** ./src/core/panel-widgets/JourneyChecklistWidget.ts ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JourneyChecklistWidget = void 0;
// Libs
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var progress_gauge_1 = __webpack_require__(/*! @src/core/ui-elements/progress-gauge */ "./src/core/ui-elements/progress-gauge.ts");
var MilestoneItemType;
(function (MilestoneItemType) {
    MilestoneItemType["Achievement"] = "achievement";
    MilestoneItemType["Task"] = "task";
})(MilestoneItemType || (MilestoneItemType = {}));
var JourneyChecklistWidget = /** @class */ (function () {
    function JourneyChecklistWidget(parentDoc, windowSvc, appSvc, checklistSvc, onUpdate) {
        this.parentDoc = parentDoc;
        this.windowSvc = windowSvc;
        this.appSvc = appSvc;
        this.checklistSvc = checklistSvc;
        this.onUpdate = onUpdate;
        this.checklist = null;
        // Checklist properties
        this.totalItemCount = 0;
        this.completedItemCount = 0;
        // DOM Elements
        this.domWrapper = null;
        this.progressGauge = null;
        this.completeBanner = null;
        // sub ids
        this.subIds = {};
        this.onClickDelegate = this.onClickDelegate.bind(this);
        this.onChangeDelegate = this.onChangeDelegate.bind(this);
        this.handleRefresh = this.handleRefresh.bind(this);
        this.domWrapper = this.parentDoc.createElement('article');
        this.domWrapper.classList.add(JourneyChecklistWidget.DOM_PREFIX);
        this.domWrapper.addEventListener('click', this.onClickDelegate); // Removed in onHalt
        this.domWrapper.addEventListener('change', this.onChangeDelegate); // Removed in onHalt
        this.subIds['checklistRefreshedSub'] = this.appSvc.pubsub.subscribe(clientlibs_1.ChurnZeroAppEvents.JourneyChecklistRefreshed, this.handleRefresh);
    }
    JourneyChecklistWidget.prototype.getId = function () {
        var _a;
        return (_a = this.checklist) === null || _a === void 0 ? void 0 : _a.id;
    };
    JourneyChecklistWidget.prototype.getContainer = function () {
        return this.domWrapper;
    };
    JourneyChecklistWidget.prototype.isCompleteBannerVisible = function () {
        var _a, _b;
        return (_b = (_a = this.completeBanner) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.contains('in');
    };
    JourneyChecklistWidget.prototype.onDigest = function () { };
    JourneyChecklistWidget.prototype.onHalt = function () {
        var _a, _b;
        clientlibs_1.PubSuber.removeAll(this.subIds);
        (_a = this.progressGauge) === null || _a === void 0 ? void 0 : _a.destroy();
        this.progressGauge = null;
        // If we don't even HAVE a dom wrapper element, bail
        if (!this.domWrapper)
            return;
        this.domWrapper.removeEventListener('click', this.onClickDelegate);
        this.domWrapper.removeEventListener('change', this.onChangeDelegate);
        while (this.domWrapper.lastChild) {
            this.domWrapper.removeChild(this.domWrapper.firstChild);
        }
        (_b = this.domWrapper.parentElement) === null || _b === void 0 ? void 0 : _b.removeChild(this.domWrapper);
        // Mark in-memory elements for GC
        this.completeBanner = null;
        this.domWrapper = null;
    };
    JourneyChecklistWidget.prototype.setData = function (data) {
        this.checklist = __assign({}, data);
    };
    JourneyChecklistWidget.prototype.build = function () {
        if (this.checklist.milestones.length === 0)
            return;
        if (!this.domWrapper) {
            return;
        }
        // Remove all child nodes from the wrapper
        while (this.domWrapper.firstChild) {
            this.domWrapper.removeChild(this.domWrapper.lastChild);
        }
        // Reset checklist count variables
        this.totalItemCount = 0;
        this.completedItemCount = 0;
        this.completeBanner = this.parentDoc.createElement('div');
        this.completeBanner.classList.add(JourneyChecklistWidget.DOM_PREFIX + "-complete-banner");
        this.populateCompleteBannerMarkup(this.completeBanner, this.checklist.completeMessage);
        this.domWrapper.appendChild(this.completeBanner);
        if (this.checklist.isMarkedComplete) {
            this.completeBanner.classList.add('is-complete');
            var tooltip = this.getChecklistCompletedTooltip();
            if (tooltip) {
                this.completeBanner.title = tooltip;
            }
        }
        // Add "index" div (don't have a good name for this)
        var listing = this.parentDoc.createElement('div');
        listing.classList.add(JourneyChecklistWidget.DOM_PREFIX + "-index");
        this.domWrapper.appendChild(listing);
        var shouldDisplayMilestones = this.checklist.shouldDisplayMilestones, headerWrapper = this.parentDoc.createElement('header'), header = this.parentDoc.createElement('h3');
        header.className = JourneyChecklistWidget.DOM_PREFIX + "-header";
        header.textContent = this.checklist.title;
        headerWrapper.className = JourneyChecklistWidget.DOM_PREFIX + "-header-wrapper";
        headerWrapper.appendChild(header);
        if (shouldDisplayMilestones) {
            this.domWrapper.classList.add('with-ms-names');
        }
        listing.appendChild(headerWrapper);
        this.appendMilestoneMarkup(listing, shouldDisplayMilestones);
        if (this.progressGauge === null) {
            this.progressGauge = new progress_gauge_1.ProgressGauge(this.parentDoc, this.windowSvc, 50, 50, 20, '');
        }
        var pc = this.getGaugePercentComplete(), title = this.getGaugeTitle();
        this.progressGauge.update(pc, title);
        typeof this.onUpdate === 'function' && this.onUpdate({ percentComplete: pc, title: title });
        headerWrapper.appendChild(this.progressGauge.getContainer());
        this.checkIfAllCompleted();
    };
    JourneyChecklistWidget.prototype.getItemCounts = function () {
        return { total: this.totalItemCount, completed: this.completedItemCount };
    };
    JourneyChecklistWidget.prototype.handleRefresh = function () {
        var _this = this;
        var _a, _b;
        if (!((_a = this.checklist) === null || _a === void 0 ? void 0 : _a.id))
            return;
        var clConfigItems = ((_b = this.checklistSvc.getChecklistConfig()) === null || _b === void 0 ? void 0 : _b.items) || [], targetCl = clConfigItems.filter(function (cl) { return cl.id === _this.checklist.id; });
        if (targetCl.length === 0) {
            this.onHalt();
            return;
        }
        this.setData(targetCl[0]);
        this.build();
    };
    JourneyChecklistWidget.prototype.onClickDelegate = function (e) {
        var _a;
        var t = e.target;
        var msHeadingBtn = clientlibs_1.CoreUtils.closest(t, "." + JourneyChecklistWidget.DOM_PREFIX + "-milestone-heading-btn");
        if (msHeadingBtn) {
            this.onMilestoneHeadingClick(msHeadingBtn);
            return;
        }
        if (t.hasAttribute('data-cl-complete-btn')) {
            var banner = e.view.document.querySelector("." + JourneyChecklistWidget.DOM_PREFIX + "-complete-banner");
            if (banner)
                banner.classList.add('is-pending');
            if (!((_a = this.checklist) === null || _a === void 0 ? void 0 : _a.journeyAccountInstanceId))
                return;
            var msLen = this.checklist.milestones.length, itemIds = [];
            for (var i = 0; i < msLen; i++) {
                var ms = this.checklist.milestones[i], achievements = ms.achievements, tasks = ms.tasks, al = achievements.length, tl = tasks.length;
                for (var j = 0; j < al; j++) {
                    var ach = achievements[j];
                    itemIds.push(ach.stepId);
                }
                for (var j = 0; j < tl; j++) {
                    var task = tasks[j];
                    itemIds.push(task.stepId);
                }
            }
            var allFieldsets = this.domWrapper.querySelectorAll('fieldset'), afl = allFieldsets.length;
            for (var i = 0; i < afl; i++) {
                var fs = allFieldsets[i];
                fs.disabled = true;
            }
            var messageContent = {
                journeyAccountInstanceId: this.checklist.journeyAccountInstanceId,
                completedStepIds: itemIds
            };
            this.checklistSvc.markChecklistComplete(messageContent);
        }
    };
    JourneyChecklistWidget.prototype.onChangeDelegate = function (e) {
        var _a;
        var t = e.target;
        if (t.tagName !== 'INPUT' || t.getAttribute('type') !== 'checkbox')
            return;
        var cb = t, sid = cb.getAttribute('data-item-step-id'), stepType = cb.getAttribute('data-item-type');
        if (!sid || !stepType || !((_a = this.checklist) === null || _a === void 0 ? void 0 : _a.journeyAccountInstanceId))
            return;
        var isChecked = cb.checked, messageContent = {
            stepType: stepType,
            stepId: parseInt(sid, 10),
            journeyAccountInstanceId: this.checklist.journeyAccountInstanceId,
            isComplete: isChecked
        };
        // Update completedItemCount
        if (isChecked) {
            this.completedItemCount++;
        }
        else {
            this.completedItemCount--;
        }
        // Update progress gauge
        var pc = this.getGaugePercentComplete(), title = this.getGaugeTitle();
        this.progressGauge && this.progressGauge.update(pc, title);
        typeof this.onUpdate === 'function' && this.onUpdate({ percentComplete: pc, title: title });
        // Check if all items are completed
        this.checkIfAllCompleted();
        this.checklistSvc.toggleItem(messageContent);
    };
    JourneyChecklistWidget.prototype.onMilestoneHeadingClick = function (t) {
        var p = t.parentElement, fieldSets = p.getElementsByTagName('fieldset'), carets = t.getElementsByTagName('span');
        if (fieldSets.length === 0 || carets.length === 0) {
            return;
        }
        var fs = fieldSets[0], c = carets[0], isHidden = fs.classList.contains('cz-hidden');
        fs.classList.toggle('cz-hidden');
        if (isHidden) {
            c.classList.remove('caret-left');
            c.classList.add('caret-down');
        }
        else {
            c.classList.remove('caret-down');
            c.classList.add('caret-left');
        }
    };
    JourneyChecklistWidget.prototype.appendMilestoneMarkup = function (wrapper, shouldShowNames) {
        var msl = this.checklist.milestones.length;
        for (var i = 0; i < msl; i++) {
            var ms = this.checklist.milestones[i], achievements = ms.achievements, tasks = ms.tasks, hasStarted = ms.hasStarted;
            // Addresses CZ-14170: Bail if this ms doesn't have any "steps" associated with it
            if (achievements.length === 0 && tasks.length === 0)
                continue;
            var s = this.parentDoc.createElement('section'), fs = this.parentDoc.createElement('fieldset');
            this.totalItemCount += (achievements.length + tasks.length);
            s.className = JourneyChecklistWidget.DOM_PREFIX + "-milestone";
            if (shouldShowNames) {
                var msHeadingButton = this.parentDoc.createElement('button'), msHeading = this.parentDoc.createElement('h5'), msHeadingCaret = this.parentDoc.createElement('span');
                msHeadingButton.className = JourneyChecklistWidget.DOM_PREFIX + "-milestone-heading-btn";
                msHeadingButton.type = 'button';
                msHeading.className = JourneyChecklistWidget.DOM_PREFIX + "-milestone-heading";
                msHeading.textContent = ms.name;
                msHeadingCaret.className = JourneyChecklistWidget.DOM_PREFIX + "-milestone-heading-caret caret-down";
                msHeadingButton.appendChild(msHeading);
                msHeadingButton.appendChild(msHeadingCaret);
                s.appendChild(msHeadingButton);
            }
            s.appendChild(fs);
            this.appendItemMarkup(fs, achievements, MilestoneItemType.Achievement);
            this.appendItemMarkup(fs, tasks, MilestoneItemType.Task);
            if (!hasStarted) {
                s.classList.add('unstarted');
                fs.setAttribute('disabled', '');
                fs.setAttribute('title', 'Milestone has not started yet.');
            }
            // Disable the whole fieldset if our checklist is complete
            if (this.checklist.isMarkedComplete)
                fs.disabled = true;
            wrapper.appendChild(s);
        }
    };
    JourneyChecklistWidget.prototype.appendItemMarkup = function (mileStoneWrapper, itemCollection, itemType) {
        var il = itemCollection.length;
        for (var i = 0; i < il; i++) {
            var item = itemCollection[i];
            var itemText = void 0;
            var itemId = JourneyChecklistWidget.DOM_PREFIX + "-" + itemType + "-item-" + item.id, itemEl = this.parentDoc.createElement('div'), itemCb = this.parentDoc.createElement('input'), itemLabel = this.parentDoc.createElement('label');
            itemEl.className = JourneyChecklistWidget.DOM_PREFIX + "-item";
            itemCb.id = itemId;
            itemCb.type = 'checkbox';
            itemCb.setAttribute('data-item-type', itemType);
            if (item.stepId) {
                itemCb.setAttribute('data-item-step-id', item.stepId.toString());
            }
            itemLabel.className = JourneyChecklistWidget.DOM_PREFIX + "-item-label";
            itemLabel.htmlFor = itemId;
            itemLabel.appendChild(itemCb);
            if (item.isCompleted) {
                this.completedItemCount++;
                itemCb.setAttribute('checked', '');
                itemLabel.title = this.getItemCompletedTooltip(item);
            }
            var _a = item.options || {}, shouldIncludeLink = _a.shouldIncludeLink, url = _a.url;
            if (shouldIncludeLink && url) {
                itemText = this.parentDoc.createElement('a');
                itemText.target = '_blank';
                itemText.href = item.options.url;
                itemText.rel = 'noreferrer noopener';
            }
            else {
                itemText = this.parentDoc.createElement('span');
            }
            itemText.className = JourneyChecklistWidget.DOM_PREFIX + "-item-text";
            itemText.textContent = item.name;
            itemLabel.appendChild(itemText);
            if (item.isAutoCompleted) {
                itemCb.disabled = true;
                itemLabel.classList.add('is-auto-completed');
                var helpIcon = this.parentDoc.createElement('i');
                helpIcon.className = 'czi czi-info-circle';
                helpIcon.title = 'This Achievement will be completed once criteria is met. This may take a few minutes to be marked complete after meeting criteria.';
                itemLabel.appendChild(helpIcon);
            }
            itemEl.appendChild(itemLabel);
            mileStoneWrapper.appendChild(itemEl);
        }
    };
    JourneyChecklistWidget.prototype.populateCompleteBannerMarkup = function (bannerWrapper, completeMessage) {
        bannerWrapper.innerHTML = "\n        <section class=\"mark-as-complete\">\n            <p>All steps are complete.</p>\n            <button type=\"button\" data-cl-complete-btn>Complete Checklist</button>\n        </section>\n        <section class=\"pending\">\n            <p>Checklist is pending completion...</p>\n        </section>\n        <section class=\"completed-text\">\n            <p>" + (completeMessage || 'Congrats! Your checklist is complete.') + "</p>\n        </section>";
    };
    JourneyChecklistWidget.prototype.getItemCompletedTooltip = function (item) {
        var completedDate = item.completedDate, changedByContactFullName = item.changedByContactFullName, changedByUserAccountFullName = item.changedByUserAccountFullName, isAutoCompleted = item.isAutoCompleted;
        if (!completedDate)
            return '';
        var d = new this.windowSvc.Date(completedDate), nameToUse = (isAutoCompleted) ?
            'meeting segment criteria' :
            changedByContactFullName || changedByUserAccountFullName || null, suffix = (nameToUse) ? " by " + nameToUse : '';
        return "Completed on " + clientlibs_1.CoreUtils.Dates.formatWithSlashes(d) + suffix;
    };
    JourneyChecklistWidget.prototype.getChecklistCompletedTooltip = function () {
        var _a;
        if (!((_a = this.checklist) === null || _a === void 0 ? void 0 : _a.completedDate))
            return '';
        var _b = this.checklist, completedDate = _b.completedDate, completedByName = _b.completedByName;
        var d = new this.windowSvc.Date(completedDate), suffix = (completedByName) ? " by " + completedByName : '';
        return "Marked complete on " + clientlibs_1.CoreUtils.Dates.formatWithSlashes(d) + suffix;
    };
    JourneyChecklistWidget.prototype.getGaugePercentComplete = function () {
        return (this.totalItemCount > 0) ? Math.floor((this.completedItemCount / this.totalItemCount) * 100) : 0;
    };
    JourneyChecklistWidget.prototype.getGaugeTitle = function () {
        return this.completedItemCount + " / " + this.totalItemCount + " Items Complete";
    };
    JourneyChecklistWidget.prototype.checkIfAllCompleted = function () {
        if (!this.completeBanner) {
            return;
        }
        if (this.completedItemCount === this.totalItemCount) {
            this.completeBanner.classList.add('in');
        }
        else {
            this.completeBanner.classList.remove('in');
        }
    };
    JourneyChecklistWidget.DOM_PREFIX = 'cz-journey-checklist';
    return JourneyChecklistWidget;
}());
exports.JourneyChecklistWidget = JourneyChecklistWidget;


/***/ }),

/***/ "./src/core/ui-elements/progress-gauge.ts":
/*!************************************************!*\
  !*** ./src/core/ui-elements/progress-gauge.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProgressGauge = void 0;
var GAUGE_ID_PREFIX = 'cz-progress-gauge', GAUGE_CONTAINER_ID_PREFIX = 'cz-progress-gauge-container';
var ProgressGauge = /** @class */ (function () {
    function ProgressGauge(parentDoc, windowSvc, width, height, radius, title, initialPercentComplete) {
        this.parentDoc = parentDoc;
        this.windowSvc = windowSvc;
        this.width = width;
        this.height = height;
        this.radius = radius;
        this.title = title;
        this.percentComplete = 0;
        var timestamp = new this.windowSvc.Date().valueOf();
        this.id = GAUGE_ID_PREFIX + "-" + timestamp;
        // Ensure this element id has not yet been used, since Date.prototype.valeuOf is only "mostly" unique
        while (this.parentDoc.getElementById(this.id)) {
            timestamp = new this.windowSvc.Date().valueOf();
            this.id = GAUGE_ID_PREFIX + "-" + timestamp;
        }
        this.containerId = GAUGE_CONTAINER_ID_PREFIX + "-" + timestamp;
        this.circumference = 2 * Math.PI * this.radius;
        this.circleX = this.width / 2;
        this.circleY = this.height / 2;
        if (typeof initialPercentComplete === 'number') {
            this.percentComplete = initialPercentComplete;
        }
        this.updateDashOffset();
    }
    /**
     * Gets the progress gauge container DOM element
     */
    ProgressGauge.prototype.getContainer = function () {
        if (!this.container) {
            this.container = this.parentDoc.createElement('aside');
            this.container.id = this.containerId;
            this.container.innerHTML = this.getSvgMarkup();
        }
        return this.container;
    };
    /**
     * Removes all progress gauge html and marks out of DOM references for garbage collection
     */
    ProgressGauge.prototype.destroy = function () {
        if (!this.container) {
            return;
        }
        while (this.svg && this.svg.firstChild) {
            this.svg.removeChild(this.svg.lastChild);
        }
        while (this.container.firstChild) {
            this.container.removeChild(this.container.lastChild);
        }
        if (this.container && this.container.parentElement) {
            this.container.parentElement.removeChild(this.container);
        }
        // Mark out of dom elements for GC
        this.svg = null;
        this.container = null;
    };
    /**
     * Updates the progress gauge's DOM markup w/ new information
     * @param percentComplete The percent complete to be updated
     * @param title [optional] The updated title (tooltip) to be displayed
     */
    ProgressGauge.prototype.update = function (percentComplete, title) {
        var svg = this.getSvg(), progress = svg.querySelector('.gauge-progress'), text = svg.querySelector('.gauge-text');
        this.percentComplete = percentComplete;
        this.updateDashOffset();
        progress.setAttribute('stroke-dashoffset', this.dashOffset.toString());
        text.textContent = this.percentComplete.toString() + "%";
        if (title) {
            var titleEl = svg.querySelector('.gauge-title');
            this.title = title;
            titleEl.textContent = this.title;
        }
    };
    /**
     * Updates the progress gauge's dashoffset
     */
    ProgressGauge.prototype.updateDashOffset = function () {
        this.dashOffset = this.circumference * ((100 - this.percentComplete) / 100);
    };
    /**
     * Gets the underlying gauge SVG dom element
     */
    ProgressGauge.prototype.getSvg = function () {
        if (!this.svg) {
            var c = this.getContainer();
            this.svg = c.querySelector("#" + this.id);
        }
        return this.svg;
    };
    /**
     * Gets the progress gauge's SVG markup as a string
     */
    ProgressGauge.prototype.getSvgMarkup = function () {
        return "\n        <svg id=\"" + this.id + "\"\n            class=\"cz-progress-gauge\"\n            width=\"" + this.width + "\"\n            height=\"" + this.height + "\">\n            <title class=\"gauge-title\">" + this.title + "</title>\n            <circle class=\"gauge-base\"\n                cx=\"" + this.circleX + "\"\n                cy=\"" + this.circleY + "\"\n                r=\"" + this.radius + "\"></circle>\n            <circle class=\"gauge-progress\"\n                cx=\"" + this.circleX + "\"\n                cy=\"" + this.circleY + "\"\n                r=\"" + this.radius + "\"\n                stroke-dasharray=\"" + this.circumference + "\"\n                stroke-dashoffset=\"" + this.dashOffset + "\"\n                transform=\"rotate(-90) translate(-" + this.width + " 0)\">\n            </circle>\n            <text class=\"gauge-text\"\n                x=\"" + this.circleX + "\"\n                y=\"" + this.circleY + "\"\n                text-anchor=\"middle\"\n                dominant-baseline=\"central\">" + this.percentComplete + "%</text>\n        </svg>";
    };
    return ProgressGauge;
}());
exports.ProgressGauge = ProgressGauge;


/***/ }),

/***/ "./src/models/SocketIoInitialConnection.ts":
/*!*************************************************!*\
  !*** ./src/models/SocketIoInitialConnection.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var SocketIoInitialConnection = /** @class */ (function () {
    function SocketIoInitialConnection(args) {
        var _this = this;
        if (args === void 0) { args = {}; }
        Object.keys(args).forEach(function (k) {
            _this[k] = args[k];
        });
    }
    return SocketIoInitialConnection;
}());
exports["default"] = SocketIoInitialConnection;


/***/ }),

/***/ "./src/repositories/simpleStorage.repository.ts":
/*!******************************************************!*\
  !*** ./src/repositories/simpleStorage.repository.ts ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var SimpleStorageRepository = /** @class */ (function () {
    // eslint-disable-next-line @typescript-eslint/ban-types
    function SimpleStorageRepository(coder) {
        var _this = this;
        this.store = SimpleStorageRepository.checkForLocalStorage();
        var userCoder = (coder) ? {
            encode: coder.encode,
            decode: coder.decode
        } : {
            encode: JSON.stringify,
            decode: JSON.parse
        };
        if (window.btoa) {
            this.encode = function (value) {
                return _this.btou(userCoder.encode(value));
                //return userCoder.encode(value);
            };
            this.decode = function (value) {
                if (_this.isUBase64(value)) {
                    return userCoder.decode(_this.utob(value));
                }
                else if (_this.isBase64(value)) {
                    return userCoder.decode(window.atob(value));
                }
                else {
                    return userCoder.decode(value);
                }
            };
        }
        else {
            this.encode = userCoder.encode;
            this.decode = userCoder.decode;
        }
    }
    //Statics
    SimpleStorageRepository.checkForLocalStorage = function () {
        try {
            if (typeof (Storage) !== 'undefined') {
                return sessionStorage;
            }
            else {
                // Sorry! No Web Storage support..
                return {};
            }
        }
        catch (e) {
            return {};
        }
    };
    SimpleStorageRepository.formatKey = function (key) {
        return "cz." + key.toLowerCase();
    };
    SimpleStorageRepository.prototype.isUBase64 = function (str) {
        try {
            return this.btou(this.utob(str)) == str;
        }
        catch (err) {
            return false;
        }
    };
    SimpleStorageRepository.prototype.isBase64 = function (str) {
        try {
            return btoa(atob(str)) == str;
        }
        catch (err) {
            return false;
        }
    };
    SimpleStorageRepository.prototype.btou = function (str) {
        return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function (match, p1) {
            return String.fromCharCode(parseInt(p1, 16));
        }));
    };
    SimpleStorageRepository.prototype.utob = function (str) {
        return decodeURIComponent(atob(str).split('').map(function (c) {
            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
        }).join(''));
    };
    SimpleStorageRepository.prototype.set = function (key, value) {
        try {
            this.store[SimpleStorageRepository.formatKey(key)] = this.encode(value);
        }
        catch (e) {
            //meh
        }
    };
    SimpleStorageRepository.prototype.get = function (key, defaultValue) {
        try {
            return this.decode(this.store[SimpleStorageRepository.formatKey(key)]);
        }
        catch (e) {
            //meh
        }
        return defaultValue;
    };
    SimpleStorageRepository.prototype.remove = function (key) {
        try {
            delete this.store[SimpleStorageRepository.formatKey(key)];
        }
        catch (e) {
            //meh
        }
    };
    return SimpleStorageRepository;
}());
exports["default"] = SimpleStorageRepository;


/***/ }),

/***/ "./src/repositories/socket.repository.ts":
/*!***********************************************!*\
  !*** ./src/repositories/socket.repository.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var SessionStorageQueue_1 = __importDefault(__webpack_require__(/*! @src/core/SessionStorageQueue */ "./src/core/SessionStorageQueue.ts"));
var SocketIoInitialConnection_1 = __importDefault(__webpack_require__(/*! @src/models/SocketIoInitialConnection */ "./src/models/SocketIoInitialConnection.ts"));
var errorLogger_1 = __importDefault(__webpack_require__(/*! @src/core/errorLogger */ "./src/core/errorLogger.ts"));
var SocketRepository = /** @class */ (function () {
    function SocketRepository(storageSvc, httpSvc, windowSvc) {
        var _this = this;
        this.storageSvc = storageSvc;
        this.httpSvc = httpSvc;
        this.windowSvc = windowSvc;
        //Private Properties
        this._pollInterval = SocketRepository.defaultPollInterval;
        this._isConnected = false;
        this._preventUsageSends = false;
        this._listeners = {};
        this._pollTimer = null;
        this._connectionTimer = null;
        this._connectionStart = null;
        this._connectionTimeout = (60 * 1000);
        this._lastSocketMessageId = '';
        this._numberOfPollFails = 0;
        this._polling = false;
        this._pollingData = [];
        this._apiUrl = null;
        //UrlTracking
        this._urlTracking = true;
        //ContactKey
        this._contactKey = null;
        //AppVersion
        this._appVersion = "localhost-2022-04-22T18:09:03.829Z"; //gets replaced by build task
        this._disconnectedQueuedSocketMessages = new SessionStorageQueue_1.default(this.storageSvc, this.windowSvc, SocketRepository.storageKeys.DisconnectedQueueKey); //[];
        this.pubsub = new clientlibs_1.PubSuber(errorLogger_1.default);
        this.appHost = this.windowSvc.hostName();
        // TODO - How to get Admin Host
        // http://localhost:53156/api/v1/sockets/;
        // applicationSvc.clientSideUrls().adminHost
        this._apiUrl = null;
        this.windowSvc.addCleanRoomUnload(function () {
            try {
                if (_this._connectionXHR) {
                    console.info('clean room unloaded: Aborting in progress connectionXHR');
                    _this._connectionXHR.abort();
                    _this._connectionXHR = null;
                }
                if (_this._pollXHR) {
                    console.info('clean room unloaded: Aborting in progress pollXHR');
                    _this._pollXHR.abort();
                    _this._pollXHR = null;
                }
            }
            catch (e) {
                //meh
            }
        });
    }
    Object.defineProperty(SocketRepository.prototype, "IsConnected", {
        //Public Properties
        get: function () {
            return this._isConnected;
        },
        enumerable: false,
        configurable: true
    });
    SocketRepository.prototype.connect = function (apiUrl, onConnectCallback, onConnectStatusCallback, onFailureCallback) {
        var _this = this;
        //stash the apiUrl
        this._apiUrl = apiUrl;
        var failureCallback = function (response) {
            if (typeof onFailureCallback === 'function') {
                onFailureCallback(response);
            }
            _this._connectionXHR = null;
            console.log('Clearing ConnectionXHR');
        };
        var successCallback = function (response) {
            _this._connectionXHR = null;
            console.log('Clearing ConnectionXHR');
            _this.connectionSuccessHandler(response, onConnectCallback, onConnectStatusCallback, onFailureCallback);
        };
        try {
            var connectUrl = this.baseUrl('connect');
            var data = {
                contactKey: this.contactKey,
                contactExternalIdHash: this.contactHash,
                accountExternalIdHash: this.accountHash,
                appKey: this.appKey,
                additionalData: {
                    browserInfo: clientlibs_1.CoreUtils.FeatureDetection.getBrowserInfo()
                }
            };
            if (this.urlTracking) {
                data.appKeyHost = this.appHost;
            }
            this._connectionStart = new this.windowSvc.Date().getTime();
            console.log('Setting ConnectionXHR');
            this._connectionXHR = this.httpSvc.Post(connectUrl, data, true, successCallback, failureCallback);
        }
        catch (e) {
            failureCallback('Error Connecting');
        }
    };
    SocketRepository.prototype.connectionSuccessHandler = function (response, onConnectCallback, onConnectStatusCallback, onFailureCallback) {
        var connectInfo = new SocketIoInitialConnection_1.default(response);
        if (!clientlibs_1.CoreUtils.Strings.isNullOrEmpty(connectInfo.connectionKey)) {
            var shortCircuitConnect_1 = false;
            if (typeof onConnectStatusCallback === 'function') {
                var callbackResponse = onConnectStatusCallback(connectInfo);
                if (callbackResponse === false) {
                    shortCircuitConnect_1 = true;
                }
                if (typeof callbackResponse === 'string') {
                    this._apiUrl = callbackResponse;
                }
            }
            if (shortCircuitConnect_1) {
                return;
            }
            console.log('Connection Status Polling beginning');
            this.connectionPoll(connectInfo.connectionKey, onConnectCallback, onConnectStatusCallback, onFailureCallback);
            return;
        }
        this._isConnected = true;
        this._connectionXHR = null;
        console.log('Clearing ConnectionXHR');
        if (!connectInfo.tenantId || clientlibs_1.CoreUtils.Strings.isNullOrEmpty(connectInfo.authKey)) {
            var suffix = (!connectInfo.tenantId) ? 'TenantId' : 'AuthKey';
            if (!response) {
                suffix = 'Falsy Response';
            }
            suffix += ' - ';
            try {
                suffix += Object.prototype.toString.call(response);
            }
            catch (e) {
                suffix += 'Sad Times';
            }
            var shouldLog = true;
            try {
                if (response && typeof response === 'string') {
                    var trimmedResponse = response.trim();
                    var ender = '/html>';
                    shouldLog = !(trimmedResponse.substring(trimmedResponse.length - ender.length, trimmedResponse.length) === ender);
                }
            }
            catch (ex) {
                //meh
                shouldLog = true;
            }
            if (shouldLog) {
                errorLogger_1.default.report('SocketRepository.successCallback', new Error('Bad ConnectionInfo - ' + suffix));
            }
            if (typeof onFailureCallback === 'function') {
                onFailureCallback(response);
            }
            this._connectionXHR = null;
            console.log('Clearing ConnectionXHR');
            return;
        }
        this._authKey = connectInfo.authKey;
        this._tenantId = connectInfo.tenantId;
        this._preventUsageSends = ((connectInfo.functionality || {})['devlessEnabled']) || false;
        var queueKey = SocketRepository.storageKeys.QueueKey + "-" + this.contactKey;
        console.log('New QueueKey', queueKey);
        this._queuedSocketMessages = new SessionStorageQueue_1.default(this.storageSvc, this.windowSvc, queueKey);
        var oldQueueStyle = new SessionStorageQueue_1.default(this.storageSvc, this.windowSvc, SocketRepository.storageKeys.QueueKey + "-" + connectInfo.appKey + "-" + this.contactKey);
        if (oldQueueStyle.length) {
            var items = oldQueueStyle.getAllItems();
            this._queuedSocketMessages.unshiftAll(items);
            oldQueueStyle.empty();
        }
        var shortCircuitConnect = false;
        if (typeof onConnectCallback === 'function') {
            var callbackResponse = onConnectCallback(connectInfo);
            if (callbackResponse === false) {
                shortCircuitConnect = true;
            }
            if (typeof callbackResponse === 'string') {
                this._apiUrl = callbackResponse;
            }
        }
        if (shortCircuitConnect) {
            return;
        }
        //trigger any registered initial connection methods
        this.pubsub.publish(clientlibs_1.SocketMessageTypes.SOCKETMESSAGETYPE_INITIAL_CONNECTION, connectInfo);
        //start polling loop
        this.poll();
    };
    SocketRepository.prototype.disconnect = function () {
        this._isConnected = false;
        if (this._connectionTimer) {
            clearTimeout(this._connectionTimer);
            this._connectionTimer = null;
        }
        if (this._connectionXHR) {
            console.info('Disconnect: Aborting in progress connectionXHR');
            this._connectionXHR.abort();
            this._connectionXHR = null;
        }
        this._authKey = null;
        this._tenantId = null;
        this._apiUrl = null;
        this._queuedSocketMessages = null;
        if (this._pollTimer) {
            console.info('Disconnect: clearing in progress poll timer');
            clearTimeout(this._pollTimer);
            this._pollTimer = null;
        }
        if (this._pollXHR) {
            console.info('Disconnect: Aborting in progress pollXHR');
            this._pollXHR.abort();
            this._pollXHR = null;
        }
        //trigger any registered disconnect methods
        this.pubsub.publish(clientlibs_1.SocketMessageTypes.SOCKETMESSAGETYPE_DISCONNECT);
    };
    SocketRepository.prototype.connectionPoll = function (connectionKey, onConnectCallback, onConnectStatusCallback, onFailureCallback) {
        var _this = this;
        var connectStatus = this.baseUrl('connectStatus');
        var failureCallback = function (response) {
            if (typeof onFailureCallback === 'function') {
                onFailureCallback(response);
            }
            _this._connectionXHR = null;
            console.log('Clearing ConnectionXHR');
        };
        var data = {
            appKey: this.appKey,
            additionalData: {
                connectionKey: connectionKey
            }
        };
        this.windowSvc.window.clearTimeout(this._connectionTimer);
        this._connectionTimer = this.windowSvc.window.setTimeout(function () {
            try {
                console.log('Setting ConnectionXHR');
                _this._connectionXHR = _this.httpSvc.Post(connectStatus, data, true, function (response) {
                    var duration = (new _this.windowSvc.Date().getTime()) - _this._connectionStart;
                    if (response) {
                        _this._connectionStart = null;
                        _this.connectionSuccessHandler(response, onConnectCallback, onConnectStatusCallback, onFailureCallback);
                    }
                    else if (duration <= _this._connectionTimeout) {
                        _this.connectionPoll(connectionKey, onConnectCallback, onConnectStatusCallback, onFailureCallback);
                    }
                    else {
                        _this.windowSvc.window.setTimeout(function () {
                            _this.connect(_this._apiUrl, onConnectCallback, onConnectStatusCallback, onFailureCallback);
                        }, (15000));
                    }
                }, failureCallback);
            }
            catch (ex) {
                failureCallback(ex);
            }
        }, 1000);
    };
    SocketRepository.prototype.send = function (socketMessageTypeId, messageContent, forcePoll) {
        var socketMessage = this.buildProperSocketMessage(socketMessageTypeId, messageContent);
        if (this.IsConnected) {
            this._queuedSocketMessages.push(socketMessage);
        }
        else {
            this._disconnectedQueuedSocketMessages.push(socketMessage);
        }
        if (forcePoll) {
            this.poll();
        }
    };
    SocketRepository.prototype.setPollInterval = function (pollInterval) {
        var doPoll = false;
        if (pollInterval < this._pollInterval && this._numberOfPollFails === 0) {
            doPoll = true;
        }
        this._pollInterval = pollInterval;
        if (doPoll) {
            //console.log("Poll Interval Changed. Polling now...");
            this.poll();
        }
        else {
            //console.log("Poll Interval Changed. Polling in " + pollInterval / 1000);
        }
    };
    SocketRepository.prototype.resetPollIntervalToDefault = function () {
        this.setPollInterval(SocketRepository.defaultPollInterval);
    };
    SocketRepository.prototype.destroy = function () {
        this.reset();
    };
    SocketRepository.prototype.reset = function () {
        this.disconnect();
        this._disconnectedQueuedSocketMessages.empty();
    };
    SocketRepository.prototype.registerListener = function (eventName, callbackFunction) {
        return this.pubsub.subscribe(eventName, callbackFunction);
    };
    SocketRepository.prototype.registerMirror = function (mirrorFn) {
        return this.pubsub.addMirror(mirrorFn);
    };
    SocketRepository.prototype.publishMirrored = function (message) {
        this.pubsub.publishMirrored(message);
    };
    SocketRepository.prototype.clearAllListeners = function () {
        this._listeners = {};
    };
    SocketRepository.prototype.flush = function () {
        this.poll();
    };
    /**
     * Initiate an http call to the server with any queued socket messages
     */
    SocketRepository.prototype.poll = function () {
        var _this = this;
        //if already polling short circuit
        if (this._polling) {
            return;
        }
        //if not connected, short circuit
        if (!this.IsConnected) {
            console.log('stopping POLL not connected');
            return;
        }
        //lock polling
        this._polling = true;
        if (this._pollTimer) {
            this.windowSvc.window.clearTimeout(this._pollTimer);
        }
        //check that a xhr object can be readied.
        try {
            this.windowSvc.XMLHttpRequestReference();
        }
        catch (e) {
            //if not the next polling attempt will try again
            this.pollFailure([]);
            return;
        }
        //move over any items that were queued while disconnected
        // this is done specifically in such a way to reduce likelihood of
        // infinite loop.
        var items = this._disconnectedQueuedSocketMessages.getAllItems();
        if (items.length) {
            this._queuedSocketMessages.unshiftAll(items);
            this._disconnectedQueuedSocketMessages.empty();
            console.log('Moved Items from disconnected to current queue', items.length);
        }
        /*let currentQueLength = this._disconnectedQueuedSocketMessages.length;
        while (currentQueLength > 0) {
            let item = this._disconnectedQueuedSocketMessages.shift();
            this._queuedSocketMessages.push(item);
            currentQueLength--;
        }*/
        //these variables are used to ensure that only one instance of
        // the given type of message is ever sent. Each variable here
        // will have a corresponding case statement in the switch below
        //
        // For example, if the
        // queuedSocketMessages contains multiple CheckOnline messages
        // we dont really care because just 1 will do the job so only
        // push the last instance.
        var lastIsActiveSocketMessage = null;
        //var lastCheckOnlineMessage = null;
        var lastCheckEventMapConfigMessage = null;
        var lastCheckPageTagConfigMessage = null;
        var lastCheckWalkthroughConfigMessage = null;
        var lastCheckChecklistConfigMessage = null;
        //create a new queue of messages so that while we are polling
        // messages can still be added to the queue and if our poll fails
        // we can preserve the messages that were attempted to be sent
        this._pollingData = this._queuedSocketMessages.getAllItems();
        var currentQueuedSocketMessages = [];
        var queLength = this._pollingData.length;
        var _loop_1 = function (i) {
            var socketMessage = this_1._pollingData[i];
            if (clientlibs_1.CoreUtils.isNullOrUndefined(socketMessage)) {
                return "continue";
            }
            switch (socketMessage.socketMessageTypeId) {
                case clientlibs_1.SocketMessageTypes.SOCKETMESSAGETYPE_IS_ACTIVE:
                    if (!this_1._preventUsageSends) {
                        lastIsActiveSocketMessage = socketMessage;
                    }
                    break;
                case clientlibs_1.SocketMessageTypes.SOCKETMESSAGETYPE_CHECK_EVENT_MAP_CONFIG_VERSION:
                    lastCheckEventMapConfigMessage = socketMessage;
                    break;
                case clientlibs_1.SocketMessageTypes.SOCKETMESSAGETYPE_CheckPageTagConfigVersion:
                    lastCheckPageTagConfigMessage = socketMessage;
                    break;
                case clientlibs_1.SocketMessageTypes.SOCKETMESSAGETYPE_CheckWalkthroughConfigVersion:
                    lastCheckWalkthroughConfigMessage = socketMessage;
                    break;
                case clientlibs_1.SocketMessageTypes.SOCKETMESSAGETYPE_CheckChecklistConfigVersion:
                    lastCheckChecklistConfigMessage = socketMessage;
                    break;
                case clientlibs_1.SocketMessageTypes.SOCKETMESSAGETYPE_SET_ATTRIBUTE: {
                    if (this_1._preventUsageSends) {
                        break;
                    }
                    var attributeItem_1 = socketMessage.messageContent;
                    //if it is a setAttribute action
                    if (attributeItem_1.action === 'setAttribute') {
                        //loop over the current queued messages
                        var wasMerged_1 = false;
                        currentQueuedSocketMessages.forEach(function (cqSm) {
                            //only merge once please
                            if (wasMerged_1) {
                                return;
                            }
                            try {
                                if (cqSm.socketMessageTypeId === clientlibs_1.SocketMessageTypes.SOCKETMESSAGETYPE_SET_ATTRIBUTE
                                    && cqSm.messageContent.action === 'setAttribute'
                                    && cqSm.messageContent.entity === attributeItem_1.entity) {
                                    //if entity matches,
                                    var cqSmDate = _this.windowSvc.Date.parse(cqSm.messageDate), socketMessageDate = _this.windowSvc.Date.parse(socketMessage.messageDate), cqSmAttributeItem = cqSm.messageContent;
                                    if (cqSmDate <= socketMessageDate) {
                                        //layer socketMessage over item in queue
                                        cqSmAttributeItem.attributes = __assign(__assign({}, cqSmAttributeItem.attributes), attributeItem_1.attributes);
                                        cqSm.messageDate = socketMessage.messageDate;
                                        wasMerged_1 = true;
                                    }
                                    else if (cqSmDate > socketMessageDate) {
                                        cqSmAttributeItem.attributes = __assign(__assign({}, attributeItem_1.attributes), cqSmAttributeItem.attributes);
                                        wasMerged_1 = true;
                                    }
                                }
                            }
                            catch (_a) {
                                //meh
                            }
                        });
                        //if this socketMessage was merged in to a preexisting one, then we are done
                        if (wasMerged_1) {
                            break;
                        }
                    }
                    currentQueuedSocketMessages.push(socketMessage);
                    break;
                }
                case clientlibs_1.SocketMessageTypes.SOCKETMESSAGETYPE_TRACK_EVENT:
                case clientlibs_1.SocketMessageTypes.SOCKETMESSAGETYPE_TIME_IN_APP:
                case clientlibs_1.SocketMessageTypes.SOCKETMESSAGETYPE_WalkthroughAction:
                case clientlibs_1.SocketMessageTypes.SOCKETMESSAGETYPE_MESSAGE_READ:
                case clientlibs_1.SocketMessageTypes.SOCKETMESSAGETYPE_MESSAGE_CLICKED:
                case clientlibs_1.SocketMessageTypes.SOCKETMESSAGETYPE_ChecklistItemToggle:
                case clientlibs_1.SocketMessageTypes.SOCKETMESSAGETYPE_ChecklistMarkComplete:
                    if (this_1._preventUsageSends) {
                        break;
                    }
                    currentQueuedSocketMessages.push(socketMessage);
                    break;
                default:
                    currentQueuedSocketMessages.push(socketMessage);
                    break;
            }
        };
        var this_1 = this;
        for (var i = 0; i < queLength; i++) {
            _loop_1(i);
        }
        //this is where we actually add the single instance of message
        // types we only want 1 instance of to the currentQueue
        if (lastIsActiveSocketMessage) {
            currentQueuedSocketMessages.push(lastIsActiveSocketMessage);
        }
        if (lastCheckEventMapConfigMessage) {
            currentQueuedSocketMessages.push(lastCheckEventMapConfigMessage);
        }
        if (lastCheckPageTagConfigMessage) {
            currentQueuedSocketMessages.push(lastCheckPageTagConfigMessage);
        }
        if (lastCheckWalkthroughConfigMessage) {
            currentQueuedSocketMessages.push(lastCheckWalkthroughConfigMessage);
        }
        if (lastCheckChecklistConfigMessage) {
            currentQueuedSocketMessages.push(lastCheckChecklistConfigMessage);
        }
        //certain types of socket messages need session identifiers only present
        // when a connection is present
        currentQueuedSocketMessages.forEach(function (item) {
            if (_this.needsSessionIdentifiers(item)) {
                _this.addSessionIdentifiersToObject(item.messageContent);
            }
        });
        var url = this.baseUrl('poll');
        //if there is a lastSocketMessageId then append it
        // to the query string params so that only messages
        // since that id will be returned
        if (this._lastSocketMessageId) {
            url = url + '&lastId=' + encodeURIComponent(this._lastSocketMessageId);
        }
        //remove any nulls or undefined
        var cleanedQueue = currentQueuedSocketMessages.filter(function (item) {
            return item !== null && item !== undefined;
        });
        //console.log("Polling with", cleanedQueue);
        //if there are no queued messages to send
        // do a get to pickup any messages the server might need to send down
        //if there are queued messages to send
        // do a post to push the queued messages up to the server and pickup
        // any messages the server might need to send down
        //console.time("POLLTIME");
        if (currentQueuedSocketMessages.length === 0) {
            this._pollXHR = this.httpSvc.Get(url, function (socketMessages) { return _this.pollSuccess(socketMessages); }, function (responseText, failedQueuedSocketMessages) { return _this.pollFailure(failedQueuedSocketMessages); });
        }
        else {
            /*console.info("Polling with...");
            console["table"](currentQueuedSocketMessages);*/
            this._pollXHR = this.httpSvc.Post(url, cleanedQueue, false, function (socketMessages) { return _this.pollSuccess(socketMessages); }, function (responseText, failedQueuedSocketMessages) { return _this.pollFailure(failedQueuedSocketMessages); });
        }
    };
    /**
     * Notify any listeners of any received SocketMessages
     * If still connected, setup the next poll interval
     * If there are already queued socket messages repoll immediately
     * @param socketMessages
     */
    SocketRepository.prototype.pollSuccess = function (socketMessages) {
        var _this = this;
        //console.log("Polling Success");
        //remove sent data from storage queue
        if (this._pollingData && this._pollingData.length && this._queuedSocketMessages) {
            var ids_1 = this._pollingData.map(function (q) {
                return q.id;
            });
            this._queuedSocketMessages.removeAll(this._pollingData, function (a) {
                return ids_1.indexOf(a.id) === -1;
            });
        }
        //clear out polling data for next poll
        this._pollingData = [];
        //loop over any returned messages and call any listeners for the given MessageTypeId
        // update _lastSocketMessageId to be the last message that was announced
        for (var i = 0; i < socketMessages.length; i++) {
            this.pubsub.publish(socketMessages[i].socketMessageTypeId, socketMessages[i].messageContent);
            if (socketMessages[i].id) {
                this._lastSocketMessageId = socketMessages[i].id;
            }
        }
        //unlock polling
        this._polling = false;
        this._pollXHR = null;
        //console.timeEnd("POLLTIME");
        //reset fail counter
        this._numberOfPollFails = 0;
        if (this._isConnected) {
            if (this._queuedSocketMessages.length > 0) {
                //if there are already queued messages, just repoll
                console.log('re-polling');
                this.poll();
            }
            else {
                //reset the poll interval
                this._pollTimer = this.windowSvc.window.setTimeout(function () {
                    try {
                        _this.poll();
                    }
                    catch (ex) {
                        //report?
                        errorLogger_1.default.report('SocketRepository.pollSuccess', ex);
                    }
                }, this._pollInterval);
            }
        }
    };
    /**
     * Requeue any SocketMessages that were attempted to be sent.
     * If still connected, setup the next poll interval
     * @param failedQueuedSocketMessages
     */
    SocketRepository.prototype.pollFailure = function (failedQueuedSocketMessages) {
        var _this = this;
        failedQueuedSocketMessages = failedQueuedSocketMessages || [];
        var queueLength = failedQueuedSocketMessages.length, requeues = [];
        if (queueLength > 0) {
            //requeue any messages
            while (queueLength > 0) {
                var queuedSocketMessage = failedQueuedSocketMessages.pop();
                queueLength--;
                if (this.needsSessionIdentifiers(queuedSocketMessage)) {
                    this.removeSessionIdentifiersFromObject(queuedSocketMessage.messageContent);
                }
                var alreadyExists = false;
                try {
                    var currentQueueItems = void 0;
                    if (this.IsConnected) {
                        currentQueueItems = this._queuedSocketMessages.getAllItems();
                    }
                    else {
                        currentQueueItems = this._disconnectedQueuedSocketMessages.getAllItems();
                    }
                    var currentQueueLength = (currentQueueItems || []).length;
                    for (var i = 0; i < currentQueueLength; i++) {
                        if (currentQueueItems[i].id === queuedSocketMessage.id) {
                            alreadyExists = true;
                            i = currentQueueLength + 1;
                        }
                    }
                }
                catch (err) {
                    //meh?
                }
                if (!alreadyExists) {
                    requeues.unshift(queuedSocketMessage);
                }
            }
            if (requeues && requeues.length) {
                console.log('Requeueing:', requeues);
                if (this.IsConnected) {
                    this._queuedSocketMessages.unshiftAll(requeues);
                }
                else {
                    this._disconnectedQueuedSocketMessages.unshiftAll(requeues);
                }
            }
        }
        //unlock polling
        this._polling = false;
        this._pollXHR = null;
        //console.timeEnd("POLLTIME");
        //bump the failure count
        if (this._numberOfPollFails < 5) {
            this._numberOfPollFails++;
        }
        var failBuffer = (1000 * 60);
        //reset the poll interval
        if (this._isConnected) {
            this._pollTimer = this.windowSvc.window.setTimeout(function () {
                try {
                    _this.poll();
                }
                catch (ex) {
                    //report?
                    errorLogger_1.default.report('SocketRepository.pollFailure', ex);
                }
            }, this._pollInterval + (failBuffer * this._numberOfPollFails));
        }
    };
    /**
     * Create a SocketMessage to be sent back to the server
     * @param socketMessageTypeId
     * @param messageContent
     */
    SocketRepository.prototype.buildProperSocketMessage = function (socketMessageTypeId, messageContent) {
        if (!socketMessageTypeId) {
            throw new Error('message type can not be blank');
        }
        var socketMessage = {
            id: clientlibs_1.DataTypeUtils.newGuid(),
            socketMessageTypeId: socketMessageTypeId,
            messageDate: new this.windowSvc.Date().toISOString(),
            messageContent: messageContent //this.windowSvc.clone(messageContent)
        };
        if (messageContent && messageContent['messageKey']) {
            socketMessage.id = messageContent['messageKey'];
        }
        return socketMessage;
    };
    /**
     * Generate the base action url for a given method
     * param: methodName
     */
    SocketRepository.prototype.baseUrl = function (methodName) {
        var queryString = {
            t: this.windowSvc.Date.now(),
            v: this.appVersion
        };
        if (this._authKey) {
            queryString['socketKey'] = encodeURIComponent(this._authKey);
        }
        var queryStringString = clientlibs_1.CoreUtils.Urls.buildQueryStringString(queryString), urlBase = "" + this._apiUrl + methodName;
        if (this._tenantId) {
            urlBase += "/" + this._tenantId;
        }
        return urlBase + queryStringString;
    };
    //Session Identifier Methods
    SocketRepository.prototype.hasValidSessionIdentifiers = function () {
        var appKeyValid = this.isAppKeyValid(this.appKey);
        var appHostValid = this.urlTracking ? this.isAppHostValid() : true;
        var contactKeyValid = this.isContactKeyValid(this.contactKey);
        return appKeyValid && appHostValid && contactKeyValid;
    };
    SocketRepository.prototype.needsSessionIdentifiers = function (socketMessage) {
        switch (socketMessage.socketMessageTypeId) {
            case clientlibs_1.SocketMessageTypes.SOCKETMESSAGETYPE_SET_ATTRIBUTE:
            case clientlibs_1.SocketMessageTypes.SOCKETMESSAGETYPE_TRACK_EVENT:
            case clientlibs_1.SocketMessageTypes.SOCKETMESSAGETYPE_WalkthroughAction:
            case clientlibs_1.SocketMessageTypes.SOCKETMESSAGETYPE_CheckWalkthroughConfigVersion:
            case clientlibs_1.SocketMessageTypes.SOCKETMESSAGETYPE_CheckChecklistConfigVersion:
            case clientlibs_1.SocketMessageTypes.SOCKETMESSAGETYPE_ChecklistItemToggle:
            case clientlibs_1.SocketMessageTypes.SOCKETMESSAGETYPE_ChecklistMarkComplete:
                return true;
            default:
                return false;
        }
    };
    SocketRepository.prototype.addSessionIdentifiersToObject = function (item) {
        item['appKey'] = this.appKey;
        if (this.urlTracking) {
            item['appKeyHost'] = this.appHost;
        }
        var key = (this.contactKey || '').split(SocketRepository.separator);
        item['accountExternalId'] = key[0];
        item['contactExternalId'] = key[1];
    };
    SocketRepository.prototype.removeSessionIdentifiersFromObject = function (item) {
        delete item.appKey;
        delete item.appKeyHost;
        delete item.accountExternalId;
        delete item.contactExternalId;
    };
    Object.defineProperty(SocketRepository.prototype, "appKey", {
        get: function () {
            //if the current appkey does not exist,
            // try to load it from storage
            //if (!this._appKey) {
            //    this._appKey = this.storageSvc.get(SocketRepository.storageKeys.AppKey, this._appKey);
            //}
            return this._appKey;
        },
        set: function (appKey) {
            this._appKey = appKey;
            //store current state of AppKey
            //this.storageSvc.set(SocketRepository.storageKeys.AppKey, this._appKey);
        },
        enumerable: false,
        configurable: true
    });
    SocketRepository.prototype.isAppKeyValid = function (keyToValidate) {
        if (keyToValidate && keyToValidate.length > 0) {
            return true;
        }
        return false;
    };
    Object.defineProperty(SocketRepository.prototype, "appHost", {
        get: function () {
            return this._appHost;
        },
        set: function (host) {
            this._appHost = host;
        },
        enumerable: false,
        configurable: true
    });
    SocketRepository.prototype.isAppHostValid = function () {
        return (this.appHost !== undefined && this.appHost.length > 0) && this.appHost.length > 0;
    };
    Object.defineProperty(SocketRepository.prototype, "urlTracking", {
        get: function () {
            return this._urlTracking;
        },
        set: function (enabled) {
            this._urlTracking = enabled;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SocketRepository.prototype, "contactKey", {
        get: function () {
            return this._contactKey;
        },
        set: function (newValue) {
            this._setDisconnectedQueue(newValue);
            //if empty values are found
            // set everything to empty
            if (!newValue) {
                this._resetContactKey();
                return;
            }
            this._contactKey = newValue;
        },
        enumerable: false,
        configurable: true
    });
    SocketRepository.prototype.isContactKeyValid = function (keyToValidate) {
        //if there is no contactKey short circuit
        if (!keyToValidate) {
            return false;
        }
        if (keyToValidate.length === 0 || keyToValidate.indexOf(SocketRepository.separator) === -1) {
            return false;
        }
        var ids = this.splitContactKey(keyToValidate);
        ids.accountExternalId = ids.accountExternalId || '';
        var validAccount = false;
        if (ids.accountExternalId !== undefined && ids.accountExternalId !== null) {
            validAccount = ids.accountExternalId.length > 0 && ids.accountExternalId.length <= 100;
        }
        var validContact = false;
        if (ids.contactExternalId !== undefined && ids.contactExternalId !== null) {
            validContact = ids.contactExternalId.length > 0;
        }
        return validAccount && validContact;
    };
    SocketRepository.prototype.splitContactKey = function (keyToSplit) {
        var splitContactKey = (keyToSplit || '').split(SocketRepository.separator);
        var accountExternalId = null;
        var contactExternalId = null;
        if (splitContactKey && splitContactKey.length === 2) {
            accountExternalId = splitContactKey[0];
            contactExternalId = splitContactKey[1];
        }
        return { accountExternalId: accountExternalId, contactExternalId: contactExternalId };
    };
    SocketRepository.prototype.generateContactKey = function (accountExternalId, contactExternalId) {
        return "" + accountExternalId + SocketRepository.separator + contactExternalId;
    };
    SocketRepository.prototype.getContactKeyFromCache = function () {
        //if the contactKey has not been set yet
        // first try local storage
        var contactKey = this.storageSvc.get(SocketRepository.storageKeys.ContactKey, null);
        // then try the cookie
        /*if (!contactKey) {
            contactKey = CoreUtils.readCookie(SocketRepository.storageKeys.ContactKeyCookie);
        }*/
        console.log('get key from cache:', contactKey);
        return contactKey;
    };
    Object.defineProperty(SocketRepository.prototype, "accountHash", {
        get: function () {
            return this._accountHash;
        },
        set: function (newValue) {
            this._accountHash = newValue;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SocketRepository.prototype, "contactHash", {
        get: function () {
            return this._contactHash;
        },
        set: function (newValue) {
            this._contactHash = newValue;
        },
        enumerable: false,
        configurable: true
    });
    SocketRepository.prototype._setDisconnectedQueue = function (newValue) {
        var key = "" + SocketRepository.storageKeys.DisconnectedQueueKey;
        if (newValue) {
            key += "-" + newValue;
        }
        var knownDisconnect = new SessionStorageQueue_1.default(this.storageSvc, this.windowSvc, key);
        //if the new key is the default and the old one was not the default, dont copy items over
        if (key !== SocketRepository.storageKeys.DisconnectedQueueKey
            && this._disconnectedQueuedSocketMessages.key !== this.storageSvc.encode(SocketRepository.storageKeys.DisconnectedQueueKey)) {
            //copy items from old disconnected queue to new one
            var oldItems = this._disconnectedQueuedSocketMessages.getAllItems();
            if (oldItems.length) {
                knownDisconnect.unshiftAll(oldItems);
                this._disconnectedQueuedSocketMessages.empty();
            }
        }
        //set disconnected queue to new one
        this._disconnectedQueuedSocketMessages = knownDisconnect;
    };
    SocketRepository.prototype._resetContactKey = function () {
        this._contactKey = null;
        this._accountHash = null;
        this._contactHash = null;
        this.storageSvc.remove(SocketRepository.storageKeys.ContactKey);
        //CoreUtils.eraseCookie(SocketRepository.storageKeys.ContactKeyCookie, new this.windowSvc.Date());
    };
    Object.defineProperty(SocketRepository.prototype, "appVersion", {
        get: function () {
            //getter
            return this._appVersion;
        },
        enumerable: false,
        configurable: true
    });
    //Statics
    SocketRepository.separator = '~|~';
    SocketRepository.defaultPollInterval = 10000;
    SocketRepository.storageKeys = {
        AppKey: 'APP_KEY',
        ContactKey: 'CONTACTKEY_KEY',
        QueueKey: 'CZ_QUEUE_KEY',
        DisconnectedQueueKey: 'CZ_DISCONNECTED_QUEUE_KEY',
        ContactKeyCookie: 'ChurnZeroUser'
    };
    return SocketRepository;
}());
exports["default"] = SocketRepository;


/***/ }),

/***/ "./src/repositories/subframe.repository.ts":
/*!*************************************************!*\
  !*** ./src/repositories/subframe.repository.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var errorLogger_1 = __importDefault(__webpack_require__(/*! @src/core/errorLogger */ "./src/core/errorLogger.ts"));
var socket_repository_1 = __importDefault(__webpack_require__(/*! @src/repositories/socket.repository */ "./src/repositories/socket.repository.ts"));
var Enums_1 = __webpack_require__(/*! @src/core/Enums */ "./src/core/Enums.ts");
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var SubframeRepository = /** @class */ (function () {
    function SubframeRepository(windowSvc, applicationSvc, mainFrame) {
        this.windowSvc = windowSvc;
        this.applicationSvc = applicationSvc;
        this.mainFrame = mainFrame;
        this._listeners = {};
        //AppVersion
        this._appVersion = "localhost-2022-04-22T18:09:03.829Z"; //gets replaced by build task
        this.pubsub = new clientlibs_1.PubSuber(errorLogger_1.default);
        this.appHost = this.windowSvc.hostName();
    }
    Object.defineProperty(SubframeRepository.prototype, "appVersion", {
        get: function () {
            //getter
            return this._appVersion;
        },
        enumerable: false,
        configurable: true
    });
    SubframeRepository.prototype.clearAllListeners = function () {
        this._listeners = {};
    };
    SubframeRepository.prototype.connect = function (apiUrl, onConnectCallback, onConnectStatusCallback, onFailureCallback) {
    };
    SubframeRepository.prototype.destroy = function () {
        this.reset();
    };
    SubframeRepository.prototype.disconnect = function () {
    };
    SubframeRepository.prototype.generateContactKey = function (accountExternalId, contactExternalId) {
        return "" + accountExternalId + socket_repository_1.default.separator + contactExternalId;
    };
    SubframeRepository.prototype.getContactKeyFromCache = function () {
        return '';
    };
    SubframeRepository.prototype.isAppHostValid = function () {
        return false;
    };
    SubframeRepository.prototype.isAppKeyValid = function (keyToValidate) {
        return false;
    };
    SubframeRepository.prototype.isContactKeyValid = function (keyToValidate) {
        return false;
    };
    SubframeRepository.prototype.reset = function () {
        this.disconnect();
    };
    SubframeRepository.prototype.resetPollIntervalToDefault = function () {
    };
    SubframeRepository.prototype.send = function (socketMessageTypeId, messageContent, forcePoll) {
        this.applicationSvc.messageMain({
            code: Enums_1.Enums.FrameCommCodes.SubFramePassback,
            data: {
                type: 'send',
                data: { socketMessageTypeId: socketMessageTypeId, messageContent: messageContent, forcePoll: forcePoll }
            }
        });
    };
    SubframeRepository.prototype.flush = function () {
        //do nothing as the main will handle
    };
    SubframeRepository.prototype.setPollInterval = function (pollInterval) {
    };
    SubframeRepository.prototype.splitContactKey = function (keyToSplit) {
        var splitContactKey = (keyToSplit || '').split(socket_repository_1.default.separator);
        var accountExternalId = null;
        var contactExternalId = null;
        if (splitContactKey && splitContactKey.length === 2) {
            accountExternalId = splitContactKey[0];
            contactExternalId = splitContactKey[1];
        }
        return { accountExternalId: accountExternalId, contactExternalId: contactExternalId };
    };
    SubframeRepository.prototype.registerListener = function (eventName, callbackFunction) {
        return this.pubsub.subscribe(eventName, callbackFunction);
    };
    SubframeRepository.prototype.publishMirrored = function (message) {
        this.pubsub.publishMirrored(message);
    };
    SubframeRepository.prototype.registerMirror = function (mirrorFn) {
        return this.pubsub.addMirror(mirrorFn);
    };
    return SubframeRepository;
}());
exports["default"] = SubframeRepository;


/***/ }),

/***/ "./src/services/application.service.ts":
/*!*********************************************!*\
  !*** ./src/services/application.service.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Templater_1 = __importDefault(__webpack_require__(/*! @src/core/Templater */ "./src/core/Templater.ts"));
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var Enums_1 = __webpack_require__(/*! @src/core/Enums */ "./src/core/Enums.ts");
var clientlibs_2 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var errorLogger_1 = __importDefault(__webpack_require__(/*! @src/core/errorLogger */ "./src/core/errorLogger.ts"));
var ApplicationService = /** @class */ (function () {
    function ApplicationService(storageSvc, windowSvc) {
        this.storageSvc = storageSvc;
        this.windowSvc = windowSvc;
        //get an array of all registered sub frames (window objects)
        this._registeredSubframes = {};
        this.isChildFrameListenerAttached = false;
        this.isFrameComListenerAttached = false;
        //**********************//
        // Self Hosted
        //**********************//
        this._isSelfHosted = false;
        this.pubsub = new clientlibs_1.PubSuber(errorLogger_1.default);
        this._registeredSubframes = {};
        //setup templater
        this.templater = new Templater_1.default(this.windowSvc.czq);
    }
    Object.defineProperty(ApplicationService.prototype, "registeredSubFrames", {
        get: function () {
            return this._registeredSubframes;
        },
        set: function (subFrames) {
            this._registeredSubframes = subFrames;
        },
        enumerable: false,
        configurable: true
    });
    ApplicationService.prototype.getRegisteredSubFrameById = function (id) {
        return this._registeredSubframes[id];
    };
    //Keep track of a subframe widnow object
    ApplicationService.prototype.registerSubFrame = function (subFrame, origin, vcode) {
        var key = clientlibs_2.DataTypeUtils.newGuid();
        this._registeredSubframes[key] = { window: subFrame, origin: origin };
        this.pubsub.publish(clientlibs_1.ChurnZeroAppEvents.SubframeRegistered, { source: key, vcode: vcode });
    };
    //**********************//
    // ClientSide Urls
    //**********************//
    ApplicationService.prototype.setupClientSideUrls = function () {
        //init the Error Logger to the connection domain
        errorLogger_1.default.initLogger(this.windowSvc.clientSideUrls.sockets, true);
        //add CDN to the templater
        this.templater.addGlobal('cdn', this.windowSvc.cdnUrl);
    };
    Object.defineProperty(ApplicationService.prototype, "environment", {
        get: function () {
            var baseApiUrl = this.windowSvc.clientSideUrls.baseApiUrl;
            var environment = 'p';
            if (baseApiUrl.indexOf('localhost:53157') >= 0) {
                //localhost
                environment = 'd';
            }
            else if (baseApiUrl.indexOf('apptest.churnzerolabs.com') >= 0 || baseApiUrl.indexOf('analyticstest.churnzerolabs.com') >= 0) {
                //test
                environment = 't';
            }
            else if (baseApiUrl.indexOf('appbranch01.churnzerolabs.com') >= 0) {
                //branch01
                environment = 't';
            }
            else if (baseApiUrl.indexOf('appstaging.churnzerolabs.com') >= 0) {
                //staging
                environment = 's';
            }
            else if (baseApiUrl.indexOf('eu1analytics.churnzero.net') >= 0) {
                //production europe / asia
            }
            else { //if (baseApiUrl.indexOf('analytics.churnzero.net') >= 0) {
                //production
            }
            return environment;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Prepend a path with the CDN host
     * If url is a fully url no change made.
     * @param url
     * @returns string
     */
    ApplicationService.prototype.addCdn = function (url) {
        //if empty, no change
        if (url.length === 0) {
            return url;
        }
        //if already url, no change
        if (url.substring(0, 5) === 'http:' || url.substring(0, 6) === 'https:' || url.substring(0, 3) === '//:') {
            return url;
        }
        if (!this.windowSvc.clientSideUrls.baseApiUrl) {
            throw new Error('Urls Cache must be built before adding cdn');
        }
        return this.windowSvc.cdnUrl + url;
    };
    //Add a listener for messages coming from devless frame
    ApplicationService.prototype.addChildFrameListener = function () {
        var _this = this;
        if (this.isChildFrameListenerAttached)
            return;
        var devlessOrigin = this.WebAppDomain;
        devlessOrigin = devlessOrigin.substr(0, devlessOrigin.length - 1);
        var unwind = clientlibs_1.iFrameUtils.attachTransportMessageListener(this.windowSvc.window, devlessOrigin, function (transportMessage, e) {
            switch (transportMessage.code) {
                case clientlibs_1.TransportCodes.PubSubMirror:
                    _this.pubsub.publishMirrored(transportMessage.data);
                    break;
            }
        }, this.windowSvc.JSON);
        this.removeChildFrameListener = function () {
            if (_this.windowSvc.window.removeEventListener) {
                _this.windowSvc.window.removeEventListener('message', unwind, false);
            }
            _this.isChildFrameListenerAttached = false;
            _this.removeChildFrameListener = undefined;
        };
        this.isChildFrameListenerAttached = true;
    };
    ApplicationService.prototype.addFrameComListener = function () {
        var _this = this;
        if (this.isFrameComListenerAttached)
            return;
        var origins = this.windowSvc.origins.join(',');
        var unwind = clientlibs_1.iFrameUtils.attachTransportMessageListener(this.windowSvc.window, origins, function (transportMessage, e) {
            if (transportMessage.code !== clientlibs_1.TransportCodes.FrameComm) {
                return;
            }
            var message = transportMessage.data;
            try {
                _this.handleFrameComMessage(message, e);
            }
            catch (ex) {
                //meh
                //ErrorLogger.report("applicationService.addFrameComListener.handleFrameComMessage", ex, "message.code:" + (message.code || "message.code is falsy").toString());
            }
        }, this.windowSvc.JSON, function (ex, e) {
            errorLogger_1.default.report('iFrameUtils.attachTransportMessageListener at application.service.ts', ex, (e.data || 'e.data is falsy').toString());
        });
        this.removeFrameComListener = function () {
            if (_this.windowSvc.window.removeEventListener) {
                _this.windowSvc.window.removeEventListener('message', unwind, false);
            }
            _this.isFrameComListenerAttached = false;
            _this.removeFrameComListener = undefined;
        };
        this.isFrameComListenerAttached = true;
    };
    ApplicationService.prototype.messageMain = function (data) {
        //guard
        if (!this.mainFrame) {
            return;
        }
        this.sendFrameCom(this.mainFrame, data);
    };
    ApplicationService.prototype.messageSubFrames = function (data) {
        //guard
        if (!this.registeredSubFrames) {
            return;
        }
        var keysToDelete = [];
        for (var key in this._registeredSubframes) {
            if (clientlibs_1.CoreUtils.hasOwnProp(this._registeredSubframes, key)) {
                var windowRegistration = this._registeredSubframes[key];
                if (windowRegistration && windowRegistration.window) {
                    this.sendFrameCom(windowRegistration, data);
                }
                else {
                    keysToDelete.push(key);
                }
            }
        }
        for (var i = 0; i < keysToDelete.length; i++) {
            try {
                var key = keysToDelete[i];
                if (key && clientlibs_1.CoreUtils.hasOwnProp(this._registeredSubframes, key)) {
                    this._registeredSubframes[key] = undefined;
                    delete this._registeredSubframes[key];
                }
            }
            catch (ex) {
                //meh
            }
        }
    };
    ApplicationService.prototype.sendFrameCom = function (target, data) {
        var message = clientlibs_1.iFrameUtils.buildTransportMessage(clientlibs_1.TransportCodes.FrameComm, data);
        //guard
        if (!target || !target.window) {
            return;
        }
        //this.debug('Sending to the following origins', target.origin);
        try {
            target.window.postMessage(clientlibs_1.iFrameUtils.encrypt(this.windowSvc.JSON.stringify(message)), target.origin);
        }
        catch (ex) {
            //ErrorLogger.report("applicationService.sendFrameCom", ex, "frameComCode:"+ data.code);
        }
    };
    ApplicationService.prototype.handleFrameComMessage = function (message, e) {
        //main frame listens for sub-frames to boot and then registers them
        if (message.code === Enums_1.Enums.FrameCommCodes.SubframeBoot) {
            if (this.isMain) {
                this.registerSubFrame(e.source, e.origin, message.data);
            }
            return;
        }
        //subframe listens for responses from its boot announcement
        if (message.code === Enums_1.Enums.FrameCommCodes.SubframeBootResponse) {
            if (!this.isMain) {
                this.mainFrame = { window: e.source, origin: e.origin };
                message.data.source = e.source;
                this.pubsub.publish(Enums_1.Enums.FrameCommCodes.SubframeBootResponse, message.data);
            }
            return;
        }
        if (this.isMain) {
            //if the main receives a message that isn't from a registered source reject it
            var registered = false;
            for (var key in this.registeredSubFrames) {
                if (!registered && clientlibs_1.CoreUtils.hasOwnProp(this.registeredSubFrames, key)) {
                    if (this.registeredSubFrames[key].window === e.source) {
                        registered = true;
                    }
                }
            }
            if (!registered) {
                console.log('Message from unregistered subframe.');
                return;
            }
        }
        else {
            //verify from main
            if (!this.mainFrame || this.mainFrame.window !== e.source) {
                console.log('Message from source other than main');
                return;
            }
        }
        //only handle known codes
        switch (message.code) {
            case Enums_1.Enums.FrameCommCodes.MainFrameComRePublish:
            case Enums_1.Enums.FrameCommCodes.MainFramePassdown:
                if (!this.isMain) {
                    this.pubsub.publish(message.code, message.data);
                }
                break;
            case Enums_1.Enums.FrameCommCodes.SubFramePassback:
                if (this.isMain) {
                    this.pubsub.publish(message.code, message.data);
                }
                break;
        }
    };
    Object.defineProperty(ApplicationService.prototype, "isSelfHosted", {
        get: function () {
            return this._isSelfHosted.trim().toLowerCase() === 'true';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ApplicationService.prototype, "isDebugging", {
        //**********************//
        // Debugging
        //**********************//
        get: function () {
            return this.storageSvc.get(ApplicationService.storageKeys.IsDebugging, false);
        },
        set: function (value) {
            if (value) {
                this.storageSvc.set(ApplicationService.storageKeys.IsDebugging, value);
            }
            else {
                this.storageSvc.remove(ApplicationService.storageKeys.IsDebugging);
            }
        },
        enumerable: false,
        configurable: true
    });
    ApplicationService.prototype.debug = function (item) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (!this.isDebugging) {
            return;
        }
        //let message = ["%c", item].concat(args || []).join(" ");
        //let infoArray = [message, "color:blue;"];
        var infoArray = [item].concat(args || []);
        if (!this.isMain && infoArray.length > 0) {
            infoArray[0] = '**Sub** - ' + infoArray[0];
        }
        /* eslint-disable-next-line */
        this.windowSvc.window['console']['info'].apply(this.windowSvc.window['console'], infoArray);
    };
    Object.defineProperty(ApplicationService.prototype, "WebAppDomain", {
        get: function () {
            return this.webAppDomain;
        },
        set: function (value) {
            this.webAppDomain = value;
        },
        enumerable: false,
        configurable: true
    });
    //Statics
    ApplicationService.storageKeys = {
        AdminPanelState: 'ADMIN_PANEL__STATE',
        IsDebugging: 'IS_DEBUGGING'
    };
    return ApplicationService;
}());
exports["default"] = ApplicationService;


/***/ }),

/***/ "./src/services/attribute.service.ts":
/*!*******************************************!*\
  !*** ./src/services/attribute.service.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var Enums_1 = __webpack_require__(/*! @src/core/Enums */ "./src/core/Enums.ts");
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var AttributeService = /** @class */ (function () {
    //Privates
    function AttributeService(commSvc, sessionSvc) {
        this.commSvc = commSvc;
        this.sessionSvc = sessionSvc;
    }
    AttributeService.prototype.SetAttribute = function (entity, name, value) {
        this.executeAttribute('setAttribute', entity, name, value);
    };
    AttributeService.prototype.IncrementAttribute = function (entity, name, value) {
        this.executeAttribute('incrementAttribute', entity, name, value);
    };
    AttributeService.prototype.executeAttribute = function (action, entity, name, value) {
        var attributeItem = {
            action: action,
            entity: entity,
            attributes: null
        };
        if (value == null && clientlibs_1.CoreUtils.isObject(name)) {
            //name = {name: value, name:value}
            attributeItem.attributes = name;
        }
        else if (clientlibs_1.CoreUtils.isString(name) && name.trim().substr(0, 1) !== '{') {
            //name = string, value = any
            attributeItem.attributes = {};
            attributeItem.attributes[name] = value;
        }
        else {
            try {
                name = JSON.parse(name);
                attributeItem.attributes = name;
            }
            catch (ex) {
                //meh, validation will handle barking
            }
        }
        if (!this.validateAttributeItem(attributeItem)) {
            return;
        }
        //dont send attributes for when the devless panel is open
        if (this.sessionSvc.ShouldPreventUsageSends) {
            return;
        }
        this.commSvc.send(Enums_1.Enums.SocketMessageTypes.SOCKETMESSAGETYPE_SET_ATTRIBUTE, attributeItem);
    };
    AttributeService.prototype.validateAttributeItem = function (attributeItem) {
        var c = window['console'], isValid = true;
        if (typeof attributeItem.action === 'undefined' || attributeItem.action === null || attributeItem.action.toString().length === 0) {
            c.warn('Action parameter must be defined. Attribute ignored.');
            isValid = false;
        }
        if (typeof attributeItem.entity === 'undefined' || attributeItem.entity === null || attributeItem.entity.toString().length === 0 || (attributeItem.entity.toLowerCase() !== 'contact' && attributeItem.entity.toLowerCase() !== 'account')) {
            c.warn('Entity value must be either \'contact\' or \'account\'. Attribute ignored.');
            isValid = false;
        }
        if (typeof attributeItem.attributes === 'undefined' || attributeItem.attributes === null || clientlibs_1.CoreUtils.numKeys(attributeItem.attributes) === 0) {
            c.warn('Name parameter must be defined. Attribute ignored.');
            isValid = false;
        }
        if (typeof attributeItem.attributes !== 'undefined' && attributeItem.attributes !== null && clientlibs_1.CoreUtils.numKeys(attributeItem.attributes) > 0) {
            for (var k in attributeItem.attributes) {
                if (attributeItem.attributes.hasOwnProperty(k) && k.trim().length === 0) {
                    c.warn('Name parameter must be defined for each attribute. Attributes ignored.');
                    isValid = false;
                    break;
                }
            }
        }
        return isValid;
    };
    return AttributeService;
}());
exports["default"] = AttributeService;


/***/ }),

/***/ "./src/services/checklist.service.ts":
/*!*******************************************!*\
  !*** ./src/services/checklist.service.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChecklistService = void 0;
// Libs
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var ChecklistService = /** @class */ (function () {
    function ChecklistService(windowSvc, commSvc) {
        this.windowSvc = windowSvc;
        this.commSvc = commSvc;
        this.lastChecklistPing = -1;
        this.pingInterval = 30000; // 30 seconds
    }
    ChecklistService.prototype.SeedData = function (config) {
        this.clConfig = __assign({}, config);
    };
    ChecklistService.prototype.getChecklistConfig = function () {
        return this.clConfig || null;
    };
    ChecklistService.prototype.checkForUpdatedConfig = function () {
        if (+this.windowSvc.Date.now() - +this.lastChecklistPing <= this.pingInterval)
            return;
        this.lastChecklistPing = this.windowSvc.Date.now();
        var version = (this.clConfig || {}).version;
        this.commSvc.send(clientlibs_1.SocketMessageTypes.SOCKETMESSAGETYPE_CheckChecklistConfigVersion, { version: version });
    };
    ChecklistService.prototype.toggleItem = function (messageContent) {
        this.commSvc.send(clientlibs_1.SocketMessageTypes.SOCKETMESSAGETYPE_ChecklistItemToggle, messageContent, true);
    };
    ChecklistService.prototype.markChecklistComplete = function (messageContent) {
        this.commSvc.send(clientlibs_1.SocketMessageTypes.SOCKETMESSAGETYPE_ChecklistMarkComplete, messageContent, true);
    };
    ChecklistService.prototype.mapChecklistBrandingToProperFormat = function (checklist) {
        if (!checklist) {
            checklist = {};
        }
        /*
                titleFontSize?: string;
                itemFontSize?: string;
                fontFamily?: string;
                textAlignment?: string;
                color?: string;
                hyperlinkColor?: string;
                backgroundColor?: string;
                markAsCompleteBackgroundColor?: string;
                markAsCompleteTextColor?: string;
                completeButtonBackgroundColor?: string;
                completeButtonTextColor?: string;
                completeMessageBackgroundColor?: string;
                completeMessageTextColor?: string;

                all?:{
                    fontFamily?:string,
                    textAlignment?:string,
                    color?:string,
                    backgroundColor?: string
                },
                links?:{
                    color?:string
                },
                title?:{
                    fontSize?:string
                },
                item?:{
                    fontSize:string
                },
                markAsComplete?:{
                    backgroundColor?: string,
                    color?:string
                }
                completeButton?:{
                    backgroundColor?: string,
                    color?:string
                }
                completeMessage?:{
                    backgroundColor?: string,
                    color?:string
                }

             */
        var convertToJustifyAlignment = function (alignment) {
            if (!alignment) {
                return undefined;
            }
            switch (alignment) {
                case 'left':
                    return 'flex-start';
                case 'right':
                    return 'flex-end';
            }
            return alignment;
        };
        var tfs = (checklist.titleFontSize || '').toString().trim(), ifs = (checklist.itemFontSize || '').toString().trim();
        if (tfs.length > 0 && tfs.indexOf('px') === -1)
            tfs += 'px';
        if (ifs.length > 0 && ifs.indexOf('px') === -1)
            ifs += 'px';
        var formatted = {
            all: {
                textAlign: checklist.textAlignment,
                color: checklist.color,
                backgroundColor: checklist.backgroundColor
            },
            links: {
                color: checklist.hyperlinkColor
            },
            title: {
                fontSize: tfs,
                justifyContent: convertToJustifyAlignment(checklist.textAlignment)
            },
            milestoneHeader: {
                fontSize: ifs,
                justifyContent: convertToJustifyAlignment(checklist.textAlignment)
            },
            item: {
                fontSize: ifs,
                justifyContent: convertToJustifyAlignment(checklist.textAlignment)
            },
            markAsComplete: {
                backgroundColor: checklist.markAsCompleteBackgroundColor,
                color: checklist.markAsCompleteTextColor,
                justifyContent: convertToJustifyAlignment(checklist.textAlignment)
            },
            completeButton: {
                backgroundColor: checklist.completeButtonBackgroundColor,
                color: checklist.completeButtonTextColor
            },
            completeMessage: {
                backgroundColor: checklist.completeMessageBackgroundColor,
                color: checklist.completeMessageTextColor,
                justifyContent: convertToJustifyAlignment(checklist.textAlignment)
            }
        };
        return formatted;
    };
    ChecklistService.prototype.buildStyleRulesFromCheckListStyleBranding = function (branding) {
        var _a, _b, _c, _d;
        var checklistItemSelectors = {
            all: '.cz-journey-checklist',
            title: '.cz-journey-checklist-header',
            milestoneHeader: '.cz-journey-checklist-milestone-heading-btn',
            item: '.cz-journey-checklist-item-label',
            links: 'a.cz-journey-checklist-item-text',
            markAsComplete: '.cz-journey-checklist-complete-banner',
            completeButton: '.cz-journey-checklist-complete-banner button',
            completeMessage: '.cz-journey-checklist-complete-banner.is-complete'
        };
        var cssRules = '';
        //ensure the milestone heading carrots are the same color as the rest of the text
        if ((_a = branding.all) === null || _a === void 0 ? void 0 : _a.color) {
            cssRules += clientlibs_1.StyleUtils.wrapInRule('.cz-journey-checklist-milestone-heading-caret.caret-down', clientlibs_1.StyleUtils.mapBrandingItemToCSSProps({ borderTopColor: branding.all.color }));
            cssRules += clientlibs_1.StyleUtils.wrapInRule('.cz-journey-checklist-milestone-heading-caret.caret-left', clientlibs_1.StyleUtils.mapBrandingItemToCSSProps({ borderRightColor: branding.all.color }));
        }
        //account for justifyContent items
        if ((_b = branding.title) === null || _b === void 0 ? void 0 : _b.justifyContent) {
            var justifyContent = branding.title.justifyContent;
            cssRules += clientlibs_1.StyleUtils.wrapInRule('.cz-journey-checklist-header-wrapper', clientlibs_1.StyleUtils.mapBrandingItemToCSSProps({ justifyContent: justifyContent }));
            branding.title.justifyContent = undefined;
        }
        if ((_c = branding.markAsComplete) === null || _c === void 0 ? void 0 : _c.justifyContent) {
            var justifyContent = branding.markAsComplete.justifyContent;
            cssRules += clientlibs_1.StyleUtils.wrapInRule('.mark-as-complete', clientlibs_1.StyleUtils.mapBrandingItemToCSSProps({ justifyContent: justifyContent }));
            branding.markAsComplete.justifyContent = undefined;
        }
        if ((_d = branding.completeMessage) === null || _d === void 0 ? void 0 : _d.justifyContent) {
            var justifyContent = branding.completeMessage.justifyContent;
            cssRules += clientlibs_1.StyleUtils.wrapInRule('.completed-text', clientlibs_1.StyleUtils.mapBrandingItemToCSSProps({ justifyContent: justifyContent }));
            branding.completeMessage.justifyContent = undefined;
        }
        for (var k in checklistItemSelectors) {
            if (clientlibs_1.CoreUtils.hasOwnProp(checklistItemSelectors, k) && clientlibs_1.CoreUtils.hasOwnProp(branding, k)) {
                var styles = clientlibs_1.StyleUtils.mapBrandingItemToCSSProps(branding[k]);
                cssRules += clientlibs_1.StyleUtils.wrapInRule(checklistItemSelectors[k], styles);
            }
        }
        return cssRules;
    };
    ChecklistService.prototype.getPositionalClassNameFromConfig = function (config) {
        switch (config.launchIconPosition) {
            case clientlibs_1.LaunchIconPosition.TopCenter:
                return 'pos-top-center';
            case clientlibs_1.LaunchIconPosition.TopRight:
                return 'pos-top-right';
            case clientlibs_1.LaunchIconPosition.LeftCenter:
                return 'pos-left-center';
            case clientlibs_1.LaunchIconPosition.RightCenter:
                return 'pos-right-center';
            case clientlibs_1.LaunchIconPosition.BottomLeft:
                return 'pos-bottom-left';
            case clientlibs_1.LaunchIconPosition.BottomCenter:
                return 'pos-bottom-center';
            case clientlibs_1.LaunchIconPosition.BottomRight:
                return 'pos-bottom-right';
            default:
                return 'pos-top-left';
        }
    };
    ChecklistService.DOM_PREFIX = 'cz-journey-checklist';
    return ChecklistService;
}());
exports.ChecklistService = ChecklistService;


/***/ }),

/***/ "./src/services/communication.service.ts":
/*!***********************************************!*\
  !*** ./src/services/communication.service.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var CommunicationService = /** @class */ (function () {
    function CommunicationService(commRepo) {
        this.commRepo = commRepo;
    }
    Object.defineProperty(CommunicationService.prototype, "appVersion", {
        get: function () {
            return this.commRepo.appVersion;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CommunicationService.prototype, "appKey", {
        //appKey
        get: function () {
            return this.commRepo.appKey;
        },
        set: function (newValue) {
            this.commRepo.appKey = newValue;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CommunicationService.prototype, "appHost", {
        //appHost
        get: function () {
            if (this.urlTracking) {
                return this.commRepo.appHost;
            }
            else {
                return 'Url Tracking Disabled';
            }
        },
        set: function (newValue) {
            this.commRepo.appHost = newValue;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CommunicationService.prototype, "urlTracking", {
        //urlTracking
        get: function () {
            return this.commRepo.urlTracking;
        },
        set: function (enabled) {
            this.commRepo.urlTracking = enabled;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CommunicationService.prototype, "contactKey", {
        //contactKey
        get: function () {
            return this.commRepo.contactKey;
        },
        set: function (newValue) {
            this.commRepo.contactKey = newValue;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CommunicationService.prototype, "accountHash", {
        //accountHash
        get: function () {
            return this.commRepo.accountHash;
        },
        set: function (newValue) {
            this.commRepo.accountHash = newValue;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CommunicationService.prototype, "contactHash", {
        //contactHash
        get: function () {
            return this.commRepo.contactHash;
        },
        set: function (newValue) {
            this.commRepo.contactHash = newValue;
        },
        enumerable: false,
        configurable: true
    });
    CommunicationService.prototype.registerListener = function (eventName, callbackFunction) {
        return this.commRepo.registerListener(eventName, callbackFunction);
    };
    CommunicationService.prototype.registerMirror = function (mirrorFn) {
        return this.commRepo.registerMirror(mirrorFn);
    };
    CommunicationService.prototype.publishMirrored = function (message) {
        this.commRepo.publishMirrored(message);
    };
    CommunicationService.prototype.generateContactKey = function (accountExternalId, contactExternalId) {
        return this.commRepo.generateContactKey(accountExternalId, contactExternalId);
    };
    CommunicationService.prototype.getContactKeyFromCache = function () {
        return this.commRepo.getContactKeyFromCache();
    };
    CommunicationService.prototype.isContactKeyValid = function (keyToValidate) {
        return this.commRepo.isContactKeyValid(keyToValidate);
    };
    CommunicationService.prototype.splitContactKey = function (keyToSplit) {
        return this.commRepo.splitContactKey(keyToSplit);
    };
    CommunicationService.prototype.isAppKeyValid = function (keyToValidate) {
        return this.commRepo.isAppKeyValid(keyToValidate);
    };
    CommunicationService.prototype.send = function (socketMessageTypeId, messageData, forcePoll) {
        try {
            this.commRepo.send(socketMessageTypeId, messageData, forcePoll);
        }
        catch (ex) {
            console.warn('Send Failed.', socketMessageTypeId, messageData, ex);
        }
    };
    CommunicationService.prototype.flush = function () {
        this.commRepo.flush();
    };
    CommunicationService.prototype.isConnected = function () {
        return this.commRepo.IsConnected;
    };
    CommunicationService.prototype.connect = function (apiUrl, onConnectCallback, onConnectStatusCallback, onFailureCallback) {
        this.commRepo.connect(apiUrl, onConnectCallback, onConnectStatusCallback, onFailureCallback);
    };
    CommunicationService.prototype.setPollInterval = function (pollInterval) {
        this.commRepo.setPollInterval(pollInterval);
    };
    CommunicationService.prototype.resetPollIntervalToDefault = function () {
        this.commRepo.resetPollIntervalToDefault();
    };
    CommunicationService.prototype.clearAllListeners = function () {
        this.commRepo.clearAllListeners();
    };
    CommunicationService.prototype.disconnect = function () {
        this.commRepo.disconnect();
    };
    CommunicationService.prototype.reset = function () {
        this.commRepo.reset();
    };
    CommunicationService.prototype.destroy = function () {
        this.commRepo.destroy();
    };
    return CommunicationService;
}());
exports["default"] = CommunicationService;


/***/ }),

/***/ "./src/services/event.service.ts":
/*!***************************************!*\
  !*** ./src/services/event.service.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var Enums_1 = __webpack_require__(/*! @src/core/Enums */ "./src/core/Enums.ts");
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var EventService = /** @class */ (function () {
    function EventService(commSvc, windowSvc, applicationSvc, sessionSvc) {
        //Privates
        this.commSvc = commSvc;
        this.windowSvc = windowSvc;
        this.applicationSvc = applicationSvc;
        this.sessionSvc = sessionSvc;
        this.lastEventMapPing = null;
        this.pingInterval = 60 * 1000;
        this._eventMapConfig = { eventMaps: [], eventMapVersion: '-1' };
    }
    Object.defineProperty(EventService.prototype, "eventMapVersion", {
        get: function () {
            return this._eventMapConfig.eventMapVersion;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EventService.prototype, "eventMaps", {
        get: function () {
            return this._eventMapConfig.eventMaps;
        },
        enumerable: false,
        configurable: true
    });
    //Basic Event Tracking
    EventService.prototype.TrackEvent = function (eventName, description, quantity, customFields) {
        var event = {
            eventDate: new this.windowSvc.Date().toISOString(),
            name: eventName,
            quantity: quantity || 1,
            description: description || '',
            customFields: customFields
        };
        if (!this.ValidateEvent(event)) {
            return;
        }
        //dont send events for when the devless panel is open
        if (this.sessionSvc.ShouldPreventUsageSends) {
            return;
        }
        this.commSvc.send(Enums_1.Enums.SocketMessageTypes.SOCKETMESSAGETYPE_TRACK_EVENT, event);
    };
    EventService.prototype.ValidateEvent = function (event) {
        var c = window['console'], isValid = true;
        if (typeof event.name === 'undefined' || event.name === null || event.name.toString().length === 0) {
            c.warn('Track Event EventName is required. Event ignored.');
            isValid = false;
        }
        if (typeof event.quantity !== 'undefined' && (Array.isArray(event.quantity) || !clientlibs_1.CoreUtils.Numbers.isNumeric(event.quantity))) {
            c.warn('Track Event Quantity field is restricted to numeric values only. Any non-numeric values will be ignored.');
            event.quantity = 1;
        }
        return isValid;
    };
    EventService.prototype.Exp_TrackEvent = function (eventName, description, quantity) {
        var detailsArray = eventName;
        if (typeof detailsArray === 'string') {
            detailsArray = [eventName, description, quantity];
        }
        console.log('Event Tracked : ', detailsArray);
    };
    //Event Maps
    EventService.prototype.RefreshEventMapConfig = function (force) {
        //let the main frame worry about refreshes
        if (!this.applicationSvc.isMain) {
            return;
        }
        // every 60 seconds
        //check for an updated eventmap
        if (+this.windowSvc.Date.now() - +this.lastEventMapPing > this.pingInterval || force) {
            this.lastEventMapPing = this.windowSvc.Date.now();
            this.commSvc.send(Enums_1.Enums.SocketMessageTypes.SOCKETMESSAGETYPE_CHECK_EVENT_MAP_CONFIG_VERSION, { version: this.eventMapVersion });
        }
    };
    EventService.prototype.LoadEventMapConfig = function (eventMapConfig) {
        if (eventMapConfig) {
            this._eventMapConfig = eventMapConfig;
        }
    };
    EventService.prototype.AddEventMaps = function (EventMaps, ResetFirst) {
        if (ResetFirst) {
            this._eventMapConfig.eventMaps = [];
        }
        this._eventMapConfig.eventMaps = this._eventMapConfig.eventMaps.concat(EventMaps);
    };
    EventService.prototype.RelevantMappedEvents = function () {
        if (typeof this._eventMapConfig.eventMaps === 'undefined') {
            this._eventMapConfig.eventMaps = [];
        }
        var allEvents = this.eventMaps.filter(function (e) {
            return !e.disabled;
        }), suggestedEvents = this.eventMaps.filter(function (e) {
            return e.selectorTypeId === Enums_1.Enums.SelectorTypes.Suggested && !e.disabled;
        }), customEvents = this.eventMaps.filter(function (e) {
            return e.selectorTypeId === Enums_1.Enums.SelectorTypes.Custom && !e.disabled;
        });
        return {
            all: allEvents,
            suggested: suggestedEvents,
            custom: customEvents
        };
    };
    return EventService;
}());
exports["default"] = EventService;


/***/ }),

/***/ "./src/services/http.service.ts":
/*!**************************************!*\
  !*** ./src/services/http.service.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var HttpService = /** @class */ (function () {
    function HttpService(coder, XMLHttpRequestRef) {
        if (coder) {
            this.encode = coder.encode;
            this.decode = coder.decode;
        }
        else {
            this.encode = JSON.stringify;
            this.decode = JSON.parse;
        }
        this.XMLHttpRequestFactory = function () {
            if (!XMLHttpRequestRef) {
                return new XMLHttpRequest();
            }
            if (typeof XMLHttpRequestRef === 'function') {
                return new (XMLHttpRequestRef())();
            }
            return new (XMLHttpRequestRef)();
            //return new (XMLHttpRequestRef||XMLHttpRequest)();
        };
    }
    HttpService.prototype.Get = function (url, successCallback, failureCallback) {
        return this.http('GET', url, null, false, successCallback, failureCallback);
    };
    HttpService.prototype.Post = function (url, postObject, withCredentials, successCallback, failureCallback) {
        return this.http('POST', url, postObject, withCredentials, successCallback, failureCallback);
    };
    HttpService.prototype.http = function (method, url, postObject, withCredentials, successCallback, failureCallback) {
        var _this = this;
        var xhr = undefined;
        try {
            xhr = this.XMLHttpRequestFactory();
        }
        catch (e) {
            //meh
            console.warn('XHR failure');
        }
        if (!xhr) {
            if (failureCallback) {
                failureCallback('XHR Unavailable Failed', postObject);
            }
            return null;
        }
        xhr.onload = function () {
            if (xhr.status === 200 || xhr.status === 204) {
                if (successCallback) {
                    var response = xhr.responseText;
                    if (response.substring(0, 1) === '{' || response.substring(0, 1) === '[') {
                        response = _this.decode(response);
                    }
                    return successCallback(response);
                }
            }
            else {
                console.warn('Request Failed (' + xhr.status + ') [' + url + ']:' + xhr.responseText);
                if (failureCallback) {
                    failureCallback(xhr.responseText, postObject);
                }
            }
        };
        xhr.onabort = function () {
            console.warn('Request Aborted[' + url + ']:' + xhr.responseText);
            if (failureCallback) {
                failureCallback('Request Aborted', postObject);
            }
        };
        xhr.onerror = function () {
            console.warn('Request Failed (onerror) [' + url + ']:' + xhr.responseText);
            if (failureCallback) {
                failureCallback('Request Failed', postObject);
            }
        };
        var formData = null;
        if (postObject) {
            formData = '=' + encodeURIComponent(this.encode(postObject));
        }
        try {
            xhr.open(method, url);
            xhr.withCredentials = withCredentials;
            // Have to use www-form-urlencoded otherwise CORS requires two requests (OPTIONS, method)
            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
            if (formData) {
                xhr.send(formData);
            }
            else {
                xhr.send();
            }
        }
        catch (ex) {
            if (failureCallback) {
                failureCallback('Request Failed', postObject);
            }
        }
        return xhr;
    };
    return HttpService;
}());
exports["default"] = HttpService;


/***/ }),

/***/ "./src/services/message.service.ts":
/*!*****************************************!*\
  !*** ./src/services/message.service.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var Enums_1 = __webpack_require__(/*! @src/core/Enums */ "./src/core/Enums.ts");
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var MessageService = /** @class */ (function () {
    function MessageService(commSvc, windowSvc, storageService) {
        this.commSvc = commSvc;
        this.windowSvc = windowSvc;
        this.storageService = storageService;
        //Privates
        this._announcements = [];
    }
    Object.defineProperty(MessageService.prototype, "Announcements", {
        get: function () {
            return this._announcements;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MessageService.prototype, "SeenAnnouncementIdsKey", {
        get: function () {
            return "SeenAnnouncementIds-" + this.commSvc.appKey + "-" + this.commSvc.contactKey;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MessageService.prototype, "SeenAnnouncementIds", {
        get: function () {
            try {
                return this.storageService.get(this.SeenAnnouncementIdsKey, []);
            }
            catch (ex) {
                return [];
            }
        },
        set: function (value) {
            this.storageService.set(this.SeenAnnouncementIdsKey, value);
        },
        enumerable: false,
        configurable: true
    });
    MessageService.prototype.SeedAnnouncements = function (baseAnnouncements) {
        //reset announcements
        this._announcements = [];
        //process each seeded announcement
        for (var i = 0; i < baseAnnouncements.length; i++) {
            var processedAnnouncement = this.processAnnouncement(baseAnnouncements[i]);
            if (processedAnnouncement) {
                //store the announcement
                this._announcements.push(processedAnnouncement);
            }
        }
        //this._announcements = baseAnnouncements;
    };
    MessageService.prototype.SendReadReceipt = function (messageId) {
        if (messageId > 0) {
            for (var i = 0; i < this.Announcements.length; i++) {
                if (this.Announcements[i] && this.Announcements[i].id === messageId) {
                    if (!this.Announcements[i].isRead) {
                        console.info('marking message as read');
                        this.Announcements[i].isRead = true;
                        this.SeenAnnouncementIds = this.SeenAnnouncementIds.concat([messageId]);
                        this.commSvc.send(Enums_1.Enums.SocketMessageTypes.SOCKETMESSAGETYPE_MESSAGE_READ, messageId, true);
                    }
                }
            }
        }
    };
    MessageService.prototype.SendClickAudit = function (messageId) {
        if (messageId > 0) {
            this.commSvc.send(Enums_1.Enums.SocketMessageTypes.SOCKETMESSAGETYPE_MESSAGE_CLICKED, messageId);
        }
    };
    MessageService.prototype.SanitizeAnnouncements = function () {
        this._announcements = this.Announcements.filter(function (n) {
            return n !== undefined && n !== null;
        });
    };
    //Entry point for Announcements workflow
    MessageService.prototype.AddNewAnnouncement = function (message) {
        var processedAnnouncement = this.processAnnouncement(message);
        if (processedAnnouncement) {
            this._announcements.push(processedAnnouncement);
        }
        return processedAnnouncement;
    };
    MessageService.prototype.ExpireAnnouncement = function (message) {
        for (var i = 0; i < this._announcements.length; i++) {
            var msg = this._announcements[i];
            if (msg.messageKey === message.messageKey) {
                //merge the old announcement object with what is passed from the server
                // the digest cycle will handle refreshing the UI
                this._announcements[i] = clientlibs_1.CoreUtils.extend({}, msg, message);
            }
        }
    };
    MessageService.prototype.GetAnnouncementFromAnnouncementHtml = function (container) {
        var announcementId = (container.getAttribute('data-message-id') || '-1').toString();
        var socketAnnouncement;
        this.Announcements.filter(function (sa) {
            if (sa.id.toString() === announcementId) {
                socketAnnouncement = sa;
            }
        });
        return socketAnnouncement;
    };
    /**
     * Ensure an announcement is only added once and set the UI properties like sequence and deliveryDate
     * @param announcement
     */
    MessageService.prototype.processAnnouncement = function (announcement) {
        //ensure announcements only get added once
        var alreadyExists = false;
        for (var i = 0; i < this._announcements.length; i++) {
            if (announcement.messageKey === this._announcements[i].messageKey) {
                announcement.isRead = this._announcements[i].isRead;
                alreadyExists = true;
            }
        }
        if (alreadyExists) {
            return;
        }
        announcement.sequence = this._announcements.length + 1;
        announcement.deliveryDate = new this.windowSvc.Date(announcement.deliveryDate);
        announcement.at = clientlibs_1.CoreUtils.Dates.formatWithSlashes(announcement.deliveryDate);
        announcement.time = clientlibs_1.CoreUtils.Times.formatWithAMPM(announcement.deliveryDate);
        announcement.announcementIncludeInPanelString = (announcement.announcementIncludeInPanel).toString();
        announcement.showInfoMessageString = (announcement.announcementIncludeInPanel).toString();
        if (this.SeenAnnouncementIds.indexOf(announcement.id) !== -1) {
            announcement.isRead = true;
        }
        this.normalizeMessageData(announcement);
        //never show info message for NPS
        if (this.isSurveyAnnouncement(announcement)) {
            announcement.showInfoMessageString = 'false';
        }
        return announcement;
    };
    //Should announcement be added to static announcements
    MessageService.prototype.isPanelAnnouncement = function (announcement) {
        return announcement.announcementIncludeInPanel;
    };
    MessageService.prototype.isSurveyAnnouncement = function (announcement) {
        var announcementType = this.getAnnouncementType(announcement);
        return announcementType === clientlibs_1.AnnouncementType.Nps || announcementType === clientlibs_1.AnnouncementType.CustomSurvey;
    };
    MessageService.prototype.isPopupAnnouncement = function (announcement) {
        return (announcement.announcementPositionId && announcement.announcementPositionId === Enums_1.Enums.AnnouncementPosition.PopUp);
    };
    MessageService.prototype.isSliderAnnouncement = function (announcement) {
        return (announcement.announcementPositionId && announcement.announcementPositionId > Enums_1.Enums.AnnouncementPosition.PopUp);
    };
    /**
     * Parse announcement type string value into enum. A little more involved than Enums.AnnouncementType['value'] since
     * it needs to be case insensitive
     */
    MessageService.prototype.getAnnouncementType = function (announcement) {
        if (!announcement.messageData) {
            return clientlibs_1.AnnouncementType.Basic;
        }
        // We are using filter instead of find here, because...IE :(
        var enumString = announcement.messageData.Type || announcement.messageData.type;
        var matchingKeys = Object.keys(clientlibs_1.AnnouncementType).filter(function (key) { return key.toString().toLowerCase() === (enumString || '').toLowerCase(); });
        if (matchingKeys.length > 0) {
            var enumKey = matchingKeys[0];
            return clientlibs_1.AnnouncementType[enumKey];
        }
        return undefined;
    };
    MessageService.prototype.normalizeMessageData = function (announcement) {
        if (!announcement.messageData) {
            return;
        }
        Object.keys(announcement.messageData).forEach(function (key) {
            var initial = key[0];
            if (initial === initial.toUpperCase()) {
                announcement.messageData[key[0].toLowerCase() + key.substr(1)] = announcement.messageData[key];
            }
        });
    };
    MessageService.prototype.isAdvancedDisplayAnnouncement = function (announcement) {
        return (this.isPopupAnnouncement(announcement) || this.isSliderAnnouncement(announcement));
    };
    MessageService.prototype.getAnnouncementPositionClassFromId = function (announcementPositionId) {
        switch (announcementPositionId) {
            case Enums_1.Enums.AnnouncementPosition.SlideBottomCenter:
                return 'bottom-center';
            case Enums_1.Enums.AnnouncementPosition.SlideLeftBottom:
                return 'left-bottom';
            case Enums_1.Enums.AnnouncementPosition.SlideTopLeft:
                return 'top-left';
            case Enums_1.Enums.AnnouncementPosition.SlideTopCenter:
                return 'top-center';
            case Enums_1.Enums.AnnouncementPosition.SlideTopRight:
                return 'top-right';
            case Enums_1.Enums.AnnouncementPosition.SlideBottomLeft:
                return 'bottom-left';
            case Enums_1.Enums.AnnouncementPosition.SlideBottomRight:
                return 'bottom-right';
            case Enums_1.Enums.AnnouncementPosition.SlideLeftTop:
                return 'left-top';
            case Enums_1.Enums.AnnouncementPosition.SlideLeftCenter:
                return 'left-center';
            case Enums_1.Enums.AnnouncementPosition.SlideRightTop:
                return 'right-top';
            case Enums_1.Enums.AnnouncementPosition.SlideRightCenter:
                return 'right-center';
            case Enums_1.Enums.AnnouncementPosition.SlideRightBottom:
                return 'right-bottom';
            default:
                console.error("Unknown AnnouncementPositionId " + announcementPositionId);
                return 'bottom-center';
        }
    };
    return MessageService;
}());
exports["default"] = MessageService;


/***/ }),

/***/ "./src/services/pagetag.service.ts":
/*!*****************************************!*\
  !*** ./src/services/pagetag.service.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var Enums_1 = __webpack_require__(/*! ../core/Enums */ "./src/core/Enums.ts");
var PageTagService = /** @class */ (function () {
    function PageTagService(commSvc, windowSvc, applicationSvc, sessionSvc) {
        this.commSvc = commSvc;
        this.windowSvc = windowSvc;
        this.applicationSvc = applicationSvc;
        this.sessionSvc = sessionSvc;
        this.lastPageTagPing = null;
        this.pingInterval = 60 * 1000;
    }
    Object.defineProperty(PageTagService.prototype, "pageTagVersion", {
        //Page Tags
        get: function () {
            return this._pageTagConfig.pageTagVersion;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PageTagService.prototype, "pageTags", {
        get: function () {
            if (!this._pageTagConfig) {
                return [];
            }
            return this._pageTagConfig.pageTags;
        },
        enumerable: false,
        configurable: true
    });
    PageTagService.prototype.LoadPageTagConfig = function (pageTagConfig) {
        if (!pageTagConfig) {
            return;
        }
        if (pageTagConfig.pageTags) {
            var c = pageTagConfig.pageTags.length;
            for (var i = 0; i < c; i++) {
                var pageTag = pageTagConfig.pageTags[i];
                pageTagConfig.pageTags[i] = clientlibs_1.PageTag.FromObject(pageTag);
            }
        }
        this._pageTagConfig = pageTagConfig;
    };
    PageTagService.prototype.AddPageTags = function (PageTags, ResetFirst) {
        if (ResetFirst) {
            this._pageTagConfig.pageTags = [];
        }
        this._pageTagConfig.pageTags = this._pageTagConfig.pageTags.concat(PageTags);
    };
    PageTagService.prototype.RefreshPageTagConfig = function (force) {
        //let the main frame worry about refreshes
        if (!this.applicationSvc.isMain) {
            return;
        }
        //if there is no pagetag config bail
        if (!this._pageTagConfig) {
            return;
        }
        // every 60 seconds
        //check for an updated pagetag config
        if (+this.windowSvc.Date.now() - +this.lastPageTagPing > this.pingInterval || force) {
            this.lastPageTagPing = this.windowSvc.Date.now();
            this.commSvc.send(Enums_1.Enums.SocketMessageTypes.SOCKETMESSAGETYPE_CheckPageTagConfigVersion, { version: this.pageTagVersion });
        }
    };
    return PageTagService;
}());
exports["default"] = PageTagService;


/***/ }),

/***/ "./src/services/session.service.ts":
/*!*****************************************!*\
  !*** ./src/services/session.service.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var tenant_service_1 = __webpack_require__(/*! @src/services/tenant.service */ "./src/services/tenant.service.ts");
var SessionStorageQueue_1 = __importDefault(__webpack_require__(/*! ../core/SessionStorageQueue */ "./src/core/SessionStorageQueue.ts"));
var clientlibs_2 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var SessionService = /** @class */ (function () {
    function SessionService(storageSvc, commSvc, appSvc, tenantSvc, windowSvc) {
        this.storageSvc = storageSvc;
        this.commSvc = commSvc;
        this.appSvc = appSvc;
        this.tenantSvc = tenantSvc;
        this.windowSvc = windowSvc;
        this.minimumModuleDurationInSeconds = 1; //anything less than this will not be pushed to server
        this.maximumModuleDurationInSeconds = 33; //30 second module block + 2 digest cycle + 1 processing time
        //Privates
        this.heartbeatInterval = SessionService.heartbeatIntervals.active;
        this.functionality = {
            panelEnabled: false,
            alwaysUseLaunchAvatar: false,
            showAccountOwnerSection: false,
            hasAccountOwner: false,
            onlyShowWhenMessagesExist: false,
            //use accountPanelContent Versions
            headerHtml: null,
            footerHtml: null,
            launchAvatarUrl: null
        };
        this.accountContent = {
            defaultAnnouncement: null,
            header: null,
            footer: null,
            launchAvatarUrl: null,
            clickToSeeMoreText: 'Click here to see that info again',
            branding: null,
            css: null,
            announcementStyles: null
        };
        this.lastHeartbeat = null;
        this.moduleActivities = new SessionStorageQueue_1.default(this.storageSvc, this.windowSvc, SessionService.storageKeys.TimeInAppQueueKey);
        this.isSilent = false;
    }
    Object.defineProperty(SessionService.prototype, "currentActivity", {
        get: function () {
            return this.storageSvc.get(SessionService.storageKeys.TimeInAppCurrentKey, null);
        },
        enumerable: false,
        configurable: true
    });
    SessionService.prototype.updateCurrentActivity = function (activity) {
        this.storageSvc.set(SessionService.storageKeys.TimeInAppCurrentKey, activity);
    };
    SessionService.prototype.clearCurrentActivity = function () {
        this.storageSvc.remove(SessionService.storageKeys.TimeInAppCurrentKey);
    };
    SessionService.prototype.SetFunctionality = function (Functionality) {
        this.functionality = Functionality;
    };
    SessionService.prototype.CurrentFunctionality = function () {
        return this.functionality;
    };
    //IsActive
    SessionService.prototype.triggerHeartbeat = function (isMainFrame) {
        if (this.ShouldPreventUsageSends) {
            return;
        }
        // only do heartbeat every 30 seconds
        if (+this.windowSvc.Date.now() - +this.lastHeartbeat > this.heartbeatInterval) {
            this.lastHeartbeat = this.windowSvc.Date.now();
            //ping back that user is active
            //console.info((CoreUtils.FeatureDetection.inIframe() ? "iFrame " : "") + "Client Active Heartbeat");
            var userActiveData = {
                title: this.windowSvc.title(),
                location: this.windowSvc.href()
            };
            this.commSvc.send(clientlibs_1.SocketMessageTypes.SOCKETMESSAGETYPE_IS_ACTIVE, this.commSvc.urlTracking ? userActiveData : null);
            //send any in app time activity
            if (isMainFrame) {
                var moduleActivities = this.popModuleActivities();
                if (moduleActivities && moduleActivities.length > 0) {
                    this.commSvc.send(clientlibs_1.SocketMessageTypes.SOCKETMESSAGETYPE_TIME_IN_APP, moduleActivities);
                }
            }
        }
    };
    SessionService.prototype.changeHeartbeatInterval = function (newInterval) {
        if (this.heartbeatInterval === newInterval) {
            return;
        }
        this.heartbeatInterval = newInterval;
        this.lastHeartbeat = 0;
    };
    Object.defineProperty(SessionService.prototype, "LaunchAvatarUrl", {
        //******************************//
        // Avatar Urls
        //*****************************//
        //Url of image to use for the open panel button
        get: function () {
            var avatarUrl;
            //if the panel is not enabled but there is a devless session use the cz icon
            if (!this.PanelEnabled && this.DevlessPanelEnabled) {
                avatarUrl = 'img/ch0-icon-light-32x32.png';
            }
            //if always use launch avatar or showAccountOwner is disabled
            // use the launchAvatarUrl
            else if (this.AlwaysUseLaunchAvatar || !this.HasAccountOwner || (this.AccountOwnerAvatarUrl || '').length === 0) {
                avatarUrl = this.accountContent.launchAvatarUrl;
            }
            else {
                avatarUrl = this.AccountOwnerAvatarUrl;
            }
            //ultimate fall back!
            if (!avatarUrl) {
                avatarUrl = 'img/info.png';
            }
            return this.appSvc.addCdn(avatarUrl);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SessionService.prototype, "AccountOwnerAvatarUrl", {
        //Url of image to use for the account owner
        get: function () {
            var currentUserAccount = this.tenantSvc.accountOwner;
            if (currentUserAccount && currentUserAccount.avatarUrl) {
                return this.appSvc.addCdn(currentUserAccount.avatarUrl);
            }
            return '';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SessionService.prototype, "PanelEnabled", {
        //******************************//
        // Feature Flags
        //*****************************//
        //Display Panel
        get: function () {
            return this.getBoolFuncFlag('panelEnabled');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SessionService.prototype, "DevlessPanelEnabled", {
        get: function () {
            return this.getBoolFuncFlag('devlessEnabled'); //this.tenantSvc.contact.hasApplicationPanelAdminAccess;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SessionService.prototype, "ShouldPreventUsageSends", {
        //If this is a devless session we dont want to track usage but we want debug logging to still output
        get: function () {
            //return false;
            return this.getBoolFuncFlag('devlessEnabled');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SessionService.prototype, "ShowAccountOwner", {
        //Account Owner Section Enabled
        get: function () {
            return this.getBoolFuncFlag('showAccountOwnerSection');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SessionService.prototype, "AlwaysUseLaunchAvatar", {
        //Always show the Launch avatar for the chat button toggle
        get: function () {
            return this.getBoolFuncFlag('alwaysUseLaunchAvatar');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SessionService.prototype, "HasAccountOwner", {
        //if the current user is assigned to an account owner
        get: function () {
            return this.getBoolFuncFlag('hasAccountOwner');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SessionService.prototype, "OnlyShowWhenMessagesExist", {
        get: function () {
            return this.getBoolFuncFlag('onlyShowWhenMessagesExist');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SessionService.prototype, "PanelPosition", {
        get: function () {
            return this.functionality.panelPosition;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SessionService.prototype, "AvatarType", {
        get: function () {
            return this.functionality.avatarType;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SessionService.prototype, "LaunchIconPositionOffsetVertical", {
        get: function () {
            return this.functionality.launchIconPositionOffsetVertical;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SessionService.prototype, "LaunchIconPositionOffsetHorizontal", {
        get: function () {
            return this.functionality.launchIconPositionOffsetHorizontal;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SessionService.prototype, "LaunchIconPositionId", {
        get: function () {
            return this.functionality.launchIconPositionId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SessionService.prototype, "SuccessCenterEnabled", {
        get: function () {
            var _a;
            return this.tenantSvc.FeatureEnabled(tenant_service_1.ReleaseGates.SuccessCentersReleased) &&
                this.tenantSvc.FeatureEnabled(tenant_service_1.FeatureFlags.SuccessCentersEnabled) &&
                !!((_a = this.successCenterConfig) === null || _a === void 0 ? void 0 : _a.successCenterId);
        },
        enumerable: false,
        configurable: true
    });
    //******************************//
    // Default Content
    //*****************************//
    SessionService.prototype.SetAccountContent = function (Functionality) {
        this.accountContent = {
            defaultAnnouncement: Functionality.defaultAnnouncementContent,
            header: Functionality.headerHtml,
            footer: Functionality.footerHtml,
            launchAvatarUrl: Functionality.launchAvatarUrl,
            css: Functionality.css,
            devlessCss: Functionality === null || Functionality === void 0 ? void 0 : Functionality.devlessCss,
            clickToSeeMoreText: Functionality.clickToSeeMoreText,
            branding: null,
            announcementStyles: new clientlibs_1.AnnouncementStyleConfig()
        };
        //try to merge in the specified branding options
        if (Functionality.branding && Functionality.branding.trim().length > 0) {
            try {
                var brandingJson = this.windowSvc.JSON.parse(Functionality.branding);
                this.accountContent.branding = clientlibs_1.CoreUtils.extend(this.accountContent.branding, brandingJson);
            }
            catch (ex) {
                //eh?
            }
        }
        // Set the announcement styles
        var announcementStyles = this.windowSvc.coder().decode(Functionality.announcementStyles || '{}'), merged = __assign(__assign({}, clientlibs_2.CZ_DEFAULT_ANNOUNCEMENT_STYLE_CONFIG), announcementStyles); // merge our CZ sanity defaults w/ the tenant config item
        this.accountContent.announcementStyles = clientlibs_1.ModelUtils.create(new clientlibs_1.AnnouncementStyleConfig(), merged);
    };
    Object.defineProperty(SessionService.prototype, "CurrentAccountContent", {
        get: function () {
            return this.accountContent;
        },
        enumerable: false,
        configurable: true
    });
    //******************************//
    // Module Activity
    //*****************************//
    SessionService.prototype.SetModule = function (module) {
        //if the new module is the same as the old, short circuit
        if (this.CurrentModule === module && this.currentActivity) {
            return;
        }
        var timeStamp = new this.windowSvc.Date().toISOString();
        if (this.currentActivity) {
            //close out previous
            this.endCurrentActivity(timeStamp);
        }
        this.CurrentModule = module;
        this.startNewActivity(timeStamp);
    };
    //Take the last known module and start a new activity
    SessionService.prototype.SetModuleActivityActive = function () {
        this.SetModule(this.CurrentModule);
        this.changeHeartbeatInterval(SessionService.heartbeatIntervals.active);
    };
    //if there is a current activity, end it
    SessionService.prototype.SetModuleActivityInactive = function () {
        if (this.currentActivity) {
            this.endCurrentActivity(new this.windowSvc.Date().toISOString());
        }
        //this.changeHeartbeatInterval(SessionService.heartbeatIntervals.inActive);
    };
    //record the last digest time for use when ending module activity
    SessionService.prototype.SetLastDigestTimestamp = function () {
        this.lastDigestTimeStamp = this.windowSvc.Date.now();
    };
    //******************************//
    // Silent Mode
    //*****************************//
    SessionService.prototype.SetSilent = function (isSilent) {
        this.isSilent = isSilent;
    };
    Object.defineProperty(SessionService.prototype, "IsSilent", {
        get: function () {
            return this.isSilent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SessionService.prototype, "CurrentAdminUserAccount", {
        get: function () {
            return this.adminUserAccount;
        },
        set: function (userAccount) {
            this.adminUserAccount = userAccount;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SessionService.prototype, "IsDevlessPanelOpen", {
        get: function () {
            return this.storageSvc.get(SessionService.storageKeys.DevlessPanelKey, false);
        },
        set: function (newValue) {
            this.storageSvc.set(SessionService.storageKeys.DevlessPanelKey, newValue);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SessionService.prototype, "SuccessCenterConfig", {
        get: function () {
            return this.successCenterConfig;
        },
        enumerable: false,
        configurable: true
    });
    SessionService.prototype.SetSuccessCenterConfig = function (config) {
        var _a;
        this.successCenterConfig = config;
        if (this.successCenterConfig) {
            this.successCenterConfig.unreadCounts = ((_a = this.successCenterConfig) === null || _a === void 0 ? void 0 : _a.unreadCounts) || {};
        }
    };
    //Internal Methods
    SessionService.prototype.getBoolFuncFlag = function (flagName) {
        return (this.functionality[flagName] || false);
    };
    SessionService.prototype.startNewActivity = function (timeStamp) {
        var newActivity = {
            module: this.CurrentModule,
            startDate: timeStamp,
            location: null,
            title: null,
            endDate: null,
            duration: null
        };
        if (this.commSvc.urlTracking) {
            newActivity.location = this.windowSvc.href();
            newActivity.title = this.windowSvc.title();
        }
        this.updateCurrentActivity(newActivity);
    };
    SessionService.prototype.endCurrentActivity = function (timeStamp) {
        var ca = this.currentActivity;
        if (ca !== null) {
            ca.module = ca.module || SessionService.defaultModule;
            ca.endDate = timeStamp;
            ca.duration = (new this.windowSvc.Date(ca.endDate) - new this.windowSvc.Date(ca.startDate)) / 1000;
            //if duration longer than maximum try using last digest timestamp
            if (this.lastDigestTimeStamp && ca.duration > this.maximumModuleDurationInSeconds) {
                console.log('Duration too long.');
                console.log('ldts:', new this.windowSvc.Date(this.lastDigestTimeStamp));
                console.log('end date:', new this.windowSvc.Date(ca.endDate));
                console.log('start date:', new this.windowSvc.Date(ca.startDate));
                console.log('End Date Duration', ca.duration);
                var digestDuration = (new this.windowSvc.Date(this.lastDigestTimeStamp) - new this.windowSvc.Date(ca.startDate)) / 1000;
                ca.duration = digestDuration;
                //console.log('Last Digest Time Stamp Duration', ca.duration);
            }
            if (ca.duration >= this.minimumModuleDurationInSeconds) {
                this.moduleActivities.push(ca);
            }
            //this.appSvc.debug(`Activity Ended w/ duration ${ca.duration}`);
            this.clearCurrentActivity();
        }
    };
    //remove all activities from the buffer
    SessionService.prototype.popModuleActivities = function () {
        var timeStamp = new this.windowSvc.Date().toISOString();
        var wasActive = false;
        if (this.currentActivity) {
            //if there isn't a current module somehow
            // ensure it is set to the same as the previous activity
            if (!this.CurrentModule) {
                this.CurrentModule = this.currentActivity.module;
            }
            //close out previous
            this.endCurrentActivity(timeStamp);
            wasActive = true;
        }
        var count = this.moduleActivities.length;
        var returnActivities = [];
        while (count) {
            var act = this.moduleActivities.shift();
            if (act !== null && act !== undefined) {
                returnActivities.push(act);
            }
            count--;
        }
        this.moduleActivities.empty();
        if (wasActive) {
            this.startNewActivity(timeStamp);
        }
        return returnActivities;
    };
    //statics
    SessionService.heartbeatIntervals = {
        active: 1000 * 30,
        inActive: 1000 * 60 * 5 // 5 min
    };
    SessionService.storageKeys = {
        TimeInAppCurrentKey: 'CZ_TIME_IN_APP_CURRENT_KEY',
        TimeInAppQueueKey: 'CZ_TIME_IN_APP_QUEUE_KEY',
        DevlessPanelKey: 'CZ_CONTENT_PANEL_OPEN_KEY'
    };
    SessionService.defaultModule = 'Default';
    return SessionService;
}());
exports["default"] = SessionService;


/***/ }),

/***/ "./src/services/storage.service.ts":
/*!*****************************************!*\
  !*** ./src/services/storage.service.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var StorageService = /** @class */ (function () {
    function StorageService(storageRepo) {
        this.storageRepo = storageRepo;
    }
    StorageService.prototype.set = function (key, value) {
        this.storageRepo.set(key, value);
    };
    StorageService.prototype.get = function (key, defaultValue) {
        return this.storageRepo.get(key, defaultValue);
    };
    StorageService.prototype.remove = function (key) {
        this.storageRepo.remove(key);
    };
    StorageService.prototype.encode = function (value) {
        return this.storageRepo.encode(value);
    };
    return StorageService;
}());
exports["default"] = StorageService;


/***/ }),

/***/ "./src/services/tenant.service.ts":
/*!****************************************!*\
  !*** ./src/services/tenant.service.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReleaseGates = exports.FeatureFlags = void 0;
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
//These are permanent gating mechanisms
var FeatureFlags;
(function (FeatureFlags) {
    FeatureFlags["PageTags"] = "pageTaggingEnabled";
    FeatureFlags["Walkthroughs"] = "walkthroughsEnabled";
    FeatureFlags["SuccessPanelAvatarPositionEnabled"] = "successPanelAvatarPositionEnabled";
    FeatureFlags["SuccessCentersEnabled"] = "successCentersEnabled";
})(FeatureFlags = exports.FeatureFlags || (exports.FeatureFlags = {}));
//These are temporary gating mechanisms; they should be cleaned up as often as possible
var ReleaseGates;
(function (ReleaseGates) {
    ReleaseGates["JourneyChecklistReleased"] = "journeyChecklistReleased";
    ReleaseGates["JourneyChecklistPhaseTwoReleased"] = "journeyChecklistPhaseTwoReleased";
    ReleaseGates["SuccessCentersReleased"] = "successCentersReleased";
    ReleaseGates["DevlessPreviousWalkthroughStepReleased"] = "devlessPreviousWalkthroughStepReleased";
})(ReleaseGates = exports.ReleaseGates || (exports.ReleaseGates = {}));
var TenantService = /** @class */ (function () {
    function TenantService(storageSvc) {
        this.storageSvc = storageSvc;
        this._uiFontFamilyMapping = [];
        this.GOOGLE_CSS2_REQUEST_BASE = 'https://fonts.googleapis.com/css2';
        this.featureFlags = {};
        //Privates
        this._accountOwner = null;
        this._tenantId = null;
        this.resetContact();
        this._pageTagConfig = { pageTags: [], pageTagVersion: '-1' };
        //default all feature flags to false
        this.featureFlags = {};
        this.featureFlags[FeatureFlags.PageTags] = false;
        this.featureFlags[FeatureFlags.Walkthroughs] = false;
        this.featureFlags[FeatureFlags.SuccessCentersEnabled] = false;
        this.featureFlags[ReleaseGates.JourneyChecklistReleased] = false;
        this.featureFlags[ReleaseGates.JourneyChecklistPhaseTwoReleased] = false;
        this.featureFlags[ReleaseGates.SuccessCentersReleased] = false;
    }
    //************************//
    // Tenant Id
    //************************//
    TenantService.prototype.setTenantId = function (TenantId) {
        this._tenantId = TenantId;
    };
    TenantService.prototype.currentTenantId = function () {
        return this._tenantId;
    };
    Object.defineProperty(TenantService.prototype, "accountOwner", {
        //************************//
        // User Account
        //************************//
        get: function () {
            //if the current userAccount does not exist,
            // try to load it from storage
            //if (!this._accountOwner) {
            //    this._accountOwner = this.storageSvc.get(TenantService.storageKeys.UserAccount, this._accountOwner);
            //}
            return this._accountOwner;
        },
        enumerable: false,
        configurable: true
    });
    TenantService.prototype.setAccountOwner = function (newAccountOwner) {
        this._accountOwner = newAccountOwner;
        //store current state of userAccount
        this.storageSvc.remove(TenantService.storageKeys.UserAccount);
        //this.storageSvc.set(TenantService.storageKeys.UserAccount, this._accountOwner);
    };
    Object.defineProperty(TenantService.prototype, "contact", {
        //************************//
        // User Account
        //************************//
        get: function () {
            //if the current contact does not exist,
            // try to load it from storage
            //if (!this._contact) {
            //    this._contact = this.storageSvc.get(TenantService.storageKeys.Contact, this._contact);
            //}
            return this._contact;
        },
        enumerable: false,
        configurable: true
    });
    //Methods
    //Contact Object Methods
    TenantService.prototype.SetContact = function (newContact) {
        this._contact = newContact;
        //store current state of contact
        //this.storageSvc.set(TenantService.storageKeys.Contact, this._contact);
    };
    TenantService.prototype.SetUIFontFamilyMapping = function (mapping) {
        this._uiFontFamilyMapping = mapping;
    };
    TenantService.prototype.buildUIFontFamilyCssRequestUrlFromConfig = function (styleConfig) {
        //guard dont nest
        if (!styleConfig) {
            return null;
        }
        var uiFontFamilyIds = styleConfig.uiFontFamilyIds || [];
        //first check for a fontFamilyId (i.e. ChecklistSettingsConfig)
        if (styleConfig.fontFamilyId && typeof styleConfig.fontFamilyId === 'number') {
            uiFontFamilyIds.push(styleConfig.fontFamilyId);
        }
        //then check for fontFamily string (i.e. WalkthroughStyleConfig, AnnouncementStyleConfig)
        if (styleConfig.fontFamily) {
            var fontFamilyId = this.getUIFontFamilyMappingId(styleConfig.fontFamily);
            if (fontFamilyId) {
                uiFontFamilyIds.push(fontFamilyId);
            }
        }
        var ctaFfId = this.getUIFontFamilyMappingId(styleConfig.ctaFontFamily);
        if (ctaFfId) {
            uiFontFamilyIds.push(ctaFfId);
        }
        return this.buildUIFontFamilyCssRequestUrl(uiFontFamilyIds);
    };
    TenantService.prototype.buildUIFontFamilyCssRequestUrl = function (uiFontFamilyIds) {
        var arr = (uiFontFamilyIds || []), queryParts = [];
        var al = arr.length;
        var _loop_1 = function (i) {
            var id = arr[i], mappings = this_1._uiFontFamilyMapping.filter(function (f) { return f.id === id; }), // use filter, because IE
            mapping = (mappings.length > 0) ? mappings[0] : null;
            if (mapping && mapping.queryPart)
                queryParts.push(mapping.queryPart);
        };
        var this_1 = this;
        for (var i = 0; i < al; i++) {
            _loop_1(i);
        }
        return (queryParts.length > 0) ? this.GOOGLE_CSS2_REQUEST_BASE + "?" + queryParts.join('&') + "&display=swap" : null;
    };
    /**
     * convert a font family name to its UIFontFamilyMapping Id
     * @param fontId
     * @private
     * @returns {number|null} will be null if fontId is null or undefined or if name does not match a known mapping
     */
    TenantService.prototype.getUIFontFamilyMappingId = function (fontId) {
        if (clientlibs_1.CoreUtils.isNullOrUndefined(fontId)) {
            return null;
        }
        if (typeof fontId === 'number') {
            return fontId;
        }
        // The below is taken directly from the web app logic. We should centralize this somewhere when time permits
        // 1. Replace any quoted family names i.e. "Roboto Condensed" => Roboto Condensed
        // 2. cut comma-separated fallbacks i.e. Montserrat, sans-serif => Montserrat
        // 3. Find matching family name in the server's font family collection
        var style = fontId.replace(/"/g, ''), subLen = style.indexOf(','), mainFont = style.substr(0, subLen), targetFonts = this._uiFontFamilyMapping.filter(function (f) { return f.family.toUpperCase() === mainFont.toUpperCase(); }); // use filter, because IE
        return targetFonts.length > 0 ? targetFonts[0].id : null;
    };
    TenantService.prototype.getUIFontFamilyMappingDisplayValue = function (fontId) {
        if (typeof fontId === 'string') {
            return fontId;
        }
        var targetFonts = this._uiFontFamilyMapping.filter(function (f) { return f.id === fontId; }); // use filter, because IE
        return targetFonts.length > 0 ? targetFonts[0].styleValue : '';
    };
    TenantService.prototype.getFullUIFontFamilyCssRequestUrl = function () {
        var queryParts = this._uiFontFamilyMapping.map(function (ff) { return ff.queryPart; });
        return (queryParts.length === 0) ?
            null :
            this.GOOGLE_CSS2_REQUEST_BASE + "?" + queryParts.join('&') + "&display=swap";
    };
    //Reset Contact
    TenantService.prototype.resetContact = function () {
        //clear out the contact
        this._contact = {
            id: null
        };
        this.storageSvc.remove(TenantService.storageKeys.Contact);
    };
    //Feature Flags
    TenantService.prototype.FeatureEnabled = function (name) {
        try {
            return !!this.featureFlags[name];
        }
        catch (ex) {
            return false;
        }
    };
    TenantService.prototype.setFeatureFlags = function (flags) {
        this.featureFlags = __assign({}, flags);
    };
    TenantService.prototype.getFeatureFlags = function () {
        return this.featureFlags;
    };
    //Statics
    TenantService.storageKeys = {
        Contact: 'CONTACT_KEY',
        UserAccount: 'USERACCOUNT_KEY'
    };
    return TenantService;
}());
exports["default"] = TenantService;


/***/ }),

/***/ "./src/services/walkthrough.service.ts":
/*!*********************************************!*\
  !*** ./src/services/walkthrough.service.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Enums_1 = __webpack_require__(/*! @src/core/Enums */ "./src/core/Enums.ts");
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var WalkthroughService = /** @class */ (function () {
    function WalkthroughService(commSvc, windowSvc, applicationSvc, sessionSvc) {
        this.commSvc = commSvc;
        this.windowSvc = windowSvc;
        this.applicationSvc = applicationSvc;
        this.sessionSvc = sessionSvc;
        this.lastWalkthroughPing = null;
        this.pingInterval = 1000 * 30;
        //Privates
        this._walkthroughConfig = { items: [], version: '-1', properties: {} };
    }
    Object.defineProperty(WalkthroughService.prototype, "walkthroughsVersion", {
        get: function () {
            return this._walkthroughConfig.version;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WalkthroughService.prototype, "walkthroughs", {
        get: function () {
            return this._walkthroughConfig.items;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WalkthroughService.prototype, "walkthroughStyleConfig", {
        get: function () {
            return this._globalWalkthroughStyleConfig || __assign({}, clientlibs_1.CZ_DEFAULT_STYLE_CONFIG);
        },
        enumerable: false,
        configurable: true
    });
    WalkthroughService.prototype.RefreshWalkthroughConfig = function (force) {
        //let the main frame worry about refreshes
        if (!this.applicationSvc.isMain) {
            return;
        }
        // every 60 seconds
        //check for an updated walkthrough config
        if (+this.windowSvc.Date.now() - +this.lastWalkthroughPing > this.pingInterval || force) {
            this.lastWalkthroughPing = this.windowSvc.Date.now();
            var data = {
                version: this.walkthroughsVersion
            };
            this.commSvc.send(Enums_1.Enums.SocketMessageTypes.SOCKETMESSAGETYPE_CheckWalkthroughConfigVersion, data);
        }
    };
    WalkthroughService.prototype.LoadWalkthroughConfig = function (walkthroughConfig) {
        if (walkthroughConfig) {
            var properties = walkthroughConfig.properties;
            if (properties === null || properties === void 0 ? void 0 : properties.styleConfigsEnabled) {
                var tenantStyleConfig = clientlibs_1.ModelUtils.create(new clientlibs_1.WalkthroughStyleConfig(), JSON.parse(properties.globalStyleConfigJson || '{}'));
                this._globalWalkthroughStyleConfig = __assign(__assign({}, clientlibs_1.CZ_DEFAULT_STYLE_CONFIG), tenantStyleConfig);
            }
            for (var i = 0; i < walkthroughConfig.items.length; i++) {
                if (walkthroughConfig.items[i]) {
                    walkthroughConfig.items[i] = clientlibs_1.Walkthrough.fromObject(walkthroughConfig.items[i]);
                    if (properties === null || properties === void 0 ? void 0 : properties.styleConfigsEnabled) {
                        this.hydateStepStyleConfigs(this._globalWalkthroughStyleConfig, walkthroughConfig.items[i]);
                    }
                }
            }
            this._walkthroughConfig = walkthroughConfig;
            if (!this.lastWalkthroughPing) {
                this.lastWalkthroughPing = this.windowSvc.Date.now();
            }
        }
    };
    WalkthroughService.prototype.hydateStepStyleConfigs = function (defaults, wt) {
        var steps = wt.steps, sl = steps.length;
        for (var i = 0; i < sl; i++) {
            var step = steps[i], stepStyleConfig = __assign(__assign(__assign({}, defaults), wt.styleConfig), step.styleConfig);
            step.styleConfig = stepStyleConfig;
        }
    };
    WalkthroughService.prototype.AddWalkthroughs = function (Walkthroughs, ResetFirst) {
        var _a;
        var isItemsAnArray = Array.isArray((_a = this._walkthroughConfig) === null || _a === void 0 ? void 0 : _a.items);
        if (ResetFirst || !isItemsAnArray) {
            this._walkthroughConfig.items = [];
        }
        this._walkthroughConfig.items = this._walkthroughConfig.items.concat(Walkthroughs);
    };
    WalkthroughService.prototype.GetClickWalkthroughs = function () {
        var _a;
        var isItemsAnArray = Array.isArray((_a = this._walkthroughConfig) === null || _a === void 0 ? void 0 : _a.items);
        if (!isItemsAnArray) {
            return [];
        }
        return this._walkthroughConfig.items.filter(function (item) {
            return !item.disabled && item.triggerTypeId === clientlibs_1.WalkthroughTriggerType.Click;
        });
    };
    WalkthroughService.prototype.GetPageVisitWalkthroughs = function () {
        var _a;
        var isItemsAnArray = Array.isArray((_a = this._walkthroughConfig) === null || _a === void 0 ? void 0 : _a.items);
        if (!isItemsAnArray) {
            return [];
        }
        return this._walkthroughConfig.items.filter(function (item) {
            return !item.disabled && item.triggerTypeId === clientlibs_1.WalkthroughTriggerType.PageVisit;
        });
    };
    WalkthroughService.prototype.GetAnchorWalkthroughs = function () {
        var _a;
        var isItemsAnArray = Array.isArray((_a = this._walkthroughConfig) === null || _a === void 0 ? void 0 : _a.items);
        if (!isItemsAnArray) {
            return [];
        }
        return this._walkthroughConfig.items.filter(function (item) {
            return !item.disabled && item.triggerTypeId === clientlibs_1.WalkthroughTriggerType.Anchor;
        });
    };
    //WalkthroughContactActions
    WalkthroughService.prototype.SendActionMessage = function (actionId, walkthroughId, walkthroughStepId) {
        if (walkthroughId && walkthroughId > 0) {
            var actionInfo = {
                actionId: actionId,
                actionDate: new this.windowSvc.Date().toISOString(),
                walkthroughId: walkthroughId,
                walkthroughStepId: walkthroughStepId
            };
            //dont send walkthrough actions for when the devless panel is open
            if (this.sessionSvc.ShouldPreventUsageSends) {
                return;
            }
            var forcePoll = actionId === Enums_1.Enums.WalkthroughActionType.WalkthroughStarted;
            this.commSvc.send(Enums_1.Enums.SocketMessageTypes.SOCKETMESSAGETYPE_WalkthroughAction, actionInfo, forcePoll);
        }
    };
    return WalkthroughService;
}());
exports["default"] = WalkthroughService;


/***/ }),

/***/ "./src/services/window.service.ts":
/*!****************************************!*\
  !*** ./src/services/window.service.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var czq = __webpack_require__(/*! ../czq/czq.js */ "./src/czq/czq.js");
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var errorLogger_1 = __importDefault(__webpack_require__(/*! @src/core/errorLogger */ "./src/core/errorLogger.ts"));
var WindowService = /** @class */ (function () {
    function WindowService(inputWindow, useWindowsObjects) {
        if (useWindowsObjects === void 0) { useWindowsObjects = false; }
        this.useWindowsObjects = useWindowsObjects;
        //Privates
        this.eventNamespace = 'czEvent';
        this.onCleanRoomUnload = [];
        //Public Properties
        this._czHost = ""; //gets replaced by build task
        this._origins = [];
        this._nativeDateAcceptable = false;
        this._nativeXHRAcceptable = false;
        this._nativeJSONAcceptable = false;
        this._nativeAddEventListenerAcceptable = false;
        this._window = inputWindow;
        this._nativeJSONAcceptable = this.isNativeJSONAcceptable();
        this._nativeDateAcceptable = this.isNativeDateAcceptable();
        this._nativeXHRAcceptable = this.isNativeXHRAcceptable();
        this._nativeAddEventListenerAcceptable = this.isNativeAddEventListenerAcceptable();
        this.errorLogger = new errorLogger_1.default(this.socketServerApiUrl, this.coder());
        this.XMLHttpRequestReference = this.XMLHttpRequestReference.bind(this);
    }
    WindowService.prototype.addCleanRoomUnload = function (fn) {
        this.onCleanRoomUnload.push(fn);
    };
    Object.defineProperty(WindowService.prototype, "czHost", {
        get: function () {
            return this._czHost;
        },
        set: function (newHost) {
            this._czHost = newHost;
            this._clientSideUrls = this.buildClientSideUrlsFromSetHost(newHost);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WindowService.prototype, "clientSideUrls", {
        get: function () {
            if (!this._clientSideUrls) {
                this._clientSideUrls = this.parseClientSideUrls();
            }
            return this._clientSideUrls;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WindowService.prototype, "socketServerApiUrl", {
        get: function () {
            return this.clientSideUrls.baseApiUrl + 'api/v1/sockets/';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WindowService.prototype, "cdnUrl", {
        get: function () {
            return this.clientSideUrls.baseApiUrl + 'external/';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WindowService.prototype, "JSON", {
        get: function () {
            if (!this._json) {
                try {
                    // TODO: Look into why this can possibly be returning undefined?
                    this._json = this.getOriginalJson();
                    if (clientlibs_1.CoreUtils.isNullOrUndefined(this._json))
                        throw new Error('windowSvc JSON getter: this._json is falsy');
                }
                catch (e) {
                    if (this._nativeJSONAcceptable) {
                        return this.window.JSON;
                    }
                    throw e;
                }
            }
            return this._json;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WindowService.prototype, "Date", {
        get: function () {
            if (!this._date) {
                try {
                    this._date = this.getOriginalDate();
                }
                catch (e) {
                    if (this._nativeDateAcceptable) {
                        return this._window.Date;
                    }
                    throw e;
                }
            }
            return this._date;
        },
        enumerable: false,
        configurable: true
    });
    WindowService.prototype.createElement = function (tagName, options) {
        try {
            if (this.isPrototypeJSLoaded()) {
                return this.document.createElement(tagName, options);
            }
            return this.originalObjectIframe.contentWindow.document.createElement(tagName, options);
        }
        catch (e) {
            if (this._nativeAddEventListenerAcceptable) {
                return this.document.createElement(tagName, options);
            }
            throw e;
        }
    };
    Object.defineProperty(WindowService.prototype, "czq", {
        get: function () {
            if (typeof (this._czq) === 'undefined') {
                this._czq = czq;
            }
            return this._czq;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WindowService.prototype, "ChurnZero", {
        get: function () {
            return this.window['ChurnZero'];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WindowService.prototype, "originalObjectIframe", {
        get: function () {
            var _this = this;
            if (this.useWindowsObjects) {
                return {
                    contentWindow: window
                };
            }
            var isConnected = true;
            if (this._originalObjectIFrame && this._originalObjectIFrame.isConnected !== undefined) {
                isConnected = this._originalObjectIFrame.isConnected;
            }
            if (!this._originalObjectIFrame || !isConnected) {
                var id = 'cz-clean-room';
                var frame = this.window.document.getElementById(id);
                if (frame && isConnected) {
                    console.log('Reclaimed Clean Room Frame');
                    this._originalObjectIFrame = frame;
                }
                else {
                    console.log('Adding Clean Room Frame');
                    var iframeSrc = 'about:blank';
                    var iframe = this.window.document.createElement('iframe');
                    iframe.id = id;
                    iframe.src = iframeSrc;
                    iframe.style.display = 'none';
                    iframe.height = iframe.width = '0';
                    iframe.onload = function (e) {
                        var contentiFrame = e.target;
                        contentiFrame.contentDocument.defaultView.onunload = function () {
                            _this._originalObjectIFrame = null;
                            for (var i = 0; i < _this.onCleanRoomUnload.length; i++) {
                                try {
                                    _this.onCleanRoomUnload[i]();
                                }
                                catch (e) {
                                    //meh
                                }
                            }
                        };
                    };
                    var root = this.window.document.getElementsByTagName('body');
                    if (root.length === 0) {
                        root = this.window.document.getElementsByTagName('head');
                    }
                    if (root.length === 0) {
                        root = this.window.document.getElementsByTagName('html');
                    }
                    if (root.length > 0) {
                        root[0].appendChild(iframe);
                    }
                    this._originalObjectIFrame = iframe;
                }
            }
            return this._originalObjectIFrame;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WindowService.prototype, "elementCache", {
        get: function () {
            if (typeof (this._elementCache) === 'undefined') {
                this._elementCache = this.buildElementCache();
            }
            return this._elementCache;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WindowService.prototype, "window", {
        //Leaving original getter method to not break things...
        get: function () {
            return this._window;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WindowService.prototype, "document", {
        //Leaving original getter method to not break things...
        get: function () {
            if (!this._document)
                this._document = this._window.document;
            return this._window.document;
        },
        enumerable: false,
        configurable: true
    });
    //Added 'Element' to the end of methods to be a little
    //more descriptive as to what the method does.
    WindowService.prototype.getBodyElement = function () {
        if (!this._body)
            this._body = this._window.document.querySelector('body');
        return this._body;
    };
    WindowService.prototype.getHeadElement = function () {
        if (!this._head)
            this._head = this._window.document.querySelector('head');
        return this._head;
    };
    //New methods to replace getters as we remove getter methods.
    WindowService.prototype.getDocument = function () {
        if (!this._document)
            this._document = this._window.document;
        return this._window.document;
    };
    WindowService.prototype.getWindow = function () {
        return this._window;
    };
    //Host Name
    WindowService.prototype.hostName = function () {
        return this.window.location.hostname;
    };
    //Title
    WindowService.prototype.title = function () {
        return this.window.document.title;
    };
    WindowService.prototype.href = function () {
        try {
            return this.window.location.href;
        }
        catch (_a) {
            return '';
        }
    };
    /**
     * Object to encode and decode values to/from strings and objects
     */
    WindowService.prototype.coder = function () {
        var coder = this.JSON;
        return { encode: coder.stringify, decode: coder.parse };
    };
    WindowService.prototype.XMLHttpRequestReference = function () {
        try {
            return this.getOriginalXMLHttpRequest();
        }
        catch (e) {
            if (this._nativeXHRAcceptable) {
                return this._window.XMLHttpRequest;
            }
            throw e;
        }
    };
    /**
     * Determine if the current browser is supported
     */
    WindowService.prototype.isSupportedBrowser = function () {
        if (clientlibs_1.CoreUtils.FeatureDetection.isLegacyIE()) {
            return false;
        }
        if (this.isLegacyFirefox()) {
            return false;
        }
        if (this.isBrowserCaptureUserAgent()) {
            return false;
        }
        if (!this.supportsISOStringParsing()) {
            return false;
        }
        if (!this.supportsClassList()) {
            return false;
        }
        return true;
    };
    /**
     * Determine if the current href is an acceptable location
     * @param additionalLocations
     */
    WindowService.prototype.isAcceptableLocation = function (additionalLocations) {
        var href = this.href();
        var badLocations = WindowService.defaultUnacceptableLocations;
        if (Array.isArray(additionalLocations)) {
            badLocations = badLocations.concat(additionalLocations);
        }
        for (var i = 0; i < badLocations.length; i++) {
            if (href.indexOf(badLocations[i]) !== -1) {
                return false;
            }
        }
        return true;
    };
    WindowService.prototype.CheckPageTagAgainstCurrentLocation = function (pageTag) {
        var regExString = clientlibs_1.CoreUtils.Urls.buildRegexFromLocationParts(pageTag.location, clientlibs_1.LocationOptions.fromJson(pageTag.locationOptionsJson));
        var regEx = new RegExp(regExString);
        return !!this.href().match(regEx);
    };
    Object.defineProperty(WindowService.prototype, "origins", {
        get: function () {
            if (!this._origins || this._origins.length === 0) {
                this._origins = [this.window.location.origin];
            }
            return this._origins;
        },
        set: function (newOrigins) {
            this._origins = newOrigins;
        },
        enumerable: false,
        configurable: true
    });
    WindowService.prototype.addOrigin = function (origin) {
        if (this.origins.indexOf(origin) === -1) {
            this.origins = this.origins.concat([origin]);
        }
    };
    /**
     * Determine if the ChurnZero object exists on the window
     */
    WindowService.prototype.wasDisposed = function () {
        var cz = this._window['ChurnZero'];
        if (!cz) {
            return true;
        }
        if (cz.name !== 'ChurnZeroApp') {
            return true;
        }
        return false;
    };
    /**
     * UI Event Items
     **/
    WindowService.prototype.namespaceEvent = function (events) {
        if (typeof (events) === 'string') {
            events = [events];
        }
        for (var i = 0; i < events.length; i++) {
            events[i] = events[i].trim() + "." + this.eventNamespace;
        }
        return events.join(' ');
    };
    WindowService.prototype.removeNamespacedEvents = function () {
        console.info('Removing Namespaced Dom Event Listeners');
        var ns = "." + this.eventNamespace;
        this.elementCache.body.off(ns);
        this.elementCache.document.off(ns);
        this.elementCache.window.off(ns);
    };
    /**
     * Generate a selector for the given element
     * @param element
     */
    WindowService.prototype.buildSelector = function (element) {
        var page = this.href(), 
        //target = this.czq(element),
        selector = clientlibs_1.CoreUtils.buildFullDomSelector(element);
        //uniqueness;
        //we have to traverse the tree to build a specific selector
        /*
        let parents = CoreUtils.getParentsOfElement(element);
        let parentSelectors:string[]=[];
        for(let i=0; i<parents.length;i++){
            parentSelectors.push(CoreUtils.buildElementSelector(parents[i]));
        }

        parentSelectors = parentSelectors.reverse();

        let parentSelectors: any = target.parents()
            .map((i, e) => {
                return CoreUtils.buildElementSelector(e as HTMLElement);
            })
            .get()
            .reverse();

        selector = (parentSelectors as string[])
            .concat([CoreUtils.buildElementSelector(element)])
            .join(">");

         */
        //test uniqueness
        //uniqueness = this.czq(selector);
        /*if (uniqueness.length > 1) {
            uniqueness.each(function (i, e) {

                if (e === element) {
                    selector += ":eq(" + i + ")";
                    return false;
                }

            });
        }*/
        return {
            page: page,
            selector: selector,
            full: page + ' | ' + selector
        };
    };
    /**
     * Checks whether elements are within the user visible viewport of a web browser.
     * Note: Only accounts for vertical position, not horizontal.
     * @param t
     * @param partial
     * @param hidden
     * @param direction
     */
    WindowService.prototype.isVisible = function (t, partial, hidden, direction) {
        /**
         * Copyright 2012, Digital Fusion
         * Licensed under the MIT license.
         * http://teamdf.com/jquery-plugins/license/
         *
         * @author Sam Sehnert
         * @desc A small plugin that checks whether elements are within
         *       the user visible viewport of a web browser.
         *       only accounts for vertical position, not horizontal.
         */
        if (t.length < 1)
            return false;
        var $t = t.length > 1 ? t.eq(0) : t;
        var $w = this.elementCache.window;
        var vpWidth = $w.width(), vpHeight = $w.height(), clientSize = hidden === true ? t.offsetWidth * t.offsetHeight : true;
        direction = direction || 'both';
        if (typeof t.getBoundingClientRect === 'function') {
            // Use this native browser method, if available.
            var rec = t.getBoundingClientRect(), tViz = rec.top >= 0 && rec.top < vpHeight, bViz = rec.bottom > 0 && rec.bottom <= vpHeight, lViz = rec.left >= 0 && rec.left < vpWidth, rViz = rec.right > 0 && rec.right <= vpWidth, vVisible = partial ? tViz || bViz : tViz && bViz, hVisible = partial ? lViz || rViz : lViz && rViz;
            if (direction === 'both')
                return clientSize > 0 && vVisible && hVisible;
            else if (direction === 'vertical')
                return clientSize > 0 && vVisible;
            else if (direction === 'horizontal')
                return clientSize > 0 && hVisible;
        }
        else {
            var viewTop = $w.scrollTop(), viewBottom = viewTop + vpHeight, viewLeft = $w.scrollLeft(), viewRight = viewLeft + vpWidth, offset = $t.offset(), top = offset.top, bottom = top + $t.height(), left = offset.left, right = left + $t.width(), compareTop = partial === true ? bottom : top, compareBottom = partial === true ? top : bottom, compareLeft = partial === true ? right : left, compareRight = partial === true ? left : right;
            if (direction === 'both')
                return !!clientSize && ((compareBottom <= viewBottom) && (compareTop >= viewTop)) && ((compareRight <= viewRight) && (compareLeft >= viewLeft));
            else if (direction === 'vertical')
                return !!clientSize && ((compareBottom <= viewBottom) && (compareTop >= viewTop));
            else if (direction === 'horizontal')
                return !!clientSize && ((compareRight <= viewRight) && (compareLeft >= viewLeft));
        }
    };
    /**
     * Center an element within the body.
     * @param element
     */
    WindowService.prototype.centerElementOnScreen = function (element) {
        if (element === null || typeof element === 'undefined') {
            return;
        }
        var bodyElement = this.document.querySelector('body');
        if (!bodyElement) {
            return;
        }
        var top = (bodyElement.clientHeight / 2) - (element.clientHeight / 4); // + bodyElement.scrollTop;
        var left = (bodyElement.clientWidth / 2) - (element.clientWidth / 4); // + bodyElement.scrollLeft;
        element.style.position = 'fixed';
        element.style.margin = 0;
        element.style.top = (top > 0 ? top : 0) + 'px';
        element.style.left = (left > 0 ? left : 0) + 'px';
    };
    /**
     * Get the offset of an element relative to the window
     * @param el
     */
    WindowService.prototype.offset = function (el) {
        var $w = this.window, rect = el.getBoundingClientRect(), scrollLeft = $w.pageXOffset || this.document.documentElement.scrollLeft, scrollTop = $w.pageYOffset || this.document.documentElement.scrollTop;
        return { top: rect.top + scrollTop, left: rect.left + scrollLeft };
    };
    WindowService.prototype.findElement = function (elementToFind) {
        var element, jqueryResult;
        if (typeof elementToFind === 'string') {
            jqueryResult = this.czq(elementToFind);
            if (jqueryResult.length > 0) {
                element = jqueryResult;
            }
            else {
                return;
            }
        }
        else {
            element = this.czq(elementToFind);
        }
        return element;
    };
    /**
     * Generate the necessary urls to communicate with the server.
     * If _czHost is blank, get the source from the Churn Zero script element
     */
    WindowService.prototype.parseClientSideUrls = function () {
        var src = this._czHost;
        if (!src || (src || '').trim().length === 0) {
            src = this.getChurnZeroScriptSrc(this.document);
        }
        return this.buildClientSideUrls(src);
    };
    WindowService.prototype.openWindow = function (url) {
        return this.window.open(url, '_blank');
    };
    /**
     * Encode a value so it can be used as an attribute value in HTML
     * @param value
     */
    WindowService.prototype.escapeObjectForDom = function (value) {
        return btoa(this.JSON.stringify(value));
    };
    /**
     * Decode a value that was encoded to be used as an attribute value in HTML
     * @param value
     */
    WindowService.prototype.unescapeObjectFromDom = function (value) {
        return this.JSON.parse(atob(value));
    };
    /**
     * Creates a copy of the given object
     * @param obj
     */
    WindowService.prototype.clone = function (obj) {
        return this.JSON.parse(this.JSON.stringify(obj));
    };
    //Internal Methods
    WindowService.prototype.supportsISOStringParsing = function () {
        try {
            return !isNaN(new this.Date(new this.Date().toISOString()).getTime());
        }
        catch (err) {
            return false;
        }
    };
    WindowService.prototype.isBrowserCaptureUserAgent = function () {
        try {
            var nAgt = navigator.userAgent, iswkhtmlto = nAgt.indexOf('wkhtmlto') !== -1;
            return iswkhtmlto;
        }
        catch (err) {
            return false;
        }
    };
    WindowService.prototype.isLegacyFirefox = function () {
        try {
            var nAgt = (navigator.userAgent || '').toLowerCase(), searchString = 'firefox/', firefoxIndex = nAgt.indexOf(searchString), isFireFox = firefoxIndex !== -1;
            //if it is a firefox like browser
            if (isFireFox) {
                //try to get the major version number
                var start = firefoxIndex + searchString.length, versionNumString = nAgt.substring(start), versionNum = parseInt(versionNumString, 10);
                //firefox 61 and below has a bug with getComputedStyle (https://caniuse.com/?search=getComputedStyle)
                if (versionNum < 62) {
                    return true;
                }
            }
            // If we've gotten this far, this browser isn't considered legacy FF
            return false;
        }
        catch (err) {
            return false;
        }
    };
    WindowService.prototype.isPrototypeJSLoaded = function () {
        return window && window['Prototype'] && window['Prototype'].Version;
    };
    WindowService.prototype.supportsClassList = function () {
        try {
            //dont use this.createElement here because we dont want to get into a loop during boot
            var testElement = this.document.createElement('div');
            testElement.classList.add('cz-hidden');
        }
        catch (_a) {
            return false;
        }
        return true;
    };
    WindowService.prototype.buildElementCache = function () {
        var body = this.czq('body');
        if (body.length === 0) {
            body = this.czq('html');
        }
        return {
            window: this.czq(window),
            document: this.czq(document),
            head: this.czq('head'),
            body: body
        };
    };
    WindowService.prototype.getOriginalJson = function () {
        var f = this.originalObjectIframe.contentWindow;
        var oj = f.JSON;
        //check if prototypejs is in global space
        if (this.isPrototypeJSLoaded()) {
            var fn_1 = oj.stringify;
            oj.stringify = function (o) {
                var tmp, toJSON;
                if (o.toJSON) {
                    toJSON = o.toJSON;
                    o.toJSON = undefined;
                }
                // eslint-disable-next-line prefer-rest-params
                tmp = fn_1.apply(this, arguments);
                toJSON && (o.toJSON = toJSON);
                return tmp;
            };
        }
        return oj;
    };
    WindowService.prototype.getOriginalDate = function () {
        return this.originalObjectIframe.contentWindow.Date;
    };
    WindowService.prototype.getOriginalXMLHttpRequest = function () {
        return this.originalObjectIframe.contentWindow.XMLHttpRequest;
    };
    /**
     * Find the ChurnZero Script and get the host
     */
    WindowService.prototype.getChurnZeroScriptSrc = function (doc) {
        //cant use czq here because it might not be loaded yet!
        var scriptTag = doc.querySelector('script[src*=\'churnzero.js\']');
        if (scriptTag) {
            var src = scriptTag.getAttribute('src');
            if (src) {
                src = src.substring(0, src.lastIndexOf('/') + 1);
                return src;
            }
        }
        return '';
    };
    WindowService.prototype.buildClientSideUrls = function (src) {
        //setup the apiUrl and the cdnUrl
        var parsed = clientlibs_1.CoreUtils.Urls.parseUrlString(src);
        var apiUrl = 'https:'; //parsed.protocol, // + '//' + parsed.host + '/',
        if (parsed.host.indexOf('localhost:53157') >= 0) {
            //localhost
            apiUrl = 'https://analytics.localhost:53157/';
        }
        else if (parsed.host.indexOf('apptest.churnzerolabs.com') >= 0 || parsed.host.indexOf('analyticstest.churnzerolabs.com') >= 0) {
            //test
            apiUrl += '//analyticstest.churnzerolabs.com/';
        }
        else if (parsed.host.indexOf('appstaging.churnzerolabs.com') >= 0) {
            //staging
            apiUrl += '//appstaging.churnzerolabs.com/';
        }
        else if (parsed.host.indexOf('appbranch01.churnzerolabs.com') >= 0) {
            //branch01
            apiUrl += '//appbranch01.churnzerolabs.com/';
        }
        else if (parsed.host.indexOf('eu1analytics.churnzero.net') >= 0) {
            //production europe / asia
            apiUrl += '//eu1analytics.churnzero.net/'; //'//' + parsed.host + '/'; //
        }
        else { //if (parsed.host.indexOf('analytics.churnzero.net') >= 0) {
            //production
            apiUrl += '//analytics.churnzero.net/'; //'//' + parsed.host + '/'; //
        }
        return {
            scriptSrc: src,
            baseApiUrl: apiUrl,
            //deprecated
            environment: '',
            sockets: apiUrl + 'api/v1/sockets/',
            cdn: apiUrl + 'external/',
        };
    };
    WindowService.prototype.buildClientSideUrlsFromSetHost = function (src) {
        //setup the apiUrl and the cdnUrl
        var parsed = clientlibs_1.CoreUtils.Urls.parseUrlString(src);
        var apiUrl = 'https://' + parsed.host + '/';
        return {
            scriptSrc: src,
            baseApiUrl: apiUrl,
            //deprecated
            environment: '',
            sockets: apiUrl + 'api/v1/sockets/',
            cdn: apiUrl + 'external/',
        };
    };
    WindowService.prototype.isNativeFunction = function (fn) {
        try {
            return /\{\s+\[native code\]/.test(Function.prototype.toString.call(fn));
        }
        catch (e) {
            return false;
        }
    };
    WindowService.prototype.isNativeDateAcceptable = function () {
        try {
            if (this.isNativeFunction(this._window.Date)
                && this.isNativeFunction(this._window.Date.now)
                && this.isNativeFunction(this._window.Date.toString)
                && this.isNativeFunction(new this._window.Date().toISOString)) {
                return true;
            }
        }
        catch (e) {
            //meh
        }
        return false;
    };
    WindowService.prototype.isNativeXHRAcceptable = function () {
        try {
            if (this.isNativeFunction(this._window.XMLHttpRequest)) {
                var xhr = new this._window.XMLHttpRequest();
                if (this.isNativeFunction(xhr.open)
                    && this.isNativeFunction(xhr.send)
                    && this.isNativeFunction(xhr.setRequestHeader)) {
                    return true;
                }
            }
        }
        catch (e) {
            //meh
        }
        return false;
    };
    WindowService.prototype.isNativeJSONAcceptable = function () {
        try {
            var win = this._window;
            if (Object.prototype.toString.call(win.JSON) === '[object JSON]') {
                var JSON = win.JSON;
                if (this.isNativeFunction(JSON.stringify) && this.isNativeFunction(JSON.parse))
                    return true;
            }
        }
        catch (error) {
            // meh
        }
        return false;
    };
    WindowService.prototype.isNativeAddEventListenerAcceptable = function () {
        try {
            var doc = this.document;
            if (this.isNativeFunction(doc.createElement)) {
                var l = doc.createElement('link');
                if (this.isNativeFunction(l.addEventListener))
                    return true;
            }
        }
        catch (error) {
            // meh
        }
        return false;
    };
    //Statics
    WindowService.defaultUnacceptableLocations = [];
    return WindowService;
}());
exports["default"] = WindowService;


/***/ }),

/***/ "./src/utils/DOM.utils.ts":
/*!********************************!*\
  !*** ./src/utils/DOM.utils.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DOMUtils = void 0;
var DOMUtils = /** @class */ (function () {
    function DOMUtils() {
    }
    /** Given two bounding client rectangles, detects collisions via x/y and width/height properties  **/
    DOMUtils.hasCollision = function (a, b) {
        return !((a.y + a.height) < b.y ||
            a.y > (b.y + b.height) ||
            (a.x + a.width) < b.x ||
            a.x > (b.x + b.width));
    };
    /**
     * Returns a flag indicating whether a provided feature is supported
     * @param theWindow The window object to check for feature support
     * @param featureName The name of the feature
     */
    DOMUtils.isFeatureSupported = function (theWindow, featureName) {
        return featureName in theWindow;
    };
    return DOMUtils;
}());
exports.DOMUtils = DOMUtils;


/***/ }),

/***/ "./src/utils/FrameComm.util.ts":
/*!*************************************!*\
  !*** ./src/utils/FrameComm.util.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FrameCommUtil = void 0;
var clientlibs_1 = __webpack_require__(/*! @churnzero/clientlibs */ "./node_modules/@churnzero/clientlibs/dist/main/index.js");
var FrameCommUtil = /** @class */ (function () {
    function FrameCommUtil() {
    }
    /**
     * Attaches link click event listeners to a given frame window
     * @param frameWindow window to add link click events to
     * @param transportPod the transport message to send upon event dispatch
     */
    FrameCommUtil.setUpLinkAuditEvents = function (frameWindow, transportPod) {
        var frameDocument = frameWindow.document;
        frameDocument.addEventListener('click', function (e) {
            if (!transportPod || !e.target) {
                return;
            }
            var target = e.target;
            var sendAudit = false, el = target;
            // Determine if this is a direct video click
            if (el.classList && el.classList.contains('fr-video')) {
                sendAudit = true;
            }
            // Determine if a link has been clicked (Pretty much the MDN polyfill for 'closest')
            while (!sendAudit && el !== null && el.nodeType === 1) {
                if (el.nodeName.toLowerCase() === 'a') {
                    sendAudit = true;
                }
                else {
                    el = el.parentElement;
                }
            }
            if (sendAudit) {
                // Avoid mutating the transportPod
                var msg = __assign({}, transportPod);
                if (el.nodeName.toLowerCase() === 'a') {
                    // Avoid mutating the transportPod's data property
                    msg.data = __assign(__assign({}, transportPod.data), { props: { href: el.getAttribute('href') } });
                }
                FrameCommUtil.postEncryptedMessage(frameWindow.parent, msg);
            }
        });
    };
    /**
     * Attaches video click & focus event listeners to a given frame window
     * @param frameWindow window to add video mouse events to
     * @param transportPod the transport message to send upon event dispatch
     */
    FrameCommUtil.setUpVideoAuditEvents = function (frameWindow, transportPod) {
        var frameDocument = frameWindow.document;
        var isVideoFrameFocused = false;
        frameDocument.addEventListener('mouseenter', function (e) {
            var t = e.target;
            if (!t || !t.classList)
                return;
            if (t.classList.contains('fr-video')) {
                isVideoFrameFocused = true;
            }
        }, true);
        frameDocument.addEventListener('mouseleave', function (e) {
            var t = e.target;
            if (!t || !t.classList)
                return;
            if (t.classList.contains('fr-video')) {
                isVideoFrameFocused = false;
            }
        }, true);
        frameWindow.addEventListener('blur', function (e) {
            if (!transportPod || !isVideoFrameFocused) {
                return;
            }
            FrameCommUtil.postEncryptedMessage(frameWindow.parent, __assign({}, transportPod));
        });
        frameWindow.addEventListener('message', function (e) {
            if (!isVideoFrameFocused) {
                return;
            }
            var data = e.data, source = e.source, origin = e.origin;
            if (typeof data !== 'string' || data.toLowerCase() !== 'czcodeblur') {
                return;
            }
            var sourceWindow = source;
            FrameCommUtil.postEncryptedMessage(sourceWindow, __assign({}, transportPod), origin);
        });
    };
    /**
     * Posts an encrypted message to the specified window
     * @param targetWindow the window to invoke postMessage on
     * @param message the message to send w/ postMessage
     * @param origin the origin to send w/ postMessage
     */
    FrameCommUtil.postEncryptedMessage = function (targetWindow, message, origin) {
        var em = clientlibs_1.iFrameUtils.encrypt(JSON.stringify(message));
        targetWindow.postMessage(em, origin || '*');
    };
    return FrameCommUtil;
}());
exports.FrameCommUtil = FrameCommUtil;


/***/ }),

/***/ "./src/czq/czq.js":
/*!************************!*\
  !*** ./src/czq/czq.js ***!
  \************************/
/***/ (function(module) {


/*!
 * jQuery JavaScript Library v3.5.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2020-05-04T22:49Z
 */
( function( global, factory ) {

    "use strict";

    if (  true && typeof module.exports === "object" ) {

        // For CommonJS and CommonJS-like environments where a proper `window`
        // is present, execute the factory and get jQuery.
        // For environments that do not have a `window` with a `document`
        // (such as Node.js), expose a factory as module.exports.
        // This accentuates the need for the creation of a real `window`.
        // e.g. var jQuery = require("jquery")(window);
        // See ticket #14549 for more info.
        module.exports = global.document ?
            factory( global, true ) :
            function( w ) {
                if ( !w.document ) {
                    throw new Error( "jQuery requires a window with a document" );
                }
                return factory( w );
            };
    } else {
        factory( global );
    }

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

    // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
    // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
    // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
    // enough that all such attempts are guarded in a try block.
    "use strict";

    var arr = [];

    var getProto = Object.getPrototypeOf;

    var slice = arr.slice;

    var flat = arr.flat ? function( array ) {
        return arr.flat.call( array );
    } : function( array ) {
        return arr.concat.apply( [], array );
    };


    var push = arr.push;

    var indexOf = arr.indexOf;

    var class2type = {};

    var toString = class2type.toString;

    var hasOwn = class2type.hasOwnProperty;

    var fnToString = hasOwn.toString;

    var ObjectFunctionString = fnToString.call( Object );

    var support = {};

    var isFunction = function isFunction( obj ) {

        // Support: Chrome <=57, Firefox <=52
        // In some browsers, typeof returns "function" for HTML <object> elements
        // (i.e., `typeof document.createElement( "object" ) === "function"`).
        // We don't want to classify *any* DOM node as a function.
        return typeof obj === "function" && typeof obj.nodeType !== "number";
    };


    var isWindow = function isWindow( obj ) {
        return obj != null && obj === obj.window;
    };


    var document = window.document;



    var preservedScriptAttributes = {
        type: true,
        src: true,
        nonce: true,
        noModule: true
    };

    function DOMEval( code, node, doc ) {
        doc = doc || document;

        var i, val,
            script = doc.createElement( "script" );

        script.text = code;
        if ( node ) {
            for ( i in preservedScriptAttributes ) {

                // Support: Firefox 64+, Edge 18+
                // Some browsers don't support the "nonce" property on scripts.
                // On the other hand, just using `getAttribute` is not enough as
                // the `nonce` attribute is reset to an empty string whenever it
                // becomes browsing-context connected.
                // See https://github.com/whatwg/html/issues/2369
                // See https://html.spec.whatwg.org/#nonce-attributes
                // The `node.getAttribute` check was added for the sake of
                // `jQuery.globalEval` so that it can fake a nonce-containing node
                // via an object.
                val = node[ i ] || node.getAttribute && node.getAttribute( i );
                if ( val ) {
                    script.setAttribute( i, val );
                }
            }
        }
        doc.head.appendChild( script ).parentNode.removeChild( script );
    }


    function toType( obj ) {
        if ( obj == null ) {
            return obj + "";
        }

        // Support: Android <=2.3 only (functionish RegExp)
        return typeof obj === "object" || typeof obj === "function" ?
            class2type[ toString.call( obj ) ] || "object" :
            typeof obj;
    }
    /* global Symbol */
    // Defining this global in .eslintrc.json would create a danger of using the global
    // unguarded in another place, it seems safer to define global only for this module



    var
        version = "3.5.1",

        // Define a local copy of jQuery
        jQuery = function( selector, context ) {

            // The jQuery object is actually just the init constructor 'enhanced'
            // Need init if jQuery is called (just allow error to be thrown if not included)
            return new jQuery.fn.init( selector, context );
        };

    jQuery.fn = jQuery.prototype = {

        // The current version of jQuery being used
        jquery: version,

        constructor: jQuery,

        // The default length of a jQuery object is 0
        length: 0,

        toArray: function() {
            return slice.call( this );
        },

        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function( num ) {

            // Return all the elements in a clean array
            if ( num == null ) {
                return slice.call( this );
            }

            // Return just the one element from the set
            return num < 0 ? this[ num + this.length ] : this[ num ];
        },

        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function( elems ) {

            // Build a new jQuery matched element set
            var ret = jQuery.merge( this.constructor(), elems );

            // Add the old object onto the stack (as a reference)
            ret.prevObject = this;

            // Return the newly-formed element set
            return ret;
        },

        // Execute a callback for every element in the matched set.
        each: function( callback ) {
            return jQuery.each( this, callback );
        },

        map: function( callback ) {
            return this.pushStack( jQuery.map( this, function( elem, i ) {
                return callback.call( elem, i, elem );
            } ) );
        },

        slice: function() {
            return this.pushStack( slice.apply( this, arguments ) );
        },

        first: function() {
            return this.eq( 0 );
        },

        last: function() {
            return this.eq( -1 );
        },

        even: function() {
            return this.pushStack( jQuery.grep( this, function( _elem, i ) {
                return ( i + 1 ) % 2;
            } ) );
        },

        odd: function() {
            return this.pushStack( jQuery.grep( this, function( _elem, i ) {
                return i % 2;
            } ) );
        },

        eq: function( i ) {
            var len = this.length,
                j = +i + ( i < 0 ? len : 0 );
            return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
        },

        end: function() {
            return this.prevObject || this.constructor();
        },

        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push: push,
        sort: arr.sort,
        splice: arr.splice
    };

    jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone,
            target = arguments[ 0 ] || {},
            i = 1,
            length = arguments.length,
            deep = false;

        // Handle a deep copy situation
        if ( typeof target === "boolean" ) {
            deep = target;

            // Skip the boolean and the target
            target = arguments[ i ] || {};
            i++;
        }

        // Handle case when target is a string or something (possible in deep copy)
        if ( typeof target !== "object" && !isFunction( target ) ) {
            target = {};
        }

        // Extend jQuery itself if only one argument is passed
        if ( i === length ) {
            target = this;
            i--;
        }

        for ( ; i < length; i++ ) {

            // Only deal with non-null/undefined values
            if ( ( options = arguments[ i ] ) != null ) {

                // Extend the base object
                for ( name in options ) {
                    copy = options[ name ];

                    // Prevent Object.prototype pollution
                    // Prevent never-ending loop
                    if ( name === "__proto__" || target === copy ) {
                        continue;
                    }

                    // Recurse if we're merging plain objects or arrays
                    if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
                        src = target[ name ];

                        // Ensure proper type for the source value
                        if ( copyIsArray && !Array.isArray( src ) ) {
                            clone = [];
                        } else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
                            clone = {};
                        } else {
                            clone = src;
                        }
                        copyIsArray = false;

                        // Never move original objects, clone them
                        target[ name ] = jQuery.extend( deep, clone, copy );

                        // Don't bring in undefined values
                    } else if ( copy !== undefined ) {
                        target[ name ] = copy;
                    }
                }
            }
        }

        // Return the modified object
        return target;
    };

    jQuery.extend( {

        // Unique for each copy of jQuery on the page
        expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

        // Assume jQuery is ready without the ready module
        isReady: true,

        error: function( msg ) {
            throw new Error( msg );
        },

        noop: function() {},

        isPlainObject: function( obj ) {
            var proto, Ctor;

            // Detect obvious negatives
            // Use toString instead of jQuery.type to catch host objects
            if ( !obj || toString.call( obj ) !== "[object Object]" ) {
                return false;
            }

            proto = getProto( obj );

            // Objects with no prototype (e.g., `Object.create( null )`) are plain
            if ( !proto ) {
                return true;
            }

            // Objects with prototype are plain iff they were constructed by a global Object function
            Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
            return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
        },

        isEmptyObject: function( obj ) {
            var name;

            for ( name in obj ) {
                return false;
            }
            return true;
        },

        // Evaluates a script in a provided context; falls back to the global one
        // if not specified.
        globalEval: function( code, options, doc ) {
            DOMEval( code, { nonce: options && options.nonce }, doc );
        },

        each: function( obj, callback ) {
            var length, i = 0;

            if ( isArrayLike( obj ) ) {
                length = obj.length;
                for ( ; i < length; i++ ) {
                    if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
                        break;
                    }
                }
            } else {
                for ( i in obj ) {
                    if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
                        break;
                    }
                }
            }

            return obj;
        },

        // results is for internal usage only
        makeArray: function( arr, results ) {
            var ret = results || [];

            if ( arr != null ) {
                if ( isArrayLike( Object( arr ) ) ) {
                    jQuery.merge( ret,
                        typeof arr === "string" ?
                            [ arr ] : arr
                    );
                } else {
                    push.call( ret, arr );
                }
            }

            return ret;
        },

        inArray: function( elem, arr, i ) {
            return arr == null ? -1 : indexOf.call( arr, elem, i );
        },

        // Support: Android <=4.0 only, PhantomJS 1 only
        // push.apply(_, arraylike) throws on ancient WebKit
        merge: function( first, second ) {
            var len = +second.length,
                j = 0,
                i = first.length;

            for ( ; j < len; j++ ) {
                first[ i++ ] = second[ j ];
            }

            first.length = i;

            return first;
        },

        grep: function( elems, callback, invert ) {
            var callbackInverse,
                matches = [],
                i = 0,
                length = elems.length,
                callbackExpect = !invert;

            // Go through the array, only saving the items
            // that pass the validator function
            for ( ; i < length; i++ ) {
                callbackInverse = !callback( elems[ i ], i );
                if ( callbackInverse !== callbackExpect ) {
                    matches.push( elems[ i ] );
                }
            }

            return matches;
        },

        // arg is for internal usage only
        map: function( elems, callback, arg ) {
            var length, value,
                i = 0,
                ret = [];

            // Go through the array, translating each of the items to their new values
            if ( isArrayLike( elems ) ) {
                length = elems.length;
                for ( ; i < length; i++ ) {
                    value = callback( elems[ i ], i, arg );

                    if ( value != null ) {
                        ret.push( value );
                    }
                }

                // Go through every key on the object,
            } else {
                for ( i in elems ) {
                    value = callback( elems[ i ], i, arg );

                    if ( value != null ) {
                        ret.push( value );
                    }
                }
            }

            // Flatten any nested arrays
            return flat( ret );
        },

        // A global GUID counter for objects
        guid: 1,

        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support: support
    } );

    if ( typeof Symbol === "function" ) {
        jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
    }

    // Populate the class2type map
    jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
        function( _i, name ) {
            class2type[ "[object " + name + "]" ] = name.toLowerCase();
        } );

    function isArrayLike( obj ) {

        // Support: real iOS 8.2 only (not reproducible in simulator)
        // `in` check used to prevent JIT error (gh-2145)
        // hasOwn isn't used here due to false negatives
        // regarding Nodelist length in IE
        var length = !!obj && "length" in obj && obj.length,
            type = toType( obj );

        if ( isFunction( obj ) || isWindow( obj ) ) {
            return false;
        }

        return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
    }
    var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.5
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2020-03-14
 */
( function( window ) {
    var i,
        support,
        Expr,
        getText,
        isXML,
        tokenize,
        compile,
        select,
        outermostContext,
        sortInput,
        hasDuplicate,

        // Local document vars
        setDocument,
        document,
        docElem,
        documentIsHTML,
        rbuggyQSA,
        rbuggyMatches,
        matches,
        contains,

        // Instance-specific data
        expando = "sizzle" + 1 * new Date(),
        preferredDoc = window.document,
        dirruns = 0,
        done = 0,
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        nonnativeSelectorCache = createCache(),
        sortOrder = function( a, b ) {
            if ( a === b ) {
                hasDuplicate = true;
            }
            return 0;
        },

        // Instance methods
        hasOwn = ( {} ).hasOwnProperty,
        arr = [],
        pop = arr.pop,
        pushNative = arr.push,
        push = arr.push,
        slice = arr.slice,

        // Use a stripped-down indexOf as it's faster than native
        // https://jsperf.com/thor-indexof-vs-for/5
        indexOf = function( list, elem ) {
            var i = 0,
                len = list.length;
            for ( ; i < len; i++ ) {
                if ( list[ i ] === elem ) {
                    return i;
                }
            }
            return -1;
        },

        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" +
		"ismap|loop|multiple|open|readonly|required|scoped",

        // Regular expressions

        // http://www.w3.org/TR/css3-selectors/#whitespace
        whitespace = "[\\x20\\t\\r\\n\\f]",

        // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
        identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
        attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5]
		// or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

        pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
        rwhitespace = new RegExp( whitespace + "+", "g" ),
        rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" +
		whitespace + "+$", "g" ),

        rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
        rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace +
		"*" ),
        rdescend = new RegExp( whitespace + "|>" ),

        rpseudo = new RegExp( pseudos ),
        ridentifier = new RegExp( "^" + identifier + "$" ),

        matchExpr = {
            "ID": new RegExp( "^#(" + identifier + ")" ),
            "CLASS": new RegExp( "^\\.(" + identifier + ")" ),
            "TAG": new RegExp( "^(" + identifier + "|[*])" ),
            "ATTR": new RegExp( "^" + attributes ),
            "PSEUDO": new RegExp( "^" + pseudos ),
            "CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
			whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
			whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
            "bool": new RegExp( "^(?:" + booleans + ")$", "i" ),

            // For use in libraries implementing .is()
            // We use this for POS matching in `select`
            "needsContext": new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
        },

        rhtml = /HTML$/i,
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,

        rnative = /^[^{]+\{\s*\[native \w/,

        // Easily-parseable/retrievable ID or TAG or CLASS selectors
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

        rsibling = /[+~]/,

        // CSS escapes
        // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
        runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g" ),
        funescape = function( escape, nonHex ) {
            var high = "0x" + escape.slice( 1 ) - 0x10000;

            return nonHex ?

            // Strip the backslash prefix from a non-hex escape sequence
                nonHex :

            // Replace a hexadecimal escape sequence with the encoded Unicode code point
            // Support: IE <=11+
            // For values outside the Basic Multilingual Plane (BMP), manually construct a
            // surrogate pair
                high < 0 ?
                    String.fromCharCode( high + 0x10000 ) :
                    String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
        },

        // CSS string/identifier serialization
        // https://drafts.csswg.org/cssom/#common-serializing-idioms
        rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
        fcssescape = function( ch, asCodePoint ) {
            if ( asCodePoint ) {

                // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
                if ( ch === "\0" ) {
                    return "\uFFFD";
                }

                // Control characters and (dependent upon position) numbers get escaped as code points
                return ch.slice( 0, -1 ) + "\\" +
				ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
            }

            // Other potentially-special ASCII characters get backslash-escaped
            return "\\" + ch;
        },

        // Used for iframes
        // See setDocument()
        // Removing the function wrapper causes a "Permission Denied"
        // error in IE
        unloadHandler = function() {
            setDocument();
        },

        inDisabledFieldset = addCombinator(
            function( elem ) {
                return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
            },
            { dir: "parentNode", next: "legend" }
        );

    // Optimize for push.apply( _, NodeList )
    try {
        push.apply(
            ( arr = slice.call( preferredDoc.childNodes ) ),
            preferredDoc.childNodes
        );

        // Support: Android<4.0
        // Detect silently failing push.apply
        // eslint-disable-next-line no-unused-expressions
        arr[ preferredDoc.childNodes.length ].nodeType;
    } catch ( e ) {
        push = { apply: arr.length ?

        // Leverage slice if possible
            function( target, els ) {
                pushNative.apply( target, slice.call( els ) );
            } :

        // Support: IE<9
        // Otherwise append directly
            function( target, els ) {
                var j = target.length,
                    i = 0;

                // Can't trust NodeList.length
                while ( ( target[ j++ ] = els[ i++ ] ) ) {}
                target.length = j - 1;
            }
        };
    }

    function Sizzle( selector, context, results, seed ) {
        var m, i, elem, nid, match, groups, newSelector,
            newContext = context && context.ownerDocument,

            // nodeType defaults to 9, since context defaults to document
            nodeType = context ? context.nodeType : 9;

        results = results || [];

        // Return early from calls with invalid selector or context
        if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

            return results;
        }

        // Try to shortcut find operations (as opposed to filters) in HTML documents
        if ( !seed ) {
            setDocument( context );
            context = context || document;

            if ( documentIsHTML ) {

                // If the selector is sufficiently simple, try using a "get*By*" DOM method
                // (excepting DocumentFragment context, where the methods don't exist)
                if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

                    // ID selector
                    if ( ( m = match[ 1 ] ) ) {

                        // Document context
                        if ( nodeType === 9 ) {
                            if ( ( elem = context.getElementById( m ) ) ) {

                                // Support: IE, Opera, Webkit
                                // TODO: identify versions
                                // getElementById can match elements by name instead of ID
                                if ( elem.id === m ) {
                                    results.push( elem );
                                    return results;
                                }
                            } else {
                                return results;
                            }

                            // Element context
                        } else {

                            // Support: IE, Opera, Webkit
                            // TODO: identify versions
                            // getElementById can match elements by name instead of ID
                            if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							contains( context, elem ) &&
							elem.id === m ) {

                                results.push( elem );
                                return results;
                            }
                        }

                        // Type selector
                    } else if ( match[ 2 ] ) {
                        push.apply( results, context.getElementsByTagName( selector ) );
                        return results;

                        // Class selector
                    } else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

                        push.apply( results, context.getElementsByClassName( m ) );
                        return results;
                    }
                }

                // Take advantage of querySelectorAll
                if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&

				// Support: IE 8 only
				// Exclude object elements
				( nodeType !== 1 || context.nodeName.toLowerCase() !== "object" ) ) {

                    newSelector = selector;
                    newContext = context;

                    // qSA considers elements outside a scoping root when evaluating child or
                    // descendant combinators, which is not what we want.
                    // In such cases, we work around the behavior by prefixing every selector in the
                    // list with an ID selector referencing the scope context.
                    // The technique has to be used as well when a leading combinator is used
                    // as such selectors are not recognized by querySelectorAll.
                    // Thanks to Andrew Dupont for this technique.
                    if ( nodeType === 1 &&
					( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {

                        // Expand context for sibling selectors
                        newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

                        // We can use :scope instead of the ID hack if the browser
                        // supports it & if we're not changing the context.
                        if ( newContext !== context || !support.scope ) {

                            // Capture the context ID, setting it first if necessary
                            if ( ( nid = context.getAttribute( "id" ) ) ) {
                                nid = nid.replace( rcssescape, fcssescape );
                            } else {
                                context.setAttribute( "id", ( nid = expando ) );
                            }
                        }

                        // Prefix every selector in the list
                        groups = tokenize( selector );
                        i = groups.length;
                        while ( i-- ) {
                            groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
                        }
                        newSelector = groups.join( "," );
                    }

                    try {
                        push.apply( results,
                            newContext.querySelectorAll( newSelector )
                        );
                        return results;
                    } catch ( qsaError ) {
                        nonnativeSelectorCache( selector, true );
                    } finally {
                        if ( nid === expando ) {
                            context.removeAttribute( "id" );
                        }
                    }
                }
            }
        }

        // All others
        return select( selector.replace( rtrim, "$1" ), context, results, seed );
    }

    /**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
    function createCache() {
        var keys = [];

        function cache( key, value ) {

            // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
            if ( keys.push( key + " " ) > Expr.cacheLength ) {

                // Only keep the most recent entries
                delete cache[ keys.shift() ];
            }
            return ( cache[ key + " " ] = value );
        }
        return cache;
    }

    /**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
    function markFunction( fn ) {
        fn[ expando ] = true;
        return fn;
    }

    /**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
    function assert( fn ) {
        var el = document.createElement( "fieldset" );

        try {
            return !!fn( el );
        } catch ( e ) {
            return false;
        } finally {

            // Remove from its parent by default
            if ( el.parentNode ) {
                el.parentNode.removeChild( el );
            }

            // release memory in IE
            el = null;
        }
    }

    /**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
    function addHandle( attrs, handler ) {
        var arr = attrs.split( "|" ),
            i = arr.length;

        while ( i-- ) {
            Expr.attrHandle[ arr[ i ] ] = handler;
        }
    }

    /**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
    function siblingCheck( a, b ) {
        var cur = b && a,
            diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

        // Use IE sourceIndex if available on both nodes
        if ( diff ) {
            return diff;
        }

        // Check if b follows a
        if ( cur ) {
            while ( ( cur = cur.nextSibling ) ) {
                if ( cur === b ) {
                    return -1;
                }
            }
        }

        return a ? 1 : -1;
    }

    /**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
    function createInputPseudo( type ) {
        return function( elem ) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === type;
        };
    }

    /**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
    function createButtonPseudo( type ) {
        return function( elem ) {
            var name = elem.nodeName.toLowerCase();
            return ( name === "input" || name === "button" ) && elem.type === type;
        };
    }

    /**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
    function createDisabledPseudo( disabled ) {

        // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
        return function( elem ) {

            // Only certain elements can match :enabled or :disabled
            // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
            // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
            if ( "form" in elem ) {

                // Check for inherited disabledness on relevant non-disabled elements:
                // * listed form-associated elements in a disabled fieldset
                //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
                //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
                // * option elements in a disabled optgroup
                //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
                // All such elements have a "form" property.
                if ( elem.parentNode && elem.disabled === false ) {

                    // Option elements defer to a parent optgroup if present
                    if ( "label" in elem ) {
                        if ( "label" in elem.parentNode ) {
                            return elem.parentNode.disabled === disabled;
                        } else {
                            return elem.disabled === disabled;
                        }
                    }

                    // Support: IE 6 - 11
                    // Use the isDisabled shortcut property to check for disabled fieldset ancestors
                    return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
					inDisabledFieldset( elem ) === disabled;
                }

                return elem.disabled === disabled;

                // Try to winnow out elements that can't be disabled before trusting the disabled property.
                // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
                // even exist on them, let alone have a boolean value.
            } else if ( "label" in elem ) {
                return elem.disabled === disabled;
            }

            // Remaining elements are neither :enabled nor :disabled
            return false;
        };
    }

    /**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
    function createPositionalPseudo( fn ) {
        return markFunction( function( argument ) {
            argument = +argument;
            return markFunction( function( seed, matches ) {
                var j,
                    matchIndexes = fn( [], seed.length, argument ),
                    i = matchIndexes.length;

                // Match elements found at the specified indexes
                while ( i-- ) {
                    if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
                        seed[ j ] = !( matches[ j ] = seed[ j ] );
                    }
                }
            } );
        } );
    }

    /**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
    function testContext( context ) {
        return context && typeof context.getElementsByTagName !== "undefined" && context;
    }

    // Expose support vars for convenience
    support = Sizzle.support = {};

    /**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
    isXML = Sizzle.isXML = function( elem ) {
        var namespace = elem.namespaceURI,
            docElem = ( elem.ownerDocument || elem ).documentElement;

        // Support: IE <=8
        // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
        // https://bugs.jquery.com/ticket/4833
        return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
    };

    /**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
    setDocument = Sizzle.setDocument = function( node ) {
        var hasCompare, subWindow,
            doc = node ? node.ownerDocument || node : preferredDoc;

        // Return early if doc is invalid or already selected
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        // eslint-disable-next-line eqeqeq
        if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
            return document;
        }

        // Update global variables
        document = doc;
        docElem = document.documentElement;
        documentIsHTML = !isXML( document );

        // Support: IE 9 - 11+, Edge 12 - 18+
        // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        // eslint-disable-next-line eqeqeq
        if ( preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

            // Support: IE 11, Edge
            if ( subWindow.addEventListener ) {
                subWindow.addEventListener( "unload", unloadHandler, false );

                // Support: IE 9 - 10 only
            } else if ( subWindow.attachEvent ) {
                subWindow.attachEvent( "onunload", unloadHandler );
            }
        }

        // Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
        // Safari 4 - 5 only, Opera <=11.6 - 12.x only
        // IE/Edge & older browsers don't support the :scope pseudo-class.
        // Support: Safari 6.0 only
        // Safari 6.0 supports :scope but it's an alias of :root there.
        support.scope = assert( function( el ) {
            docElem.appendChild( el ).appendChild( document.createElement( "div" ) );
            return typeof el.querySelectorAll !== "undefined" &&
			!el.querySelectorAll( ":scope fieldset div" ).length;
        } );

        /* Attributes
	---------------------------------------------------------------------- */

        // Support: IE<8
        // Verify that getAttribute really returns attributes and not properties
        // (excepting IE8 booleans)
        support.attributes = assert( function( el ) {
            el.className = "i";
            return !el.getAttribute( "className" );
        } );

        /* getElement(s)By*
	---------------------------------------------------------------------- */

        // Check if getElementsByTagName("*") returns only elements
        support.getElementsByTagName = assert( function( el ) {
            el.appendChild( document.createComment( "" ) );
            return !el.getElementsByTagName( "*" ).length;
        } );

        // Support: IE<9
        support.getElementsByClassName = rnative.test( document.getElementsByClassName );

        // Support: IE<10
        // Check if getElementById returns elements by name
        // The broken getElementById methods don't pick up programmatically-set names,
        // so use a roundabout getElementsByName test
        support.getById = assert( function( el ) {
            docElem.appendChild( el ).id = expando;
            return !document.getElementsByName || !document.getElementsByName( expando ).length;
        } );

        // ID filter and find
        if ( support.getById ) {
            Expr.filter[ "ID" ] = function( id ) {
                var attrId = id.replace( runescape, funescape );
                return function( elem ) {
                    return elem.getAttribute( "id" ) === attrId;
                };
            };
            Expr.find[ "ID" ] = function( id, context ) {
                if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
                    var elem = context.getElementById( id );
                    return elem ? [ elem ] : [];
                }
            };
        } else {
            Expr.filter[ "ID" ] =  function( id ) {
                var attrId = id.replace( runescape, funescape );
                return function( elem ) {
                    var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
                    return node && node.value === attrId;
                };
            };

            // Support: IE 6 - 7 only
            // getElementById is not reliable as a find shortcut
            Expr.find[ "ID" ] = function( id, context ) {
                if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
                    var node, i, elems,
                        elem = context.getElementById( id );

                    if ( elem ) {

                        // Verify the id attribute
                        node = elem.getAttributeNode( "id" );
                        if ( node && node.value === id ) {
                            return [ elem ];
                        }

                        // Fall back on getElementsByName
                        elems = context.getElementsByName( id );
                        i = 0;
                        while ( ( elem = elems[ i++ ] ) ) {
                            node = elem.getAttributeNode( "id" );
                            if ( node && node.value === id ) {
                                return [ elem ];
                            }
                        }
                    }

                    return [];
                }
            };
        }

        // Tag
        Expr.find[ "TAG" ] = support.getElementsByTagName ?
            function( tag, context ) {
                if ( typeof context.getElementsByTagName !== "undefined" ) {
                    return context.getElementsByTagName( tag );

                    // DocumentFragment nodes don't have gEBTN
                } else if ( support.qsa ) {
                    return context.querySelectorAll( tag );
                }
            } :

            function( tag, context ) {
                var elem,
                    tmp = [],
                    i = 0,

                    // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                    results = context.getElementsByTagName( tag );

                // Filter out possible comments
                if ( tag === "*" ) {
                    while ( ( elem = results[ i++ ] ) ) {
                        if ( elem.nodeType === 1 ) {
                            tmp.push( elem );
                        }
                    }

                    return tmp;
                }
                return results;
            };

        // Class
        Expr.find[ "CLASS" ] = support.getElementsByClassName && function( className, context ) {
            if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
                return context.getElementsByClassName( className );
            }
        };

        /* QSA/matchesSelector
	---------------------------------------------------------------------- */

        // QSA and matchesSelector support

        // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
        rbuggyMatches = [];

        // qSa(:focus) reports false when true (Chrome 21)
        // We allow this because of a bug in IE8/9 that throws an error
        // whenever `document.activeElement` is accessed on an iframe
        // So, we allow :focus to pass through QSA all the time to avoid the IE error
        // See https://bugs.jquery.com/ticket/13378
        rbuggyQSA = [];

        if ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {

            // Build QSA regex
            // Regex strategy adopted from Diego Perini
            assert( function( el ) {

                var input;

                // Select is set to empty string on purpose
                // This is to test IE's treatment of not explicitly
                // setting a boolean content attribute,
                // since its presence should be enough
                // https://bugs.jquery.com/ticket/12359
                docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

                // Support: IE8, Opera 11-12.16
                // Nothing should be selected when empty strings follow ^= or $= or *=
                // The test attribute must be unknown in Opera but "safe" for WinRT
                // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                if ( el.querySelectorAll( "[msallowcapture^='']" ).length ) {
                    rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
                }

                // Support: IE8
                // Boolean attributes and "value" are not treated correctly
                if ( !el.querySelectorAll( "[selected]" ).length ) {
                    rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
                }

                // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
                if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
                    rbuggyQSA.push( "~=" );
                }

                // Support: IE 11+, Edge 15 - 18+
                // IE 11/Edge don't find elements on a `[name='']` query in some cases.
                // Adding a temporary attribute to the document before the selection works
                // around the issue.
                // Interestingly, IE 10 & older don't seem to have the issue.
                input = document.createElement( "input" );
                input.setAttribute( "name", "" );
                el.appendChild( input );
                if ( !el.querySelectorAll( "[name='']" ).length ) {
                    rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
					whitespace + "*(?:''|\"\")" );
                }

                // Webkit/Opera - :checked should return selected option elements
                // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                // IE8 throws error here and will not see later tests
                if ( !el.querySelectorAll( ":checked" ).length ) {
                    rbuggyQSA.push( ":checked" );
                }

                // Support: Safari 8+, iOS 8+
                // https://bugs.webkit.org/show_bug.cgi?id=136851
                // In-page `selector#id sibling-combinator selector` fails
                if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
                    rbuggyQSA.push( ".#.+[+~]" );
                }

                // Support: Firefox <=3.6 - 5 only
                // Old Firefox doesn't throw on a badly-escaped identifier.
                el.querySelectorAll( "\\\f" );
                rbuggyQSA.push( "[\\r\\n\\f]" );
            } );

            assert( function( el ) {
                el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

                // Support: Windows 8 Native Apps
                // The type and name attributes are restricted during .innerHTML assignment
                var input = document.createElement( "input" );
                input.setAttribute( "type", "hidden" );
                el.appendChild( input ).setAttribute( "name", "D" );

                // Support: IE8
                // Enforce case-sensitivity of name attribute
                if ( el.querySelectorAll( "[name=d]" ).length ) {
                    rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
                }

                // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                // IE8 throws error here and will not see later tests
                if ( el.querySelectorAll( ":enabled" ).length !== 2 ) {
                    rbuggyQSA.push( ":enabled", ":disabled" );
                }

                // Support: IE9-11+
                // IE's :disabled selector does not pick up the children of disabled fieldsets
                docElem.appendChild( el ).disabled = true;
                if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
                    rbuggyQSA.push( ":enabled", ":disabled" );
                }

                // Support: Opera 10 - 11 only
                // Opera 10-11 does not throw on post-comma invalid pseudos
                el.querySelectorAll( "*,:x" );
                rbuggyQSA.push( ",.*:" );
            } );
        }

        if ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector ) ) ) ) {

            assert( function( el ) {

                // Check to see if it's possible to do matchesSelector
                // on a disconnected node (IE 9)
                support.disconnectedMatch = matches.call( el, "*" );

                // This should fail with an exception
                // Gecko does not error, returns false instead
                matches.call( el, "[s!='']:x" );
                rbuggyMatches.push( "!=", pseudos );
            } );
        }

        rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );
        rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( "|" ) );

        /* Contains
	---------------------------------------------------------------------- */
        hasCompare = rnative.test( docElem.compareDocumentPosition );

        // Element contains another
        // Purposefully self-exclusive
        // As in, an element does not contain itself
        contains = hasCompare || rnative.test( docElem.contains ) ?
            function( a, b ) {
                var adown = a.nodeType === 9 ? a.documentElement : a,
                    bup = b && b.parentNode;
                return a === bup || !!( bup && bup.nodeType === 1 && (
                    adown.contains ?
                        adown.contains( bup ) :
                        a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
                ) );
            } :
            function( a, b ) {
                if ( b ) {
                    while ( ( b = b.parentNode ) ) {
                        if ( b === a ) {
                            return true;
                        }
                    }
                }
                return false;
            };

        /* Sorting
	---------------------------------------------------------------------- */

        // Document order sorting
        sortOrder = hasCompare ?
            function( a, b ) {

                // Flag for duplicate removal
                if ( a === b ) {
                    hasDuplicate = true;
                    return 0;
                }

                // Sort on method existence if only one input has compareDocumentPosition
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                if ( compare ) {
                    return compare;
                }

                // Calculate position if both inputs belong to the same document
                // Support: IE 11+, Edge 17 - 18+
                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                // two documents; shallow comparisons work.
                // eslint-disable-next-line eqeqeq
                compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
                    a.compareDocumentPosition( b ) :

                // Otherwise we know they are disconnected
                    1;

                // Disconnected nodes
                if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

                    // Choose the first element that is related to our preferred document
                    // Support: IE 11+, Edge 17 - 18+
                    // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                    // two documents; shallow comparisons work.
                    // eslint-disable-next-line eqeqeq
                    if ( a == document || a.ownerDocument == preferredDoc &&
				contains( preferredDoc, a ) ) {
                        return -1;
                    }

                    // Support: IE 11+, Edge 17 - 18+
                    // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                    // two documents; shallow comparisons work.
                    // eslint-disable-next-line eqeqeq
                    if ( b == document || b.ownerDocument == preferredDoc &&
				contains( preferredDoc, b ) ) {
                        return 1;
                    }

                    // Maintain original order
                    return sortInput ?
                        ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
                        0;
                }

                return compare & 4 ? -1 : 1;
            } :
            function( a, b ) {

                // Exit early if the nodes are identical
                if ( a === b ) {
                    hasDuplicate = true;
                    return 0;
                }

                var cur,
                    i = 0,
                    aup = a.parentNode,
                    bup = b.parentNode,
                    ap = [ a ],
                    bp = [ b ];

                // Parentless nodes are either documents or disconnected
                if ( !aup || !bup ) {

                    // Support: IE 11+, Edge 17 - 18+
                    // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                    // two documents; shallow comparisons work.
                    /* eslint-disable eqeqeq */
                    return a == document ? -1 :
                        b == document ? 1 :
                        /* eslint-enable eqeqeq */
                            aup ? -1 :
                                bup ? 1 :
                                    sortInput ?
                                        ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
                                        0;

                    // If the nodes are siblings, we can do a quick check
                } else if ( aup === bup ) {
                    return siblingCheck( a, b );
                }

                // Otherwise we need full lists of their ancestors for comparison
                cur = a;
                while ( ( cur = cur.parentNode ) ) {
                    ap.unshift( cur );
                }
                cur = b;
                while ( ( cur = cur.parentNode ) ) {
                    bp.unshift( cur );
                }

                // Walk down the tree looking for a discrepancy
                while ( ap[ i ] === bp[ i ] ) {
                    i++;
                }

                return i ?

                // Do a sibling check if the nodes have a common ancestor
                    siblingCheck( ap[ i ], bp[ i ] ) :

                // Otherwise nodes in our document sort first
                // Support: IE 11+, Edge 17 - 18+
                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                // two documents; shallow comparisons work.
                /* eslint-disable eqeqeq */
                    ap[ i ] == preferredDoc ? -1 :
                        bp[ i ] == preferredDoc ? 1 :
                        /* eslint-enable eqeqeq */
                            0;
            };

        return document;
    };

    Sizzle.matches = function( expr, elements ) {
        return Sizzle( expr, null, null, elements );
    };

    Sizzle.matchesSelector = function( elem, expr ) {
        setDocument( elem );

        if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

            try {
                var ret = matches.call( elem, expr );

                // IE 9's matchesSelector returns false on disconnected nodes
                if ( ret || support.disconnectedMatch ||

				// As well, disconnected nodes are said to be in a document
				// fragment in IE 9
				elem.document && elem.document.nodeType !== 11 ) {
                    return ret;
                }
            } catch ( e ) {
                nonnativeSelectorCache( expr, true );
            }
        }

        return Sizzle( expr, document, null, [ elem ] ).length > 0;
    };

    Sizzle.contains = function( context, elem ) {

        // Set document vars if needed
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        // eslint-disable-next-line eqeqeq
        if ( ( context.ownerDocument || context ) != document ) {
            setDocument( context );
        }
        return contains( context, elem );
    };

    Sizzle.attr = function( elem, name ) {

        // Set document vars if needed
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        // eslint-disable-next-line eqeqeq
        if ( ( elem.ownerDocument || elem ) != document ) {
            setDocument( elem );
        }

        var fn = Expr.attrHandle[ name.toLowerCase() ],

            // Don't get fooled by Object.prototype properties (jQuery #13807)
            val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
                fn( elem, name, !documentIsHTML ) :
                undefined;

        return val !== undefined ?
            val :
            support.attributes || !documentIsHTML ?
                elem.getAttribute( name ) :
                ( val = elem.getAttributeNode( name ) ) && val.specified ?
                    val.value :
                    null;
    };

    Sizzle.escape = function( sel ) {
        return ( sel + "" ).replace( rcssescape, fcssescape );
    };

    Sizzle.error = function( msg ) {
        throw new Error( "Syntax error, unrecognized expression: " + msg );
    };

    /**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
    Sizzle.uniqueSort = function( results ) {
        var elem,
            duplicates = [],
            j = 0,
            i = 0;

        // Unless we *know* we can detect duplicates, assume their presence
        hasDuplicate = !support.detectDuplicates;
        sortInput = !support.sortStable && results.slice( 0 );
        results.sort( sortOrder );

        if ( hasDuplicate ) {
            while ( ( elem = results[ i++ ] ) ) {
                if ( elem === results[ i ] ) {
                    j = duplicates.push( i );
                }
            }
            while ( j-- ) {
                results.splice( duplicates[ j ], 1 );
            }
        }

        // Clear input after sorting to release objects
        // See https://github.com/jquery/sizzle/pull/225
        sortInput = null;

        return results;
    };

    /**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
    getText = Sizzle.getText = function( elem ) {
        var node,
            ret = "",
            i = 0,
            nodeType = elem.nodeType;

        if ( !nodeType ) {

            // If no nodeType, this is expected to be an array
            while ( ( node = elem[ i++ ] ) ) {

                // Do not traverse comment nodes
                ret += getText( node );
            }
        } else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {

            // Use textContent for elements
            // innerText usage removed for consistency of new lines (jQuery #11153)
            if ( typeof elem.textContent === "string" ) {
                return elem.textContent;
            } else {

                // Traverse its children
                for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                    ret += getText( elem );
                }
            }
        } else if ( nodeType === 3 || nodeType === 4 ) {
            return elem.nodeValue;
        }

        // Do not include comment or processing instruction nodes

        return ret;
    };

    Expr = Sizzle.selectors = {

        // Can be adjusted by the user
        cacheLength: 50,

        createPseudo: markFunction,

        match: matchExpr,

        attrHandle: {},

        find: {},

        relative: {
            ">": { dir: "parentNode", first: true },
            " ": { dir: "parentNode" },
            "+": { dir: "previousSibling", first: true },
            "~": { dir: "previousSibling" }
        },

        preFilter: {
            "ATTR": function( match ) {
                match[ 1 ] = match[ 1 ].replace( runescape, funescape );

                // Move the given value to match[3] whether quoted or unquoted
                match[ 3 ] = ( match[ 3 ] || match[ 4 ] ||
				match[ 5 ] || "" ).replace( runescape, funescape );

                if ( match[ 2 ] === "~=" ) {
                    match[ 3 ] = " " + match[ 3 ] + " ";
                }

                return match.slice( 0, 4 );
            },

            "CHILD": function( match ) {

                /* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
                match[ 1 ] = match[ 1 ].toLowerCase();

                if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

                    // nth-* requires argument
                    if ( !match[ 3 ] ) {
                        Sizzle.error( match[ 0 ] );
                    }

                    // numeric x and y parameters for Expr.filter.CHILD
                    // remember that false/true cast respectively to 0/1
                    match[ 4 ] = +( match[ 4 ] ?
                        match[ 5 ] + ( match[ 6 ] || 1 ) :
                        2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" ) );
                    match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

                    // other types prohibit arguments
                } else if ( match[ 3 ] ) {
                    Sizzle.error( match[ 0 ] );
                }

                return match;
            },

            "PSEUDO": function( match ) {
                var excess,
                    unquoted = !match[ 6 ] && match[ 2 ];

                if ( matchExpr[ "CHILD" ].test( match[ 0 ] ) ) {
                    return null;
                }

                // Accept quoted arguments as-is
                if ( match[ 3 ] ) {
                    match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

                    // Strip excess characters from unquoted arguments
                } else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

                    // excess is a negative index
                    match[ 0 ] = match[ 0 ].slice( 0, excess );
                    match[ 2 ] = unquoted.slice( 0, excess );
                }

                // Return only captures needed by the pseudo filter method (type and argument)
                return match.slice( 0, 3 );
            }
        },

        filter: {

            "TAG": function( nodeNameSelector ) {
                var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
                return nodeNameSelector === "*" ?
                    function() {
                        return true;
                    } :
                    function( elem ) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
            },

            "CLASS": function( className ) {
                var pattern = classCache[ className + " " ];

                return pattern ||
				( pattern = new RegExp( "(^|" + whitespace +
					")" + className + "(" + whitespace + "|$)" ) ) && classCache(
				    className, function( elem ) {
				        return pattern.test(
				            typeof elem.className === "string" && elem.className ||
								typeof elem.getAttribute !== "undefined" &&
									elem.getAttribute( "class" ) ||
								""
				        );
				    } );
            },

            "ATTR": function( name, operator, check ) {
                return function( elem ) {
                    var result = Sizzle.attr( elem, name );

                    if ( result == null ) {
                        return operator === "!=";
                    }
                    if ( !operator ) {
                        return true;
                    }

                    result += "";

                    /* eslint-disable max-len */

                    return operator === "=" ? result === check :
                        operator === "!=" ? result !== check :
                            operator === "^=" ? check && result.indexOf( check ) === 0 :
                                operator === "*=" ? check && result.indexOf( check ) > -1 :
                                    operator === "$=" ? check && result.slice( -check.length ) === check :
                                        operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
                                            operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
                                                false;
                    /* eslint-enable max-len */

                };
            },

            "CHILD": function( type, what, _argument, first, last ) {
                var simple = type.slice( 0, 3 ) !== "nth",
                    forward = type.slice( -4 ) !== "last",
                    ofType = what === "of-type";

                return first === 1 && last === 0 ?

                // Shortcut for :nth-*(n)
                    function( elem ) {
                        return !!elem.parentNode;
                    } :

                    function( elem, _context, xml ) {
                        var cache, uniqueCache, outerCache, node, nodeIndex, start,
                            dir = simple !== forward ? "nextSibling" : "previousSibling",
                            parent = elem.parentNode,
                            name = ofType && elem.nodeName.toLowerCase(),
                            useCache = !xml && !ofType,
                            diff = false;

                        if ( parent ) {

                            // :(first|last|only)-(child|of-type)
                            if ( simple ) {
                                while ( dir ) {
                                    node = elem;
                                    while ( ( node = node[ dir ] ) ) {
                                        if ( ofType ?
                                            node.nodeName.toLowerCase() === name :
                                            node.nodeType === 1 ) {

                                            return false;
                                        }
                                    }

                                    // Reverse direction for :only-* (if we haven't yet done so)
                                    start = dir = type === "only" && !start && "nextSibling";
                                }
                                return true;
                            }

                            start = [ forward ? parent.firstChild : parent.lastChild ];

                            // non-xml :nth-child(...) stores cache data on `parent`
                            if ( forward && useCache ) {

                                // Seek `elem` from a previously-cached index

                                // ...in a gzip-friendly way
                                node = parent;
                                outerCache = node[ expando ] || ( node[ expando ] = {} );

                                // Support: IE <9 only
                                // Defend against cloned attroperties (jQuery gh-1709)
                                uniqueCache = outerCache[ node.uniqueID ] ||
								( outerCache[ node.uniqueID ] = {} );

                                cache = uniqueCache[ type ] || [];
                                nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
                                diff = nodeIndex && cache[ 2 ];
                                node = nodeIndex && parent.childNodes[ nodeIndex ];

                                while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

                                    // When found, cache indexes on `parent` and break
                                    if ( node.nodeType === 1 && ++diff && node === elem ) {
                                        uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
                                        break;
                                    }
                                }

                            } else {

                                // Use previously-cached element index if available
                                if ( useCache ) {

                                    // ...in a gzip-friendly way
                                    node = elem;
                                    outerCache = node[ expando ] || ( node[ expando ] = {} );

                                    // Support: IE <9 only
                                    // Defend against cloned attroperties (jQuery gh-1709)
                                    uniqueCache = outerCache[ node.uniqueID ] ||
									( outerCache[ node.uniqueID ] = {} );

                                    cache = uniqueCache[ type ] || [];
                                    nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
                                    diff = nodeIndex;
                                }

                                // xml :nth-child(...)
                                // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                if ( diff === false ) {

                                    // Use the same loop as above to seek `elem` from the start
                                    while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

                                        if ( ( ofType ?
                                            node.nodeName.toLowerCase() === name :
                                            node.nodeType === 1 ) &&
										++diff ) {

                                            // Cache the index of each encountered element
                                            if ( useCache ) {
                                                outerCache = node[ expando ] ||
												( node[ expando ] = {} );

                                                // Support: IE <9 only
                                                // Defend against cloned attroperties (jQuery gh-1709)
                                                uniqueCache = outerCache[ node.uniqueID ] ||
												( outerCache[ node.uniqueID ] = {} );

                                                uniqueCache[ type ] = [ dirruns, diff ];
                                            }

                                            if ( node === elem ) {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }

                            // Incorporate the offset, then check against cycle size
                            diff -= last;
                            return diff === first || ( diff % first === 0 && diff / first >= 0 );
                        }
                    };
            },

            "PSEUDO": function( pseudo, argument ) {

                // pseudo-class names are case-insensitive
                // http://www.w3.org/TR/selectors/#pseudo-classes
                // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                // Remember that setFilters inherits from pseudos
                var args,
                    fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

                // The user may use createPseudo to indicate that
                // arguments are needed to create the filter function
                // just as Sizzle does
                if ( fn[ expando ] ) {
                    return fn( argument );
                }

                // But maintain support for old signatures
                if ( fn.length > 1 ) {
                    args = [ pseudo, pseudo, "", argument ];
                    return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
                        markFunction( function( seed, matches ) {
                            var idx,
                                matched = fn( seed, argument ),
                                i = matched.length;
                            while ( i-- ) {
                                idx = indexOf( seed, matched[ i ] );
                                seed[ idx ] = !( matches[ idx ] = matched[ i ] );
                            }
                        } ) :
                        function( elem ) {
                            return fn( elem, 0, args );
                        };
                }

                return fn;
            }
        },

        pseudos: {

            // Potentially complex pseudos
            "not": markFunction( function( selector ) {

                // Trim the selector passed to compile
                // to avoid treating leading and trailing
                // spaces as combinators
                var input = [],
                    results = [],
                    matcher = compile( selector.replace( rtrim, "$1" ) );

                return matcher[ expando ] ?
                    markFunction( function( seed, matches, _context, xml ) {
                        var elem,
                            unmatched = matcher( seed, null, xml, [] ),
                            i = seed.length;

                        // Match elements unmatched by `matcher`
                        while ( i-- ) {
                            if ( ( elem = unmatched[ i ] ) ) {
                                seed[ i ] = !( matches[ i ] = elem );
                            }
                        }
                    } ) :
                    function( elem, _context, xml ) {
                        input[ 0 ] = elem;
                        matcher( input, null, xml, results );

                        // Don't keep the element (issue #299)
                        input[ 0 ] = null;
                        return !results.pop();
                    };
            } ),

            "has": markFunction( function( selector ) {
                return function( elem ) {
                    return Sizzle( selector, elem ).length > 0;
                };
            } ),

            "contains": markFunction( function( text ) {
                text = text.replace( runescape, funescape );
                return function( elem ) {
                    return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
                };
            } ),

            // "Whether an element is represented by a :lang() selector
            // is based solely on the element's language value
            // being equal to the identifier C,
            // or beginning with the identifier C immediately followed by "-".
            // The matching of C against the element's language value is performed case-insensitively.
            // The identifier C does not have to be a valid language name."
            // http://www.w3.org/TR/selectors/#lang-pseudo
            "lang": markFunction( function( lang ) {

                // lang value must be a valid identifier
                if ( !ridentifier.test( lang || "" ) ) {
                    Sizzle.error( "unsupported lang: " + lang );
                }
                lang = lang.replace( runescape, funescape ).toLowerCase();
                return function( elem ) {
                    var elemLang;
                    do {
                        if ( ( elemLang = documentIsHTML ?
                            elem.lang :
                            elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

                            elemLang = elemLang.toLowerCase();
                            return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
                        }
                    } while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
                    return false;
                };
            } ),

            // Miscellaneous
            "target": function( elem ) {
                var hash = window.location && window.location.hash;
                return hash && hash.slice( 1 ) === elem.id;
            },

            "root": function( elem ) {
                return elem === docElem;
            },

            "focus": function( elem ) {
                return elem === document.activeElement &&
				( !document.hasFocus || document.hasFocus() ) &&
				!!( elem.type || elem.href || ~elem.tabIndex );
            },

            // Boolean properties
            "enabled": createDisabledPseudo( false ),
            "disabled": createDisabledPseudo( true ),

            "checked": function( elem ) {

                // In CSS3, :checked should return both checked and selected elements
                // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                var nodeName = elem.nodeName.toLowerCase();
                return ( nodeName === "input" && !!elem.checked ) ||
				( nodeName === "option" && !!elem.selected );
            },

            "selected": function( elem ) {

                // Accessing this property makes selected-by-default
                // options in Safari work properly
                if ( elem.parentNode ) {
                    // eslint-disable-next-line no-unused-expressions
                    elem.parentNode.selectedIndex;
                }

                return elem.selected === true;
            },

            // Contents
            "empty": function( elem ) {

                // http://www.w3.org/TR/selectors/#empty-pseudo
                // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                //   but not by others (comment: 8; processing instruction: 7; etc.)
                // nodeType < 6 works because attributes (2) do not appear as children
                for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                    if ( elem.nodeType < 6 ) {
                        return false;
                    }
                }
                return true;
            },

            "parent": function( elem ) {
                return !Expr.pseudos[ "empty" ]( elem );
            },

            // Element/input types
            "header": function( elem ) {
                return rheader.test( elem.nodeName );
            },

            "input": function( elem ) {
                return rinputs.test( elem.nodeName );
            },

            "button": function( elem ) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && elem.type === "button" || name === "button";
            },

            "text": function( elem ) {
                var attr;
                return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
            },

            // Position-in-collection
            "first": createPositionalPseudo( function() {
                return [ 0 ];
            } ),

            "last": createPositionalPseudo( function( _matchIndexes, length ) {
                return [ length - 1 ];
            } ),

            "eq": createPositionalPseudo( function( _matchIndexes, length, argument ) {
                return [ argument < 0 ? argument + length : argument ];
            } ),

            "even": createPositionalPseudo( function( matchIndexes, length ) {
                var i = 0;
                for ( ; i < length; i += 2 ) {
                    matchIndexes.push( i );
                }
                return matchIndexes;
            } ),

            "odd": createPositionalPseudo( function( matchIndexes, length ) {
                var i = 1;
                for ( ; i < length; i += 2 ) {
                    matchIndexes.push( i );
                }
                return matchIndexes;
            } ),

            "lt": createPositionalPseudo( function( matchIndexes, length, argument ) {
                var i = argument < 0 ?
                    argument + length :
                    argument > length ?
                        length :
                        argument;
                for ( ; --i >= 0; ) {
                    matchIndexes.push( i );
                }
                return matchIndexes;
            } ),

            "gt": createPositionalPseudo( function( matchIndexes, length, argument ) {
                var i = argument < 0 ? argument + length : argument;
                for ( ; ++i < length; ) {
                    matchIndexes.push( i );
                }
                return matchIndexes;
            } )
        }
    };

    Expr.pseudos[ "nth" ] = Expr.pseudos[ "eq" ];

    // Add button/input type pseudos
    for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
        Expr.pseudos[ i ] = createInputPseudo( i );
    }
    for ( i in { submit: true, reset: true } ) {
        Expr.pseudos[ i ] = createButtonPseudo( i );
    }

    // Easy API for creating new setFilters
    function setFilters() {}
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();

    tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
        var matched, match, tokens, type,
            soFar, groups, preFilters,
            cached = tokenCache[ selector + " " ];

        if ( cached ) {
            return parseOnly ? 0 : cached.slice( 0 );
        }

        soFar = selector;
        groups = [];
        preFilters = Expr.preFilter;

        while ( soFar ) {

            // Comma and first run
            if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
                if ( match ) {

                    // Don't consume trailing commas as valid
                    soFar = soFar.slice( match[ 0 ].length ) || soFar;
                }
                groups.push( ( tokens = [] ) );
            }

            matched = false;

            // Combinators
            if ( ( match = rcombinators.exec( soFar ) ) ) {
                matched = match.shift();
                tokens.push( {
                    value: matched,

                    // Cast descendant combinators to space
                    type: match[ 0 ].replace( rtrim, " " )
                } );
                soFar = soFar.slice( matched.length );
            }

            // Filters
            for ( type in Expr.filter ) {
                if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
                    matched = match.shift();
                    tokens.push( {
                        value: matched,
                        type: type,
                        matches: match
                    } );
                    soFar = soFar.slice( matched.length );
                }
            }

            if ( !matched ) {
                break;
            }
        }

        // Return the length of the invalid excess
        // if we're just parsing
        // Otherwise, throw an error or return tokens
        return parseOnly ?
            soFar.length :
            soFar ?
                Sizzle.error( selector ) :

            // Cache the tokens
                tokenCache( selector, groups ).slice( 0 );
    };

    function toSelector( tokens ) {
        var i = 0,
            len = tokens.length,
            selector = "";
        for ( ; i < len; i++ ) {
            selector += tokens[ i ].value;
        }
        return selector;
    }

    function addCombinator( matcher, combinator, base ) {
        var dir = combinator.dir,
            skip = combinator.next,
            key = skip || dir,
            checkNonElements = base && key === "parentNode",
            doneName = done++;

        return combinator.first ?

        // Check against closest ancestor/preceding element
            function( elem, context, xml ) {
                while ( ( elem = elem[ dir ] ) ) {
                    if ( elem.nodeType === 1 || checkNonElements ) {
                        return matcher( elem, context, xml );
                    }
                }
                return false;
            } :

        // Check against all ancestor/preceding elements
            function( elem, context, xml ) {
                var oldCache, uniqueCache, outerCache,
                    newCache = [ dirruns, doneName ];

                // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
                if ( xml ) {
                    while ( ( elem = elem[ dir ] ) ) {
                        if ( elem.nodeType === 1 || checkNonElements ) {
                            if ( matcher( elem, context, xml ) ) {
                                return true;
                            }
                        }
                    }
                } else {
                    while ( ( elem = elem[ dir ] ) ) {
                        if ( elem.nodeType === 1 || checkNonElements ) {
                            outerCache = elem[ expando ] || ( elem[ expando ] = {} );

                            // Support: IE <9 only
                            // Defend against cloned attroperties (jQuery gh-1709)
                            uniqueCache = outerCache[ elem.uniqueID ] ||
							( outerCache[ elem.uniqueID ] = {} );

                            if ( skip && skip === elem.nodeName.toLowerCase() ) {
                                elem = elem[ dir ] || elem;
                            } else if ( ( oldCache = uniqueCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

                                // Assign to newCache so results back-propagate to previous elements
                                return ( newCache[ 2 ] = oldCache[ 2 ] );
                            } else {

                                // Reuse newcache so results back-propagate to previous elements
                                uniqueCache[ key ] = newCache;

                                // A match means we're done; a fail means we have to keep checking
                                if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            };
    }

    function elementMatcher( matchers ) {
        return matchers.length > 1 ?
            function( elem, context, xml ) {
                var i = matchers.length;
                while ( i-- ) {
                    if ( !matchers[ i ]( elem, context, xml ) ) {
                        return false;
                    }
                }
                return true;
            } :
            matchers[ 0 ];
    }

    function multipleContexts( selector, contexts, results ) {
        var i = 0,
            len = contexts.length;
        for ( ; i < len; i++ ) {
            Sizzle( selector, contexts[ i ], results );
        }
        return results;
    }

    function condense( unmatched, map, filter, context, xml ) {
        var elem,
            newUnmatched = [],
            i = 0,
            len = unmatched.length,
            mapped = map != null;

        for ( ; i < len; i++ ) {
            if ( ( elem = unmatched[ i ] ) ) {
                if ( !filter || filter( elem, context, xml ) ) {
                    newUnmatched.push( elem );
                    if ( mapped ) {
                        map.push( i );
                    }
                }
            }
        }

        return newUnmatched;
    }

    function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
        if ( postFilter && !postFilter[ expando ] ) {
            postFilter = setMatcher( postFilter );
        }
        if ( postFinder && !postFinder[ expando ] ) {
            postFinder = setMatcher( postFinder, postSelector );
        }
        return markFunction( function( seed, results, context, xml ) {
            var temp, i, elem,
                preMap = [],
                postMap = [],
                preexisting = results.length,

                // Get initial elements from seed or context
                elems = seed || multipleContexts(
                    selector || "*",
                    context.nodeType ? [ context ] : context,
                    []
                ),

                // Prefilter to get matcher input, preserving a map for seed-results synchronization
                matcherIn = preFilter && ( seed || !selector ) ?
                    condense( elems, preMap, preFilter, context, xml ) :
                    elems,

                matcherOut = matcher ?

                // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                    postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

                    // ...intermediate processing is necessary
                        [] :

                    // ...otherwise use results directly
                        results :
                    matcherIn;

            // Find primary matches
            if ( matcher ) {
                matcher( matcherIn, matcherOut, context, xml );
            }

            // Apply postFilter
            if ( postFilter ) {
                temp = condense( matcherOut, postMap );
                postFilter( temp, [], context, xml );

                // Un-match failing elements by moving them back to matcherIn
                i = temp.length;
                while ( i-- ) {
                    if ( ( elem = temp[ i ] ) ) {
                        matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
                    }
                }
            }

            if ( seed ) {
                if ( postFinder || preFilter ) {
                    if ( postFinder ) {

                        // Get the final matcherOut by condensing this intermediate into postFinder contexts
                        temp = [];
                        i = matcherOut.length;
                        while ( i-- ) {
                            if ( ( elem = matcherOut[ i ] ) ) {

                                // Restore matcherIn since elem is not yet a final match
                                temp.push( ( matcherIn[ i ] = elem ) );
                            }
                        }
                        postFinder( null, ( matcherOut = [] ), temp, xml );
                    }

                    // Move matched elements from seed to results to keep them synchronized
                    i = matcherOut.length;
                    while ( i-- ) {
                        if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {

                            seed[ temp ] = !( results[ temp ] = elem );
                        }
                    }
                }

                // Add elements to results, through postFinder if defined
            } else {
                matcherOut = condense(
                    matcherOut === results ?
                        matcherOut.splice( preexisting, matcherOut.length ) :
                        matcherOut
                );
                if ( postFinder ) {
                    postFinder( null, results, matcherOut, xml );
                } else {
                    push.apply( results, matcherOut );
                }
            }
        } );
    }

    function matcherFromTokens( tokens ) {
        var checkContext, matcher, j,
            len = tokens.length,
            leadingRelative = Expr.relative[ tokens[ 0 ].type ],
            implicitRelative = leadingRelative || Expr.relative[ " " ],
            i = leadingRelative ? 1 : 0,

            // The foundational matcher ensures that elements are reachable from top-level context(s)
            matchContext = addCombinator( function( elem ) {
                return elem === checkContext;
            }, implicitRelative, true ),
            matchAnyContext = addCombinator( function( elem ) {
                return indexOf( checkContext, elem ) > -1;
            }, implicitRelative, true ),
            matchers = [ function( elem, context, xml ) {
                var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
                    ( checkContext = context ).nodeType ?
                        matchContext( elem, context, xml ) :
                        matchAnyContext( elem, context, xml ) );

                // Avoid hanging onto element (issue #299)
                checkContext = null;
                return ret;
            } ];

        for ( ; i < len; i++ ) {
            if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
                matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
            } else {
                matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

                // Return special upon seeing a positional matcher
                if ( matcher[ expando ] ) {

                    // Find the next relative operator (if any) for proper handling
                    j = ++i;
                    for ( ; j < len; j++ ) {
                        if ( Expr.relative[ tokens[ j ].type ] ) {
                            break;
                        }
                    }
                    return setMatcher(
                        i > 1 && elementMatcher( matchers ),
                        i > 1 && toSelector(

                            // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                            tokens
                                .slice( 0, i - 1 )
                                .concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
                        ).replace( rtrim, "$1" ),
                        matcher,
                        i < j && matcherFromTokens( tokens.slice( i, j ) ),
                        j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
                        j < len && toSelector( tokens )
                    );
                }
                matchers.push( matcher );
            }
        }

        return elementMatcher( matchers );
    }

    function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
        var bySet = setMatchers.length > 0,
            byElement = elementMatchers.length > 0,
            superMatcher = function( seed, context, xml, results, outermost ) {
                var elem, j, matcher,
                    matchedCount = 0,
                    i = "0",
                    unmatched = seed && [],
                    setMatched = [],
                    contextBackup = outermostContext,

                    // We must always have either seed elements or outermost context
                    elems = seed || byElement && Expr.find[ "TAG" ]( "*", outermost ),

                    // Use integer dirruns iff this is the outermost matcher
                    dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
                    len = elems.length;

                if ( outermost ) {

                    // Support: IE 11+, Edge 17 - 18+
                    // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                    // two documents; shallow comparisons work.
                    // eslint-disable-next-line eqeqeq
                    outermostContext = context == document || context || outermost;
                }

                // Add elements passing elementMatchers directly to results
                // Support: IE<9, Safari
                // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
                    if ( byElement && elem ) {
                        j = 0;

                        // Support: IE 11+, Edge 17 - 18+
                        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                        // two documents; shallow comparisons work.
                        // eslint-disable-next-line eqeqeq
                        if ( !context && elem.ownerDocument != document ) {
                            setDocument( elem );
                            xml = !documentIsHTML;
                        }
                        while ( ( matcher = elementMatchers[ j++ ] ) ) {
                            if ( matcher( elem, context || document, xml ) ) {
                                results.push( elem );
                                break;
                            }
                        }
                        if ( outermost ) {
                            dirruns = dirrunsUnique;
                        }
                    }

                    // Track unmatched elements for set filters
                    if ( bySet ) {

                        // They will have gone through all possible matchers
                        if ( ( elem = !matcher && elem ) ) {
                            matchedCount--;
                        }

                        // Lengthen the array for every element, matched or not
                        if ( seed ) {
                            unmatched.push( elem );
                        }
                    }
                }

                // `i` is now the count of elements visited above, and adding it to `matchedCount`
                // makes the latter nonnegative.
                matchedCount += i;

                // Apply set filters to unmatched elements
                // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
                // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
                // no element matchers and no seed.
                // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
                // case, which will result in a "00" `matchedCount` that differs from `i` but is also
                // numerically zero.
                if ( bySet && i !== matchedCount ) {
                    j = 0;
                    while ( ( matcher = setMatchers[ j++ ] ) ) {
                        matcher( unmatched, setMatched, context, xml );
                    }

                    if ( seed ) {

                        // Reintegrate element matches to eliminate the need for sorting
                        if ( matchedCount > 0 ) {
                            while ( i-- ) {
                                if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
                                    setMatched[ i ] = pop.call( results );
                                }
                            }
                        }

                        // Discard index placeholder values to get only actual matches
                        setMatched = condense( setMatched );
                    }

                    // Add matches to results
                    push.apply( results, setMatched );

                    // Seedless set matches succeeding multiple successful matchers stipulate sorting
                    if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

                        Sizzle.uniqueSort( results );
                    }
                }

                // Override manipulation of globals by nested matchers
                if ( outermost ) {
                    dirruns = dirrunsUnique;
                    outermostContext = contextBackup;
                }

                return unmatched;
            };

        return bySet ?
            markFunction( superMatcher ) :
            superMatcher;
    }

    compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
        var i,
            setMatchers = [],
            elementMatchers = [],
            cached = compilerCache[ selector + " " ];

        if ( !cached ) {

            // Generate a function of recursive functions that can be used to check each element
            if ( !match ) {
                match = tokenize( selector );
            }
            i = match.length;
            while ( i-- ) {
                cached = matcherFromTokens( match[ i ] );
                if ( cached[ expando ] ) {
                    setMatchers.push( cached );
                } else {
                    elementMatchers.push( cached );
                }
            }

            // Cache the compiled function
            cached = compilerCache(
                selector,
                matcherFromGroupMatchers( elementMatchers, setMatchers )
            );

            // Save selector and tokenization
            cached.selector = selector;
        }
        return cached;
    };

    /**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
    select = Sizzle.select = function( selector, context, results, seed ) {
        var i, tokens, token, type, find,
            compiled = typeof selector === "function" && selector,
            match = !seed && tokenize( ( selector = compiled.selector || selector ) );

        results = results || [];

        // Try to minimize operations if there is only one selector in the list and no seed
        // (the latter of which guarantees us context)
        if ( match.length === 1 ) {

            // Reduce context if the leading compound selector is an ID
            tokens = match[ 0 ] = match[ 0 ].slice( 0 );
            if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
			context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

                context = ( Expr.find[ "ID" ]( token.matches[ 0 ]
                    .replace( runescape, funescape ), context ) || [] )[ 0 ];
                if ( !context ) {
                    return results;

                    // Precompiled matchers will still verify ancestry, so step up a level
                } else if ( compiled ) {
                    context = context.parentNode;
                }

                selector = selector.slice( tokens.shift().value.length );
            }

            // Fetch a seed set for right-to-left matching
            i = matchExpr[ "needsContext" ].test( selector ) ? 0 : tokens.length;
            while ( i-- ) {
                token = tokens[ i ];

                // Abort if we hit a combinator
                if ( Expr.relative[ ( type = token.type ) ] ) {
                    break;
                }
                if ( ( find = Expr.find[ type ] ) ) {

                    // Search, expanding context for leading sibling combinators
                    if ( ( seed = find(
                        token.matches[ 0 ].replace( runescape, funescape ),
                        rsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||
						context
                    ) ) ) {

                        // If seed is empty or no tokens remain, we can return early
                        tokens.splice( i, 1 );
                        selector = seed.length && toSelector( tokens );
                        if ( !selector ) {
                            push.apply( results, seed );
                            return results;
                        }

                        break;
                    }
                }
            }
        }

        // Compile and execute a filtering function if one is not provided
        // Provide `match` to avoid retokenization if we modified the selector above
        ( compiled || compile( selector, match ) )(
            seed,
            context,
            !documentIsHTML,
            results,
            !context || rsibling.test( selector ) && testContext( context.parentNode ) || context
        );
        return results;
    };

    // One-time assignments

    // Sort stability
    support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

    // Support: Chrome 14-35+
    // Always assume duplicates if they aren't passed to the comparison function
    support.detectDuplicates = !!hasDuplicate;

    // Initialize against the default document
    setDocument();

    // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
    // Detached nodes confoundingly follow *each other*
    support.sortDetached = assert( function( el ) {

        // Should return 1, but returns 4 (following)
        return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
    } );

    // Support: IE<8
    // Prevent attribute/property "interpolation"
    // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
    if ( !assert( function( el ) {
        el.innerHTML = "<a href='#'></a>";
        return el.firstChild.getAttribute( "href" ) === "#";
    } ) ) {
        addHandle( "type|href|height|width", function( elem, name, isXML ) {
            if ( !isXML ) {
                return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
            }
        } );
    }

    // Support: IE<9
    // Use defaultValue in place of getAttribute("value")
    if ( !support.attributes || !assert( function( el ) {
        el.innerHTML = "<input/>";
        el.firstChild.setAttribute( "value", "" );
        return el.firstChild.getAttribute( "value" ) === "";
    } ) ) {
        addHandle( "value", function( elem, _name, isXML ) {
            if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
                return elem.defaultValue;
            }
        } );
    }

    // Support: IE<9
    // Use getAttributeNode to fetch booleans when getAttribute lies
    if ( !assert( function( el ) {
        return el.getAttribute( "disabled" ) == null;
    } ) ) {
        addHandle( booleans, function( elem, name, isXML ) {
            var val;
            if ( !isXML ) {
                return elem[ name ] === true ? name.toLowerCase() :
                    ( val = elem.getAttributeNode( name ) ) && val.specified ?
                        val.value :
                        null;
            }
        } );
    }

    return Sizzle;

} )( window );



    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;

    // Deprecated
    jQuery.expr[ ":" ] = jQuery.expr.pseudos;
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    jQuery.escapeSelector = Sizzle.escape;




    var dir = function( elem, dir, until ) {
        var matched = [],
            truncate = until !== undefined;

        while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
            if ( elem.nodeType === 1 ) {
                if ( truncate && jQuery( elem ).is( until ) ) {
                    break;
                }
                matched.push( elem );
            }
        }
        return matched;
    };


    var siblings = function( n, elem ) {
        var matched = [];

        for ( ; n; n = n.nextSibling ) {
            if ( n.nodeType === 1 && n !== elem ) {
                matched.push( n );
            }
        }

        return matched;
    };


    var rneedsContext = jQuery.expr.match.needsContext;



    function nodeName( elem, name ) {

        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

    }
    var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



    // Implement the identical functionality for filter and not
    function winnow( elements, qualifier, not ) {
        if ( isFunction( qualifier ) ) {
            return jQuery.grep( elements, function( elem, i ) {
                return !!qualifier.call( elem, i, elem ) !== not;
            } );
        }

        // Single element
        if ( qualifier.nodeType ) {
            return jQuery.grep( elements, function( elem ) {
                return ( elem === qualifier ) !== not;
            } );
        }

        // Arraylike of elements (jQuery, arguments, Array)
        if ( typeof qualifier !== "string" ) {
            return jQuery.grep( elements, function( elem ) {
                return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
            } );
        }

        // Filtered directly for both simple and complex selectors
        return jQuery.filter( qualifier, elements, not );
    }

    jQuery.filter = function( expr, elems, not ) {
        var elem = elems[ 0 ];

        if ( not ) {
            expr = ":not(" + expr + ")";
        }

        if ( elems.length === 1 && elem.nodeType === 1 ) {
            return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
        }

        return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
            return elem.nodeType === 1;
        } ) );
    };

    jQuery.fn.extend( {
        find: function( selector ) {
            var i, ret,
                len = this.length,
                self = this;

            if ( typeof selector !== "string" ) {
                return this.pushStack( jQuery( selector ).filter( function() {
                    for ( i = 0; i < len; i++ ) {
                        if ( jQuery.contains( self[ i ], this ) ) {
                            return true;
                        }
                    }
                } ) );
            }

            ret = this.pushStack( [] );

            for ( i = 0; i < len; i++ ) {
                jQuery.find( selector, self[ i ], ret );
            }

            return len > 1 ? jQuery.uniqueSort( ret ) : ret;
        },
        filter: function( selector ) {
            return this.pushStack( winnow( this, selector || [], false ) );
        },
        not: function( selector ) {
            return this.pushStack( winnow( this, selector || [], true ) );
        },
        is: function( selector ) {
            return !!winnow(
                this,

                // If this is a positional/relative selector, check membership in the returned set
                // so $("p:first").is("p:last") won't return true for a doc with two "p".
                typeof selector === "string" && rneedsContext.test( selector ) ?
                    jQuery( selector ) :
                    selector || [],
                false
            ).length;
        }
    } );


    // Initialize a jQuery object


    // A central reference to the root jQuery(document)
    var rootjQuery,

        // A simple way to check for HTML strings
        // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
        // Strict HTML recognition (#11290: must start with <)
        // Shortcut simple #id case for speed
        rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

        init = jQuery.fn.init = function( selector, context, root ) {
            var match, elem;

            // HANDLE: $(""), $(null), $(undefined), $(false)
            if ( !selector ) {
                return this;
            }

            // Method init() accepts an alternate rootjQuery
            // so migrate can support jQuery.sub (gh-2101)
            root = root || rootjQuery;

            // Handle HTML strings
            if ( typeof selector === "string" ) {
                if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

                    // Assume that strings that start and end with <> are HTML and skip the regex check
                    match = [ null, selector, null ];

                } else {
                    match = rquickExpr.exec( selector );
                }

                // Match html or make sure no context is specified for #id
                if ( match && ( match[ 1 ] || !context ) ) {

                    // HANDLE: $(html) -> $(array)
                    if ( match[ 1 ] ) {
                        context = context instanceof jQuery ? context[ 0 ] : context;

                        // Option to run scripts is true for back-compat
                        // Intentionally let the error be thrown if parseHTML is not present
                        jQuery.merge( this, jQuery.parseHTML(
                            match[ 1 ],
                            context && context.nodeType ? context.ownerDocument || context : document,
                            true
                        ) );

                        // HANDLE: $(html, props)
                        if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
                            for ( match in context ) {

                                // Properties of context are called as methods if possible
                                if ( isFunction( this[ match ] ) ) {
                                    this[ match ]( context[ match ] );

                                    // ...and otherwise set as attributes
                                } else {
                                    this.attr( match, context[ match ] );
                                }
                            }
                        }

                        return this;

                        // HANDLE: $(#id)
                    } else {
                        elem = document.getElementById( match[ 2 ] );

                        if ( elem ) {

                            // Inject the element directly into the jQuery object
                            this[ 0 ] = elem;
                            this.length = 1;
                        }
                        return this;
                    }

                    // HANDLE: $(expr, $(...))
                } else if ( !context || context.jquery ) {
                    return ( context || root ).find( selector );

                    // HANDLE: $(expr, context)
                    // (which is just equivalent to: $(context).find(expr)
                } else {
                    return this.constructor( context ).find( selector );
                }

                // HANDLE: $(DOMElement)
            } else if ( selector.nodeType ) {
                this[ 0 ] = selector;
                this.length = 1;
                return this;

                // HANDLE: $(function)
                // Shortcut for document ready
            } else if ( isFunction( selector ) ) {
                return root.ready !== undefined ?
                    root.ready( selector ) :

                // Execute immediately if ready is not present
                    selector( jQuery );
            }

            return jQuery.makeArray( selector, this );
        };

    // Give the init function the jQuery prototype for later instantiation
    init.prototype = jQuery.fn;

    // Initialize central reference
    rootjQuery = jQuery( document );


    var rparentsprev = /^(?:parents|prev(?:Until|All))/,

        // Methods guaranteed to produce a unique set when starting from a unique set
        guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
        };

    jQuery.fn.extend( {
        has: function( target ) {
            var targets = jQuery( target, this ),
                l = targets.length;

            return this.filter( function() {
                var i = 0;
                for ( ; i < l; i++ ) {
                    if ( jQuery.contains( this, targets[ i ] ) ) {
                        return true;
                    }
                }
            } );
        },

        closest: function( selectors, context ) {
            var cur,
                i = 0,
                l = this.length,
                matched = [],
                targets = typeof selectors !== "string" && jQuery( selectors );

            // Positional selectors never match, since there's no _selection_ context
            if ( !rneedsContext.test( selectors ) ) {
                for ( ; i < l; i++ ) {
                    for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

                        // Always skip document fragments
                        if ( cur.nodeType < 11 && ( targets ?
                            targets.index( cur ) > -1 :

                        // Don't pass non-elements to Sizzle
                            cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

                            matched.push( cur );
                            break;
                        }
                    }
                }
            }

            return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
        },

        // Determine the position of an element within the set
        index: function( elem ) {

            // No argument, return index in parent
            if ( !elem ) {
                return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
            }

            // Index in selector
            if ( typeof elem === "string" ) {
                return indexOf.call( jQuery( elem ), this[ 0 ] );
            }

            // Locate the position of the desired element
            return indexOf.call( this,

                // If it receives a jQuery object, the first element is used
                elem.jquery ? elem[ 0 ] : elem
            );
        },

        add: function( selector, context ) {
            return this.pushStack(
                jQuery.uniqueSort(
                    jQuery.merge( this.get(), jQuery( selector, context ) )
                )
            );
        },

        addBack: function( selector ) {
            return this.add( selector == null ?
                this.prevObject : this.prevObject.filter( selector )
            );
        }
    } );

    function sibling( cur, dir ) {
        while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
        return cur;
    }

    jQuery.each( {
        parent: function( elem ) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function( elem ) {
            return dir( elem, "parentNode" );
        },
        parentsUntil: function( elem, _i, until ) {
            return dir( elem, "parentNode", until );
        },
        next: function( elem ) {
            return sibling( elem, "nextSibling" );
        },
        prev: function( elem ) {
            return sibling( elem, "previousSibling" );
        },
        nextAll: function( elem ) {
            return dir( elem, "nextSibling" );
        },
        prevAll: function( elem ) {
            return dir( elem, "previousSibling" );
        },
        nextUntil: function( elem, _i, until ) {
            return dir( elem, "nextSibling", until );
        },
        prevUntil: function( elem, _i, until ) {
            return dir( elem, "previousSibling", until );
        },
        siblings: function( elem ) {
            return siblings( ( elem.parentNode || {} ).firstChild, elem );
        },
        children: function( elem ) {
            return siblings( elem.firstChild );
        },
        contents: function( elem ) {
            if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

                return elem.contentDocument;
            }

            // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
            // Treat the template element as a regular one in browsers that
            // don't support it.
            if ( nodeName( elem, "template" ) ) {
                elem = elem.content || elem;
            }

            return jQuery.merge( [], elem.childNodes );
        }
    }, function( name, fn ) {
        jQuery.fn[ name ] = function( until, selector ) {
            var matched = jQuery.map( this, fn, until );

            if ( name.slice( -5 ) !== "Until" ) {
                selector = until;
            }

            if ( selector && typeof selector === "string" ) {
                matched = jQuery.filter( selector, matched );
            }

            if ( this.length > 1 ) {

                // Remove duplicates
                if ( !guaranteedUnique[ name ] ) {
                    jQuery.uniqueSort( matched );
                }

                // Reverse order for parents* and prev-derivatives
                if ( rparentsprev.test( name ) ) {
                    matched.reverse();
                }
            }

            return this.pushStack( matched );
        };
    } );
    var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



    // Convert String-formatted options into Object-formatted ones
    function createOptions( options ) {
        var object = {};
        jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
            object[ flag ] = true;
        } );
        return object;
    }

    /*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
    jQuery.Callbacks = function( options ) {

        // Convert options from String-formatted to Object-formatted if needed
        // (we check in cache first)
        options = typeof options === "string" ?
            createOptions( options ) :
            jQuery.extend( {}, options );

        var // Flag to know if list is currently firing
            firing,

            // Last fire value for non-forgettable lists
            memory,

            // Flag to know if list was already fired
            fired,

            // Flag to prevent firing
            locked,

            // Actual callback list
            list = [],

            // Queue of execution data for repeatable lists
            queue = [],

            // Index of currently firing callback (modified by add/remove as needed)
            firingIndex = -1,

            // Fire callbacks
            fire = function() {

                // Enforce single-firing
                locked = locked || options.once;

                // Execute callbacks for all pending executions,
                // respecting firingIndex overrides and runtime changes
                fired = firing = true;
                for ( ; queue.length; firingIndex = -1 ) {
                    memory = queue.shift();
                    while ( ++firingIndex < list.length ) {

                        // Run callback and check for early termination
                        if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

                            // Jump to end and forget the data so .add doesn't re-fire
                            firingIndex = list.length;
                            memory = false;
                        }
                    }
                }

                // Forget the data if we're done with it
                if ( !options.memory ) {
                    memory = false;
                }

                firing = false;

                // Clean up if we're done firing for good
                if ( locked ) {

                    // Keep an empty list if we have data for future add calls
                    if ( memory ) {
                        list = [];

                        // Otherwise, this object is spent
                    } else {
                        list = "";
                    }
                }
            },

            // Actual Callbacks object
            self = {

                // Add a callback or a collection of callbacks to the list
                add: function() {
                    if ( list ) {

                        // If we have memory from a past run, we should fire after adding
                        if ( memory && !firing ) {
                            firingIndex = list.length - 1;
                            queue.push( memory );
                        }

                        ( function add( args ) {
                            jQuery.each( args, function( _, arg ) {
                                if ( isFunction( arg ) ) {
                                    if ( !options.unique || !self.has( arg ) ) {
                                        list.push( arg );
                                    }
                                } else if ( arg && arg.length && toType( arg ) !== "string" ) {

                                    // Inspect recursively
                                    add( arg );
                                }
                            } );
                        } )( arguments );

                        if ( memory && !firing ) {
                            fire();
                        }
                    }
                    return this;
                },

                // Remove a callback from the list
                remove: function() {
                    jQuery.each( arguments, function( _, arg ) {
                        var index;
                        while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
                            list.splice( index, 1 );

                            // Handle firing indexes
                            if ( index <= firingIndex ) {
                                firingIndex--;
                            }
                        }
                    } );
                    return this;
                },

                // Check if a given callback is in the list.
                // If no argument is given, return whether or not list has callbacks attached.
                has: function( fn ) {
                    return fn ?
                        jQuery.inArray( fn, list ) > -1 :
                        list.length > 0;
                },

                // Remove all callbacks from the list
                empty: function() {
                    if ( list ) {
                        list = [];
                    }
                    return this;
                },

                // Disable .fire and .add
                // Abort any current/pending executions
                // Clear all callbacks and values
                disable: function() {
                    locked = queue = [];
                    list = memory = "";
                    return this;
                },
                disabled: function() {
                    return !list;
                },

                // Disable .fire
                // Also disable .add unless we have memory (since it would have no effect)
                // Abort any pending executions
                lock: function() {
                    locked = queue = [];
                    if ( !memory && !firing ) {
                        list = memory = "";
                    }
                    return this;
                },
                locked: function() {
                    return !!locked;
                },

                // Call all callbacks with the given context and arguments
                fireWith: function( context, args ) {
                    if ( !locked ) {
                        args = args || [];
                        args = [ context, args.slice ? args.slice() : args ];
                        queue.push( args );
                        if ( !firing ) {
                            fire();
                        }
                    }
                    return this;
                },

                // Call all the callbacks with the given arguments
                fire: function() {
                    self.fireWith( this, arguments );
                    return this;
                },

                // To know if the callbacks have already been called at least once
                fired: function() {
                    return !!fired;
                }
            };

        return self;
    };


    function Identity( v ) {
        return v;
    }
    function Thrower( ex ) {
        throw ex;
    }

    function adoptValue( value, resolve, reject, noValue ) {
        var method;

        try {

            // Check for promise aspect first to privilege synchronous behavior
            if ( value && isFunction( ( method = value.promise ) ) ) {
                method.call( value ).done( resolve ).fail( reject );

                // Other thenables
            } else if ( value && isFunction( ( method = value.then ) ) ) {
                method.call( value, resolve, reject );

                // Other non-thenables
            } else {

                // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
                // * false: [ value ].slice( 0 ) => resolve( value )
                // * true: [ value ].slice( 1 ) => resolve()
                resolve.apply( undefined, [ value ].slice( noValue ) );
            }

            // For Promises/A+, convert exceptions into rejections
            // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
            // Deferred#then to conditionally suppress rejection.
        } catch ( value ) {

            // Support: Android 4.0 only
            // Strict mode functions invoked without .call/.apply get global-object context
            reject.apply( undefined, [ value ] );
        }
    }

    jQuery.extend( {

        Deferred: function( func ) {
            var tuples = [

                    // action, add listener, callbacks,
                    // ... .then handlers, argument index, [final state]
                    [ "notify", "progress", jQuery.Callbacks( "memory" ),
                        jQuery.Callbacks( "memory" ), 2 ],
                    [ "resolve", "done", jQuery.Callbacks( "once memory" ),
                        jQuery.Callbacks( "once memory" ), 0, "resolved" ],
                    [ "reject", "fail", jQuery.Callbacks( "once memory" ),
                        jQuery.Callbacks( "once memory" ), 1, "rejected" ]
                ],
                state = "pending",
                promise = {
                    state: function() {
                        return state;
                    },
                    always: function() {
                        deferred.done( arguments ).fail( arguments );
                        return this;
                    },
                    "catch": function( fn ) {
                        return promise.then( null, fn );
                    },

                    // Keep pipe for back-compat
                    pipe: function( /* fnDone, fnFail, fnProgress */ ) {
                        var fns = arguments;

                        return jQuery.Deferred( function( newDefer ) {
                            jQuery.each( tuples, function( _i, tuple ) {

                                // Map tuples (progress, done, fail) to arguments (done, fail, progress)
                                var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

                                // deferred.progress(function() { bind to newDefer or newDefer.notify })
                                // deferred.done(function() { bind to newDefer or newDefer.resolve })
                                // deferred.fail(function() { bind to newDefer or newDefer.reject })
                                deferred[ tuple[ 1 ] ]( function() {
                                    var returned = fn && fn.apply( this, arguments );
                                    if ( returned && isFunction( returned.promise ) ) {
                                        returned.promise()
                                            .progress( newDefer.notify )
                                            .done( newDefer.resolve )
                                            .fail( newDefer.reject );
                                    } else {
                                        newDefer[ tuple[ 0 ] + "With" ](
                                            this,
                                            fn ? [ returned ] : arguments
                                        );
                                    }
                                } );
                            } );
                            fns = null;
                        } ).promise();
                    },
                    then: function( onFulfilled, onRejected, onProgress ) {
                        var maxDepth = 0;
                        function resolve( depth, deferred, handler, special ) {
                            return function() {
                                var that = this,
                                    args = arguments,
                                    mightThrow = function() {
                                        var returned, then;

                                        // Support: Promises/A+ section 2.3.3.3.3
                                        // https://promisesaplus.com/#point-59
                                        // Ignore double-resolution attempts
                                        if ( depth < maxDepth ) {
                                            return;
                                        }

                                        returned = handler.apply( that, args );

                                        // Support: Promises/A+ section 2.3.1
                                        // https://promisesaplus.com/#point-48
                                        if ( returned === deferred.promise() ) {
                                            throw new TypeError( "Thenable self-resolution" );
                                        }

                                        // Support: Promises/A+ sections 2.3.3.1, 3.5
                                        // https://promisesaplus.com/#point-54
                                        // https://promisesaplus.com/#point-75
                                        // Retrieve `then` only once
                                        then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

                                        // Handle a returned thenable
                                        if ( isFunction( then ) ) {

                                            // Special processors (notify) just wait for resolution
                                            if ( special ) {
                                                then.call(
                                                    returned,
                                                    resolve( maxDepth, deferred, Identity, special ),
                                                    resolve( maxDepth, deferred, Thrower, special )
                                                );

                                                // Normal processors (resolve) also hook into progress
                                            } else {

                                                // ...and disregard older resolution values
                                                maxDepth++;

                                                then.call(
                                                    returned,
                                                    resolve( maxDepth, deferred, Identity, special ),
                                                    resolve( maxDepth, deferred, Thrower, special ),
                                                    resolve( maxDepth, deferred, Identity,
                                                        deferred.notifyWith )
                                                );
                                            }

                                            // Handle all other returned values
                                        } else {

                                            // Only substitute handlers pass on context
                                            // and multiple values (non-spec behavior)
                                            if ( handler !== Identity ) {
                                                that = undefined;
                                                args = [ returned ];
                                            }

                                            // Process the value(s)
                                            // Default process is resolve
                                            ( special || deferred.resolveWith )( that, args );
                                        }
                                    },

                                    // Only normal processors (resolve) catch and reject exceptions
                                    process = special ?
                                        mightThrow :
                                        function() {
                                            try {
                                                mightThrow();
                                            } catch ( e ) {

                                                if ( jQuery.Deferred.exceptionHook ) {
                                                    jQuery.Deferred.exceptionHook( e,
                                                        process.stackTrace );
                                                }

                                                // Support: Promises/A+ section 2.3.3.3.4.1
                                                // https://promisesaplus.com/#point-61
                                                // Ignore post-resolution exceptions
                                                if ( depth + 1 >= maxDepth ) {

                                                    // Only substitute handlers pass on context
                                                    // and multiple values (non-spec behavior)
                                                    if ( handler !== Thrower ) {
                                                        that = undefined;
                                                        args = [ e ];
                                                    }

                                                    deferred.rejectWith( that, args );
                                                }
                                            }
                                        };

                                // Support: Promises/A+ section 2.3.3.3.1
                                // https://promisesaplus.com/#point-57
                                // Re-resolve promises immediately to dodge false rejection from
                                // subsequent errors
                                if ( depth ) {
                                    process();
                                } else {

                                    // Call an optional hook to record the stack, in case of exception
                                    // since it's otherwise lost when execution goes async
                                    if ( jQuery.Deferred.getStackHook ) {
                                        process.stackTrace = jQuery.Deferred.getStackHook();
                                    }
                                    window.setTimeout( process );
                                }
                            };
                        }

                        return jQuery.Deferred( function( newDefer ) {

                            // progress_handlers.add( ... )
                            tuples[ 0 ][ 3 ].add(
                                resolve(
                                    0,
                                    newDefer,
                                    isFunction( onProgress ) ?
                                        onProgress :
                                        Identity,
                                    newDefer.notifyWith
                                )
                            );

                            // fulfilled_handlers.add( ... )
                            tuples[ 1 ][ 3 ].add(
                                resolve(
                                    0,
                                    newDefer,
                                    isFunction( onFulfilled ) ?
                                        onFulfilled :
                                        Identity
                                )
                            );

                            // rejected_handlers.add( ... )
                            tuples[ 2 ][ 3 ].add(
                                resolve(
                                    0,
                                    newDefer,
                                    isFunction( onRejected ) ?
                                        onRejected :
                                        Thrower
                                )
                            );
                        } ).promise();
                    },

                    // Get a promise for this deferred
                    // If obj is provided, the promise aspect is added to the object
                    promise: function( obj ) {
                        return obj != null ? jQuery.extend( obj, promise ) : promise;
                    }
                },
                deferred = {};

            // Add list-specific methods
            jQuery.each( tuples, function( i, tuple ) {
                var list = tuple[ 2 ],
                    stateString = tuple[ 5 ];

                // promise.progress = list.add
                // promise.done = list.add
                // promise.fail = list.add
                promise[ tuple[ 1 ] ] = list.add;

                // Handle state
                if ( stateString ) {
                    list.add(
                        function() {

                            // state = "resolved" (i.e., fulfilled)
                            // state = "rejected"
                            state = stateString;
                        },

                        // rejected_callbacks.disable
                        // fulfilled_callbacks.disable
                        tuples[ 3 - i ][ 2 ].disable,

                        // rejected_handlers.disable
                        // fulfilled_handlers.disable
                        tuples[ 3 - i ][ 3 ].disable,

                        // progress_callbacks.lock
                        tuples[ 0 ][ 2 ].lock,

                        // progress_handlers.lock
                        tuples[ 0 ][ 3 ].lock
                    );
                }

                // progress_handlers.fire
                // fulfilled_handlers.fire
                // rejected_handlers.fire
                list.add( tuple[ 3 ].fire );

                // deferred.notify = function() { deferred.notifyWith(...) }
                // deferred.resolve = function() { deferred.resolveWith(...) }
                // deferred.reject = function() { deferred.rejectWith(...) }
                deferred[ tuple[ 0 ] ] = function() {
                    deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
                    return this;
                };

                // deferred.notifyWith = list.fireWith
                // deferred.resolveWith = list.fireWith
                // deferred.rejectWith = list.fireWith
                deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
            } );

            // Make the deferred a promise
            promise.promise( deferred );

            // Call given func if any
            if ( func ) {
                func.call( deferred, deferred );
            }

            // All done!
            return deferred;
        },

        // Deferred helper
        when: function( singleValue ) {
            var

                // count of uncompleted subordinates
                remaining = arguments.length,

                // count of unprocessed arguments
                i = remaining,

                // subordinate fulfillment data
                resolveContexts = Array( i ),
                resolveValues = slice.call( arguments ),

                // the master Deferred
                master = jQuery.Deferred(),

                // subordinate callback factory
                updateFunc = function( i ) {
                    return function( value ) {
                        resolveContexts[ i ] = this;
                        resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
                        if ( !( --remaining ) ) {
                            master.resolveWith( resolveContexts, resolveValues );
                        }
                    };
                };

            // Single- and empty arguments are adopted like Promise.resolve
            if ( remaining <= 1 ) {
                adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
                    !remaining );

                // Use .then() to unwrap secondary thenables (cf. gh-3000)
                if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

                    return master.then();
                }
            }

            // Multiple arguments are aggregated like Promise.all array elements
            while ( i-- ) {
                adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
            }

            return master.promise();
        }
    } );


    // These usually indicate a programmer mistake during development,
    // warn about them ASAP rather than swallowing them by default.
    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

    jQuery.Deferred.exceptionHook = function( error, stack ) {

        // Support: IE 8 - 9 only
        // Console exists when dev tools are open, which can happen at any time
        if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
            window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
        }
    };




    jQuery.readyException = function( error ) {
        window.setTimeout( function() {
            throw error;
        } );
    };




    // The deferred used on DOM ready
    var readyList = jQuery.Deferred();

    jQuery.fn.ready = function( fn ) {

        readyList
            .then( fn )

        // Wrap jQuery.readyException in a function so that the lookup
        // happens at the time of error handling instead of callback
        // registration.
            .catch( function( error ) {
                jQuery.readyException( error );
            } );

        return this;
    };

    jQuery.extend( {

        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,

        // A counter to track how many items to wait for before
        // the ready event fires. See #6781
        readyWait: 1,

        // Handle when the DOM is ready
        ready: function( wait ) {

            // Abort if there are pending holds or we're already ready
            if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
                return;
            }

            // Remember that the DOM is ready
            jQuery.isReady = true;

            // If a normal DOM Ready event fired, decrement, and wait if need be
            if ( wait !== true && --jQuery.readyWait > 0 ) {
                return;
            }

            // If there are functions bound, to execute
            readyList.resolveWith( document, [ jQuery ] );
        }
    } );

    jQuery.ready.then = readyList.then;

    // The ready event handler and self cleanup method
    function completed() {
        document.removeEventListener( "DOMContentLoaded", completed );
        window.removeEventListener( "load", completed );
        jQuery.ready();
    }

    // Catch cases where $(document).ready() is called
    // after the browser event has already occurred.
    // Support: IE <=9 - 10 only
    // Older IE sometimes signals "interactive" too soon
    if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

        // Handle it asynchronously to allow scripts the opportunity to delay ready
        window.setTimeout( jQuery.ready );

    } else {

        // Use the handy event callback
        document.addEventListener( "DOMContentLoaded", completed );

        // A fallback to window.onload, that will always work
        window.addEventListener( "load", completed );
    }




    // Multifunctional method to get and set values of a collection
    // The value/s can optionally be executed if it's a function
    var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
        var i = 0,
            len = elems.length,
            bulk = key == null;

        // Sets many values
        if ( toType( key ) === "object" ) {
            chainable = true;
            for ( i in key ) {
                access( elems, fn, i, key[ i ], true, emptyGet, raw );
            }

            // Sets one value
        } else if ( value !== undefined ) {
            chainable = true;

            if ( !isFunction( value ) ) {
                raw = true;
            }

            if ( bulk ) {

                // Bulk operations run against the entire set
                if ( raw ) {
                    fn.call( elems, value );
                    fn = null;

                    // ...except when executing function values
                } else {
                    bulk = fn;
                    fn = function( elem, _key, value ) {
                        return bulk.call( jQuery( elem ), value );
                    };
                }
            }

            if ( fn ) {
                for ( ; i < len; i++ ) {
                    fn(
                        elems[ i ], key, raw ?
                            value :
                            value.call( elems[ i ], i, fn( elems[ i ], key ) )
                    );
                }
            }
        }

        if ( chainable ) {
            return elems;
        }

        // Gets
        if ( bulk ) {
            return fn.call( elems );
        }

        return len ? fn( elems[ 0 ], key ) : emptyGet;
    };


    // Matches dashed string for camelizing
    var rmsPrefix = /^-ms-/,
        rdashAlpha = /-([a-z])/g;

    // Used by camelCase as callback to replace()
    function fcamelCase( _all, letter ) {
        return letter.toUpperCase();
    }

    // Convert dashed to camelCase; used by the css and data modules
    // Support: IE <=9 - 11, Edge 12 - 15
    // Microsoft forgot to hump their vendor prefix (#9572)
    function camelCase( string ) {
        return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
    }
    var acceptData = function( owner ) {

        // Accepts only:
        //  - Node
        //    - Node.ELEMENT_NODE
        //    - Node.DOCUMENT_NODE
        //  - Object
        //    - Any
        return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
    };




    function Data() {
        this.expando = jQuery.expando + Data.uid++;
    }

    Data.uid = 1;

    Data.prototype = {

        cache: function( owner ) {

            // Check if the owner object already has a cache
            var value = owner[ this.expando ];

            // If not, create one
            if ( !value ) {
                value = {};

                // We can accept data for non-element nodes in modern browsers,
                // but we should not, see #8335.
                // Always return an empty object.
                if ( acceptData( owner ) ) {

                    // If it is a node unlikely to be stringify-ed or looped over
                    // use plain assignment
                    if ( owner.nodeType ) {
                        owner[ this.expando ] = value;

                        // Otherwise secure it in a non-enumerable property
                        // configurable must be true to allow the property to be
                        // deleted when data is removed
                    } else {
                        Object.defineProperty( owner, this.expando, {
                            value: value,
                            configurable: true
                        } );
                    }
                }
            }

            return value;
        },
        set: function( owner, data, value ) {
            var prop,
                cache = this.cache( owner );

            // Handle: [ owner, key, value ] args
            // Always use camelCase key (gh-2257)
            if ( typeof data === "string" ) {
                cache[ camelCase( data ) ] = value;

                // Handle: [ owner, { properties } ] args
            } else {

                // Copy the properties one-by-one to the cache object
                for ( prop in data ) {
                    cache[ camelCase( prop ) ] = data[ prop ];
                }
            }
            return cache;
        },
        get: function( owner, key ) {
            return key === undefined ?
                this.cache( owner ) :

            // Always use camelCase key (gh-2257)
                owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
        },
        access: function( owner, key, value ) {

            // In cases where either:
            //
            //   1. No key was specified
            //   2. A string key was specified, but no value provided
            //
            // Take the "read" path and allow the get method to determine
            // which value to return, respectively either:
            //
            //   1. The entire cache object
            //   2. The data stored at the key
            //
            if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

                return this.get( owner, key );
            }

            // When the key is not a string, or both a key and value
            // are specified, set or extend (existing objects) with either:
            //
            //   1. An object of properties
            //   2. A key and value
            //
            this.set( owner, key, value );

            // Since the "set" path can have two possible entry points
            // return the expected data based on which path was taken[*]
            return value !== undefined ? value : key;
        },
        remove: function( owner, key ) {
            var i,
                cache = owner[ this.expando ];

            if ( cache === undefined ) {
                return;
            }

            if ( key !== undefined ) {

                // Support array or space separated string of keys
                if ( Array.isArray( key ) ) {

                    // If key is an array of keys...
                    // We always set camelCase keys, so remove that.
                    key = key.map( camelCase );
                } else {
                    key = camelCase( key );

                    // If a key with the spaces exists, use it.
                    // Otherwise, create an array by matching non-whitespace
                    key = key in cache ?
                        [ key ] :
                        ( key.match( rnothtmlwhite ) || [] );
                }

                i = key.length;

                while ( i-- ) {
                    delete cache[ key[ i ] ];
                }
            }

            // Remove the expando if there's no more data
            if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

                // Support: Chrome <=35 - 45
                // Webkit & Blink performance suffers when deleting properties
                // from DOM nodes, so set to undefined instead
                // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
                if ( owner.nodeType ) {
                    owner[ this.expando ] = undefined;
                } else {
                    delete owner[ this.expando ];
                }
            }
        },
        hasData: function( owner ) {
            var cache = owner[ this.expando ];
            return cache !== undefined && !jQuery.isEmptyObject( cache );
        }
    };
    var dataPriv = new Data();

    var dataUser = new Data();



    //	Implementation Summary
    //
    //	1. Enforce API surface and semantic compatibility with 1.9.x branch
    //	2. Improve the module's maintainability by reducing the storage
    //		paths to a single mechanism.
    //	3. Use the same single mechanism to support "private" and "user" data.
    //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
    //	5. Avoid exposing implementation details on user objects (eg. expando properties)
    //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        rmultiDash = /[A-Z]/g;

    function getData( data ) {
        if ( data === "true" ) {
            return true;
        }

        if ( data === "false" ) {
            return false;
        }

        if ( data === "null" ) {
            return null;
        }

        // Only convert to a number if it doesn't change the string
        if ( data === +data + "" ) {
            return +data;
        }

        if ( rbrace.test( data ) ) {
            return JSON.parse( data );
        }

        return data;
    }

    function dataAttr( elem, key, data ) {
        var name;

        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if ( data === undefined && elem.nodeType === 1 ) {
            name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
            data = elem.getAttribute( name );

            if ( typeof data === "string" ) {
                try {
                    data = getData( data );
                } catch ( e ) {}

                // Make sure we set the data so it isn't changed later
                dataUser.set( elem, key, data );
            } else {
                data = undefined;
            }
        }
        return data;
    }

    jQuery.extend( {
        hasData: function( elem ) {
            return dataUser.hasData( elem ) || dataPriv.hasData( elem );
        },

        data: function( elem, name, data ) {
            return dataUser.access( elem, name, data );
        },

        removeData: function( elem, name ) {
            dataUser.remove( elem, name );
        },

        // TODO: Now that all calls to _data and _removeData have been replaced
        // with direct calls to dataPriv methods, these can be deprecated.
        _data: function( elem, name, data ) {
            return dataPriv.access( elem, name, data );
        },

        _removeData: function( elem, name ) {
            dataPriv.remove( elem, name );
        }
    } );

    jQuery.fn.extend( {
        data: function( key, value ) {
            var i, name, data,
                elem = this[ 0 ],
                attrs = elem && elem.attributes;

            // Gets all values
            if ( key === undefined ) {
                if ( this.length ) {
                    data = dataUser.get( elem );

                    if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
                        i = attrs.length;
                        while ( i-- ) {

                            // Support: IE 11 only
                            // The attrs elements can be null (#14894)
                            if ( attrs[ i ] ) {
                                name = attrs[ i ].name;
                                if ( name.indexOf( "data-" ) === 0 ) {
                                    name = camelCase( name.slice( 5 ) );
                                    dataAttr( elem, name, data[ name ] );
                                }
                            }
                        }
                        dataPriv.set( elem, "hasDataAttrs", true );
                    }
                }

                return data;
            }

            // Sets multiple values
            if ( typeof key === "object" ) {
                return this.each( function() {
                    dataUser.set( this, key );
                } );
            }

            return access( this, function( value ) {
                var data;

                // The calling jQuery object (element matches) is not empty
                // (and therefore has an element appears at this[ 0 ]) and the
                // `value` parameter was not undefined. An empty jQuery object
                // will result in `undefined` for elem = this[ 0 ] which will
                // throw an exception if an attempt to read a data cache is made.
                if ( elem && value === undefined ) {

                    // Attempt to get data from the cache
                    // The key will always be camelCased in Data
                    data = dataUser.get( elem, key );
                    if ( data !== undefined ) {
                        return data;
                    }

                    // Attempt to "discover" the data in
                    // HTML5 custom data-* attrs
                    data = dataAttr( elem, key );
                    if ( data !== undefined ) {
                        return data;
                    }

                    // We tried really hard, but the data doesn't exist.
                    return;
                }

                // Set the data...
                this.each( function() {

                    // We always store the camelCased key
                    dataUser.set( this, key, value );
                } );
            }, null, value, arguments.length > 1, null, true );
        },

        removeData: function( key ) {
            return this.each( function() {
                dataUser.remove( this, key );
            } );
        }
    } );


    jQuery.extend( {
        queue: function( elem, type, data ) {
            var queue;

            if ( elem ) {
                type = ( type || "fx" ) + "queue";
                queue = dataPriv.get( elem, type );

                // Speed up dequeue by getting out quickly if this is just a lookup
                if ( data ) {
                    if ( !queue || Array.isArray( data ) ) {
                        queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
                    } else {
                        queue.push( data );
                    }
                }
                return queue || [];
            }
        },

        dequeue: function( elem, type ) {
            type = type || "fx";

            var queue = jQuery.queue( elem, type ),
                startLength = queue.length,
                fn = queue.shift(),
                hooks = jQuery._queueHooks( elem, type ),
                next = function() {
                    jQuery.dequeue( elem, type );
                };

            // If the fx queue is dequeued, always remove the progress sentinel
            if ( fn === "inprogress" ) {
                fn = queue.shift();
                startLength--;
            }

            if ( fn ) {

                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if ( type === "fx" ) {
                    queue.unshift( "inprogress" );
                }

                // Clear up the last queue stop function
                delete hooks.stop;
                fn.call( elem, next, hooks );
            }

            if ( !startLength && hooks ) {
                hooks.empty.fire();
            }
        },

        // Not public - generate a queueHooks object, or return the current one
        _queueHooks: function( elem, type ) {
            var key = type + "queueHooks";
            return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
                empty: jQuery.Callbacks( "once memory" ).add( function() {
                    dataPriv.remove( elem, [ type + "queue", key ] );
                } )
            } );
        }
    } );

    jQuery.fn.extend( {
        queue: function( type, data ) {
            var setter = 2;

            if ( typeof type !== "string" ) {
                data = type;
                type = "fx";
                setter--;
            }

            if ( arguments.length < setter ) {
                return jQuery.queue( this[ 0 ], type );
            }

            return data === undefined ?
                this :
                this.each( function() {
                    var queue = jQuery.queue( this, type, data );

                    // Ensure a hooks for this queue
                    jQuery._queueHooks( this, type );

                    if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
                        jQuery.dequeue( this, type );
                    }
                } );
        },
        dequeue: function( type ) {
            return this.each( function() {
                jQuery.dequeue( this, type );
            } );
        },
        clearQueue: function( type ) {
            return this.queue( type || "fx", [] );
        },

        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function( type, obj ) {
            var tmp,
                count = 1,
                defer = jQuery.Deferred(),
                elements = this,
                i = this.length,
                resolve = function() {
                    if ( !( --count ) ) {
                        defer.resolveWith( elements, [ elements ] );
                    }
                };

            if ( typeof type !== "string" ) {
                obj = type;
                type = undefined;
            }
            type = type || "fx";

            while ( i-- ) {
                tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
                if ( tmp && tmp.empty ) {
                    count++;
                    tmp.empty.add( resolve );
                }
            }
            resolve();
            return defer.promise( obj );
        }
    } );
    var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

    var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


    var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

    var documentElement = document.documentElement;



    var isAttached = function( elem ) {
            return jQuery.contains( elem.ownerDocument, elem );
        },
        composed = { composed: true };

    // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
    // Check attachment across shadow DOM boundaries when possible (gh-3504)
    // Support: iOS 10.0-10.2 only
    // Early iOS 10 versions support `attachShadow` but not `getRootNode`,
    // leading to errors. We need to check for `getRootNode`.
    if ( documentElement.getRootNode ) {
        isAttached = function( elem ) {
            return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
        };
    }
    var isHiddenWithinTree = function( elem, el ) {

        // isHiddenWithinTree might be called from jQuery#filter function;
        // in that case, element will be second argument
        elem = el || elem;

        // Inline style trumps all
        return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
    };



    function adjustCSS( elem, prop, valueParts, tween ) {
        var adjusted, scale,
            maxIterations = 20,
            currentValue = tween ?
                function() {
                    return tween.cur();
                } :
                function() {
                    return jQuery.css( elem, prop, "" );
                },
            initial = currentValue(),
            unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

            // Starting value computation is required for potential unit mismatches
            initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

        if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

            // Support: Firefox <=54
            // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
            initial = initial / 2;

            // Trust units reported by jQuery.css
            unit = unit || initialInUnit[ 3 ];

            // Iteratively approximate from a nonzero starting point
            initialInUnit = +initial || 1;

            while ( maxIterations-- ) {

                // Evaluate and update our best guess (doubling guesses that zero out).
                // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
                jQuery.style( elem, prop, initialInUnit + unit );
                if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
                    maxIterations = 0;
                }
                initialInUnit = initialInUnit / scale;

            }

            initialInUnit = initialInUnit * 2;
            jQuery.style( elem, prop, initialInUnit + unit );

            // Make sure we update the tween properties later on
            valueParts = valueParts || [];
        }

        if ( valueParts ) {
            initialInUnit = +initialInUnit || +initial || 0;

            // Apply relative offset (+=/-=) if specified
            adjusted = valueParts[ 1 ] ?
                initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
                +valueParts[ 2 ];
            if ( tween ) {
                tween.unit = unit;
                tween.start = initialInUnit;
                tween.end = adjusted;
            }
        }
        return adjusted;
    }


    var defaultDisplayMap = {};

    function getDefaultDisplay( elem ) {
        var temp,
            doc = elem.ownerDocument,
            nodeName = elem.nodeName,
            display = defaultDisplayMap[ nodeName ];

        if ( display ) {
            return display;
        }

        temp = doc.body.appendChild( doc.createElement( nodeName ) );
        display = jQuery.css( temp, "display" );

        temp.parentNode.removeChild( temp );

        if ( display === "none" ) {
            display = "block";
        }
        defaultDisplayMap[ nodeName ] = display;

        return display;
    }

    function showHide( elements, show ) {
        var display, elem,
            values = [],
            index = 0,
            length = elements.length;

        // Determine new display value for elements that need to change
        for ( ; index < length; index++ ) {
            elem = elements[ index ];
            if ( !elem.style ) {
                continue;
            }

            display = elem.style.display;
            if ( show ) {

                // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
                // check is required in this first loop unless we have a nonempty display value (either
                // inline or about-to-be-restored)
                if ( display === "none" ) {
                    values[ index ] = dataPriv.get( elem, "display" ) || null;
                    if ( !values[ index ] ) {
                        elem.style.display = "";
                    }
                }
                if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
                    values[ index ] = getDefaultDisplay( elem );
                }
            } else {
                if ( display !== "none" ) {
                    values[ index ] = "none";

                    // Remember what we're overwriting
                    dataPriv.set( elem, "display", display );
                }
            }
        }

        // Set the display of the elements in a second loop to avoid constant reflow
        for ( index = 0; index < length; index++ ) {
            if ( values[ index ] != null ) {
                elements[ index ].style.display = values[ index ];
            }
        }

        return elements;
    }

    jQuery.fn.extend( {
        show: function() {
            return showHide( this, true );
        },
        hide: function() {
            return showHide( this );
        },
        toggle: function( state ) {
            if ( typeof state === "boolean" ) {
                return state ? this.show() : this.hide();
            }

            return this.each( function() {
                if ( isHiddenWithinTree( this ) ) {
                    jQuery( this ).show();
                } else {
                    jQuery( this ).hide();
                }
            } );
        }
    } );
    var rcheckableType = ( /^(?:checkbox|radio)$/i );

    var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

    var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



    ( function() {
        var fragment = document.createDocumentFragment(),
            div = fragment.appendChild( document.createElement( "div" ) ),
            input = document.createElement( "input" );

        // Support: Android 4.0 - 4.3 only
        // Check state lost if the name is set (#11217)
        // Support: Windows Web Apps (WWA)
        // `name` and `type` must use .setAttribute for WWA (#14901)
        input.setAttribute( "type", "radio" );
        input.setAttribute( "checked", "checked" );
        input.setAttribute( "name", "t" );

        div.appendChild( input );

        // Support: Android <=4.1 only
        // Older WebKit doesn't clone checked state correctly in fragments
        support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

        // Support: IE <=11 only
        // Make sure textarea (and checkbox) defaultValue is properly cloned
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

        // Support: IE <=9 only
        // IE <=9 replaces <option> tags with their contents when inserted outside of
        // the select element.
        div.innerHTML = "<option></option>";
        support.option = !!div.lastChild;
    } )();


    // We have to close these tags to support XHTML (#13200)
    var wrapMap = {

        // XHTML parsers do not magically insert elements in the
        // same way that tag soup parsers do. So we cannot shorten
        // this by omitting <tbody> or other required elements.
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

        _default: [ 0, "", "" ]
    };

    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;

    // Support: IE <=9 only
    if ( !support.option ) {
        wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
    }


    function getAll( context, tag ) {

        // Support: IE <=9 - 11 only
        // Use typeof to avoid zero-argument method invocation on host objects (#15151)
        var ret;

        if ( typeof context.getElementsByTagName !== "undefined" ) {
            ret = context.getElementsByTagName( tag || "*" );

        } else if ( typeof context.querySelectorAll !== "undefined" ) {
            ret = context.querySelectorAll( tag || "*" );

        } else {
            ret = [];
        }

        if ( tag === undefined || tag && nodeName( context, tag ) ) {
            return jQuery.merge( [ context ], ret );
        }

        return ret;
    }


    // Mark scripts as having already been evaluated
    function setGlobalEval( elems, refElements ) {
        var i = 0,
            l = elems.length;

        for ( ; i < l; i++ ) {
            dataPriv.set(
                elems[ i ],
                "globalEval",
                !refElements || dataPriv.get( refElements[ i ], "globalEval" )
            );
        }
    }


    var rhtml = /<|&#?\w+;/;

    function buildFragment( elems, context, scripts, selection, ignored ) {
        var elem, tmp, tag, wrap, attached, j,
            fragment = context.createDocumentFragment(),
            nodes = [],
            i = 0,
            l = elems.length;

        for ( ; i < l; i++ ) {
            elem = elems[ i ];

            if ( elem || elem === 0 ) {

                // Add nodes directly
                if ( toType( elem ) === "object" ) {

                    // Support: Android <=4.0 only, PhantomJS 1 only
                    // push.apply(_, arraylike) throws on ancient WebKit
                    jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

                    // Convert non-html into a text node
                } else if ( !rhtml.test( elem ) ) {
                    nodes.push( context.createTextNode( elem ) );

                    // Convert html into DOM nodes
                } else {
                    tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

                    // Deserialize a standard representation
                    tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
                    wrap = wrapMap[ tag ] || wrapMap._default;
                    tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

                    // Descend through wrappers to the right content
                    j = wrap[ 0 ];
                    while ( j-- ) {
                        tmp = tmp.lastChild;
                    }

                    // Support: Android <=4.0 only, PhantomJS 1 only
                    // push.apply(_, arraylike) throws on ancient WebKit
                    jQuery.merge( nodes, tmp.childNodes );

                    // Remember the top-level container
                    tmp = fragment.firstChild;

                    // Ensure the created nodes are orphaned (#12392)
                    tmp.textContent = "";
                }
            }
        }

        // Remove wrapper from fragment
        fragment.textContent = "";

        i = 0;
        while ( ( elem = nodes[ i++ ] ) ) {

            // Skip elements already in the context collection (trac-4087)
            if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
                if ( ignored ) {
                    ignored.push( elem );
                }
                continue;
            }

            attached = isAttached( elem );

            // Append to fragment
            tmp = getAll( fragment.appendChild( elem ), "script" );

            // Preserve script evaluation history
            if ( attached ) {
                setGlobalEval( tmp );
            }

            // Capture executables
            if ( scripts ) {
                j = 0;
                while ( ( elem = tmp[ j++ ] ) ) {
                    if ( rscriptType.test( elem.type || "" ) ) {
                        scripts.push( elem );
                    }
                }
            }
        }

        return fragment;
    }


    var
        rkeyEvent = /^key/,
        rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
        rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

    function returnTrue() {
        return true;
    }

    function returnFalse() {
        return false;
    }

    // Support: IE <=9 - 11+
    // focus() and blur() are asynchronous, except when they are no-op.
    // So expect focus to be synchronous when the element is already active,
    // and blur to be synchronous when the element is not already active.
    // (focus and blur are always synchronous in other supported browsers,
    // this just defines when we can count on it).
    function expectSync( elem, type ) {
        return ( elem === safeActiveElement() ) === ( type === "focus" );
    }

    // Support: IE <=9 only
    // Accessing document.activeElement can throw unexpectedly
    // https://bugs.jquery.com/ticket/13393
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch ( err ) { }
    }

    function on( elem, types, selector, data, fn, one ) {
        var origFn, type;

        // Types can be a map of types/handlers
        if ( typeof types === "object" ) {

            // ( types-Object, selector, data )
            if ( typeof selector !== "string" ) {

                // ( types-Object, data )
                data = data || selector;
                selector = undefined;
            }
            for ( type in types ) {
                on( elem, type, selector, data, types[ type ], one );
            }
            return elem;
        }

        if ( data == null && fn == null ) {

            // ( types, fn )
            fn = selector;
            data = selector = undefined;
        } else if ( fn == null ) {
            if ( typeof selector === "string" ) {

                // ( types, selector, fn )
                fn = data;
                data = undefined;
            } else {

                // ( types, data, fn )
                fn = data;
                data = selector;
                selector = undefined;
            }
        }
        if ( fn === false ) {
            fn = returnFalse;
        } else if ( !fn ) {
            return elem;
        }

        if ( one === 1 ) {
            origFn = fn;
            fn = function( event ) {

                // Can use an empty set, since event contains the info
                jQuery().off( event );
                return origFn.apply( this, arguments );
            };

            // Use same guid so caller can remove using origFn
            fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
        }
        return elem.each( function() {
            jQuery.event.add( this, types, fn, data, selector );
        } );
    }

    /*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
    jQuery.event = {

        global: {},

        add: function( elem, types, handler, data, selector ) {

            var handleObjIn, eventHandle, tmp,
                events, t, handleObj,
                special, handlers, type, namespaces, origType,
                elemData = dataPriv.get( elem );

            // Only attach events to objects that accept data
            if ( !acceptData( elem ) ) {
                return;
            }

            // Caller can pass in an object of custom data in lieu of the handler
            if ( handler.handler ) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }

            // Ensure that invalid selectors throw exceptions at attach time
            // Evaluate against documentElement in case elem is a non-element node (e.g., document)
            if ( selector ) {
                jQuery.find.matchesSelector( documentElement, selector );
            }

            // Make sure that the handler has a unique ID, used to find/remove it later
            if ( !handler.guid ) {
                handler.guid = jQuery.guid++;
            }

            // Init the element's event structure and main handler, if this is the first
            if ( !( events = elemData.events ) ) {
                events = elemData.events = Object.create( null );
            }
            if ( !( eventHandle = elemData.handle ) ) {
                eventHandle = elemData.handle = function( e ) {

                    // Discard the second event of a jQuery.event.trigger() and
                    // when an event is called after a page has unloaded
                    return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
                        jQuery.event.dispatch.apply( elem, arguments ) : undefined;
                };
            }

            // Handle multiple events separated by a space
            types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
            t = types.length;
            while ( t-- ) {
                tmp = rtypenamespace.exec( types[ t ] ) || [];
                type = origType = tmp[ 1 ];
                namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

                // There *must* be a type, no attaching namespace-only handlers
                if ( !type ) {
                    continue;
                }

                // If event changes its type, use the special event handlers for the changed type
                special = jQuery.event.special[ type ] || {};

                // If selector defined, determine special event api type, otherwise given type
                type = ( selector ? special.delegateType : special.bindType ) || type;

                // Update special based on newly reset type
                special = jQuery.event.special[ type ] || {};

                // handleObj is passed to all event handlers
                handleObj = jQuery.extend( {
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
                    namespace: namespaces.join( "." )
                }, handleObjIn );

                // Init the event handler queue if we're the first
                if ( !( handlers = events[ type ] ) ) {
                    handlers = events[ type ] = [];
                    handlers.delegateCount = 0;

                    // Only use addEventListener if the special events handler returns false
                    if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

                        if ( elem.addEventListener ) {
                            elem.addEventListener( type, eventHandle );
                        }
                    }
                }

                if ( special.add ) {
                    special.add.call( elem, handleObj );

                    if ( !handleObj.handler.guid ) {
                        handleObj.handler.guid = handler.guid;
                    }
                }

                // Add to the element's handler list, delegates in front
                if ( selector ) {
                    handlers.splice( handlers.delegateCount++, 0, handleObj );
                } else {
                    handlers.push( handleObj );
                }

                // Keep track of which events have ever been used, for event optimization
                jQuery.event.global[ type ] = true;
            }

        },

        // Detach an event or set of events from an element
        remove: function( elem, types, handler, selector, mappedTypes ) {

            var j, origCount, tmp,
                events, t, handleObj,
                special, handlers, type, namespaces, origType,
                elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

            if ( !elemData || !( events = elemData.events ) ) {
                return;
            }

            // Once for each type.namespace in types; type may be omitted
            types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
            t = types.length;
            while ( t-- ) {
                tmp = rtypenamespace.exec( types[ t ] ) || [];
                type = origType = tmp[ 1 ];
                namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

                // Unbind all events (on this namespace, if provided) for the element
                if ( !type ) {
                    for ( type in events ) {
                        jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
                    }
                    continue;
                }

                special = jQuery.event.special[ type ] || {};
                type = ( selector ? special.delegateType : special.bindType ) || type;
                handlers = events[ type ] || [];
                tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

                // Remove matching events
                origCount = j = handlers.length;
                while ( j-- ) {
                    handleObj = handlers[ j ];

                    if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
                        handlers.splice( j, 1 );

                        if ( handleObj.selector ) {
                            handlers.delegateCount--;
                        }
                        if ( special.remove ) {
                            special.remove.call( elem, handleObj );
                        }
                    }
                }

                // Remove generic event handler if we removed something and no more handlers exist
                // (avoids potential for endless recursion during removal of special event handlers)
                if ( origCount && !handlers.length ) {
                    if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

                        jQuery.removeEvent( elem, type, elemData.handle );
                    }

                    delete events[ type ];
                }
            }

            // Remove data and the expando if it's no longer used
            if ( jQuery.isEmptyObject( events ) ) {
                dataPriv.remove( elem, "handle events" );
            }
        },

        dispatch: function( nativeEvent ) {

            var i, j, ret, matched, handleObj, handlerQueue,
                args = new Array( arguments.length ),

                // Make a writable jQuery.Event from the native event object
                event = jQuery.event.fix( nativeEvent ),

                handlers = (
                    dataPriv.get( this, "events" ) || Object.create( null )
                )[ event.type ] || [],
                special = jQuery.event.special[ event.type ] || {};

            // Use the fix-ed jQuery.Event rather than the (read-only) native event
            args[ 0 ] = event;

            for ( i = 1; i < arguments.length; i++ ) {
                args[ i ] = arguments[ i ];
            }

            event.delegateTarget = this;

            // Call the preDispatch hook for the mapped type, and let it bail if desired
            if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
                return;
            }

            // Determine handlers
            handlerQueue = jQuery.event.handlers.call( this, event, handlers );

            // Run delegates first; they may want to stop propagation beneath us
            i = 0;
            while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
                event.currentTarget = matched.elem;

                j = 0;
                while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

                    // If the event is namespaced, then each handler is only invoked if it is
                    // specially universal or its namespaces are a superset of the event's.
                    if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

                        event.handleObj = handleObj;
                        event.data = handleObj.data;

                        ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

                        if ( ret !== undefined ) {
                            if ( ( event.result = ret ) === false ) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }

            // Call the postDispatch hook for the mapped type
            if ( special.postDispatch ) {
                special.postDispatch.call( this, event );
            }

            return event.result;
        },

        handlers: function( event, handlers ) {
            var i, handleObj, sel, matchedHandlers, matchedSelectors,
                handlerQueue = [],
                delegateCount = handlers.delegateCount,
                cur = event.target;

            // Find delegate handlers
            if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

                for ( ; cur !== this; cur = cur.parentNode || this ) {

                    // Don't check non-elements (#13208)
                    // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                    if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
                        matchedHandlers = [];
                        matchedSelectors = {};
                        for ( i = 0; i < delegateCount; i++ ) {
                            handleObj = handlers[ i ];

                            // Don't conflict with Object.prototype properties (#13203)
                            sel = handleObj.selector + " ";

                            if ( matchedSelectors[ sel ] === undefined ) {
                                matchedSelectors[ sel ] = handleObj.needsContext ?
                                    jQuery( sel, this ).index( cur ) > -1 :
                                    jQuery.find( sel, this, null, [ cur ] ).length;
                            }
                            if ( matchedSelectors[ sel ] ) {
                                matchedHandlers.push( handleObj );
                            }
                        }
                        if ( matchedHandlers.length ) {
                            handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
                        }
                    }
                }
            }

            // Add the remaining (directly-bound) handlers
            cur = this;
            if ( delegateCount < handlers.length ) {
                handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
            }

            return handlerQueue;
        },

        addProp: function( name, hook ) {
            Object.defineProperty( jQuery.Event.prototype, name, {
                enumerable: true,
                configurable: true,

                get: isFunction( hook ) ?
                    function() {
                        if ( this.originalEvent ) {
                            return hook( this.originalEvent );
                        }
                    } :
                    function() {
                        if ( this.originalEvent ) {
                            return this.originalEvent[ name ];
                        }
                    },

                set: function( value ) {
                    Object.defineProperty( this, name, {
                        enumerable: true,
                        configurable: true,
                        writable: true,
                        value: value
                    } );
                }
            } );
        },

        fix: function( originalEvent ) {
            return originalEvent[ jQuery.expando ] ?
                originalEvent :
                new jQuery.Event( originalEvent );
        },

        special: {
            load: {

                // Prevent triggered image.load events from bubbling to window.load
                noBubble: true
            },
            click: {

                // Utilize native event to ensure correct state for checkable inputs
                setup: function( data ) {

                    // For mutual compressibility with _default, replace `this` access with a local var.
                    // `|| data` is dead code meant only to preserve the variable through minification.
                    var el = this || data;

                    // Claim the first handler
                    if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

                        // dataPriv.set( el, "click", ... )
                        leverageNative( el, "click", returnTrue );
                    }

                    // Return false to allow normal processing in the caller
                    return false;
                },
                trigger: function( data ) {

                    // For mutual compressibility with _default, replace `this` access with a local var.
                    // `|| data` is dead code meant only to preserve the variable through minification.
                    var el = this || data;

                    // Force setup before triggering a click
                    if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

                        leverageNative( el, "click" );
                    }

                    // Return non-false to allow normal event-path propagation
                    return true;
                },

                // For cross-browser consistency, suppress native .click() on links
                // Also prevent it if we're currently inside a leveraged native-event stack
                _default: function( event ) {
                    var target = event.target;
                    return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
                }
            },

            beforeunload: {
                postDispatch: function( event ) {

                    // Support: Firefox 20+
                    // Firefox doesn't alert if the returnValue field is not set.
                    if ( event.result !== undefined && event.originalEvent ) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        }
    };

    // Ensure the presence of an event listener that handles manually-triggered
    // synthetic events by interrupting progress until reinvoked in response to
    // *native* events that it fires directly, ensuring that state changes have
    // already occurred before other listeners are invoked.
    function leverageNative( el, type, expectSync ) {

        // Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
        if ( !expectSync ) {
            if ( dataPriv.get( el, type ) === undefined ) {
                jQuery.event.add( el, type, returnTrue );
            }
            return;
        }

        // Register the controller as a special universal handler for all event namespaces
        dataPriv.set( el, type, false );
        jQuery.event.add( el, type, {
            namespace: false,
            handler: function( event ) {
                var notAsync, result,
                    saved = dataPriv.get( this, type );

                if ( ( event.isTrigger & 1 ) && this[ type ] ) {

                    // Interrupt processing of the outer synthetic .trigger()ed event
                    // Saved data should be false in such cases, but might be a leftover capture object
                    // from an async native handler (gh-4350)
                    if ( !saved.length ) {

                        // Store arguments for use when handling the inner native event
                        // There will always be at least one argument (an event object), so this array
                        // will not be confused with a leftover capture object.
                        saved = slice.call( arguments );
                        dataPriv.set( this, type, saved );

                        // Trigger the native event and capture its result
                        // Support: IE <=9 - 11+
                        // focus() and blur() are asynchronous
                        notAsync = expectSync( this, type );
                        this[ type ]();
                        result = dataPriv.get( this, type );
                        if ( saved !== result || notAsync ) {
                            dataPriv.set( this, type, false );
                        } else {
                            result = {};
                        }
                        if ( saved !== result ) {

                            // Cancel the outer synthetic event
                            event.stopImmediatePropagation();
                            event.preventDefault();
                            return result.value;
                        }

                        // If this is an inner synthetic event for an event with a bubbling surrogate
                        // (focus or blur), assume that the surrogate already propagated from triggering the
                        // native event and prevent that from happening again here.
                        // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
                        // bubbling surrogate propagates *after* the non-bubbling base), but that seems
                        // less bad than duplication.
                    } else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
                        event.stopPropagation();
                    }

                    // If this is a native event triggered above, everything is now in order
                    // Fire an inner synthetic event with the original arguments
                } else if ( saved.length ) {

                    // ...and capture the result
                    dataPriv.set( this, type, {
                        value: jQuery.event.trigger(

                            // Support: IE <=9 - 11+
                            // Extend with the prototype to reset the above stopImmediatePropagation()
                            jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
                            saved.slice( 1 ),
                            this
                        )
                    } );

                    // Abort handling of the native event
                    event.stopImmediatePropagation();
                }
            }
        } );
    }

    jQuery.removeEvent = function( elem, type, handle ) {

        // This "if" is needed for plain objects
        if ( elem.removeEventListener ) {
            elem.removeEventListener( type, handle );
        }
    };

    jQuery.Event = function( src, props ) {

        // Allow instantiation without the 'new' keyword
        if ( !( this instanceof jQuery.Event ) ) {
            return new jQuery.Event( src, props );
        }

        // Event object
        if ( src && src.type ) {
            this.originalEvent = src;
            this.type = src.type;

            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
                returnTrue :
                returnFalse;

            // Create target properties
            // Support: Safari <=6 - 7 only
            // Target should not be a text node (#504, #13143)
            this.target = ( src.target && src.target.nodeType === 3 ) ?
                src.target.parentNode :
                src.target;

            this.currentTarget = src.currentTarget;
            this.relatedTarget = src.relatedTarget;

            // Event type
        } else {
            this.type = src;
        }

        // Put explicitly provided properties onto the event object
        if ( props ) {
            jQuery.extend( this, props );
        }

        // Create a timestamp if incoming event doesn't have one
        this.timeStamp = src && src.timeStamp || Date.now();

        // Mark it as fixed
        this[ jQuery.expando ] = true;
    };

    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,

        preventDefault: function() {
            var e = this.originalEvent;

            this.isDefaultPrevented = returnTrue;

            if ( e && !this.isSimulated ) {
                e.preventDefault();
            }
        },
        stopPropagation: function() {
            var e = this.originalEvent;

            this.isPropagationStopped = returnTrue;

            if ( e && !this.isSimulated ) {
                e.stopPropagation();
            }
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;

            this.isImmediatePropagationStopped = returnTrue;

            if ( e && !this.isSimulated ) {
                e.stopImmediatePropagation();
            }

            this.stopPropagation();
        }
    };

    // Includes all common event props including KeyEvent and MouseEvent specific props
    jQuery.each( {
        altKey: true,
        bubbles: true,
        cancelable: true,
        changedTouches: true,
        ctrlKey: true,
        detail: true,
        eventPhase: true,
        metaKey: true,
        pageX: true,
        pageY: true,
        shiftKey: true,
        view: true,
        "char": true,
        code: true,
        charCode: true,
        key: true,
        keyCode: true,
        button: true,
        buttons: true,
        clientX: true,
        clientY: true,
        offsetX: true,
        offsetY: true,
        pointerId: true,
        pointerType: true,
        screenX: true,
        screenY: true,
        targetTouches: true,
        toElement: true,
        touches: true,

        which: function( event ) {
            var button = event.button;

            // Add which for key events
            if ( event.which == null && rkeyEvent.test( event.type ) ) {
                return event.charCode != null ? event.charCode : event.keyCode;
            }

            // Add which for click: 1 === left; 2 === middle; 3 === right
            if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
                if ( button & 1 ) {
                    return 1;
                }

                if ( button & 2 ) {
                    return 3;
                }

                if ( button & 4 ) {
                    return 2;
                }

                return 0;
            }

            return event.which;
        }
    }, jQuery.event.addProp );

    jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
        jQuery.event.special[ type ] = {

            // Utilize native event if possible so blur/focus sequence is correct
            setup: function() {

                // Claim the first handler
                // dataPriv.set( this, "focus", ... )
                // dataPriv.set( this, "blur", ... )
                leverageNative( this, type, expectSync );

                // Return false to allow normal processing in the caller
                return false;
            },
            trigger: function() {

                // Force setup before trigger
                leverageNative( this, type );

                // Return non-false to allow normal event-path propagation
                return true;
            },

            delegateType: delegateType
        };
    } );

    // Create mouseenter/leave events using mouseover/out and event-time checks
    // so that event delegation works in jQuery.
    // Do the same for pointerenter/pointerleave and pointerover/pointerout
    //
    // Support: Safari 7 only
    // Safari sends mouseenter too often; see:
    // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
    // for the description of the bug (it existed in older Chrome versions as well).
    jQuery.each( {
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function( orig, fix ) {
        jQuery.event.special[ orig ] = {
            delegateType: fix,
            bindType: fix,

            handle: function( event ) {
                var ret,
                    target = this,
                    related = event.relatedTarget,
                    handleObj = event.handleObj;

                // For mouseenter/leave call the handler if related is outside the target.
                // NB: No relatedTarget if the mouse left/entered the browser window
                if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply( this, arguments );
                    event.type = fix;
                }
                return ret;
            }
        };
    } );

    jQuery.fn.extend( {

        on: function( types, selector, data, fn ) {
            return on( this, types, selector, data, fn );
        },
        one: function( types, selector, data, fn ) {
            return on( this, types, selector, data, fn, 1 );
        },
        off: function( types, selector, fn ) {
            var handleObj, type;
            if ( types && types.preventDefault && types.handleObj ) {

                // ( event )  dispatched jQuery.Event
                handleObj = types.handleObj;
                jQuery( types.delegateTarget ).off(
                    handleObj.namespace ?
                        handleObj.origType + "." + handleObj.namespace :
                        handleObj.origType,
                    handleObj.selector,
                    handleObj.handler
                );
                return this;
            }
            if ( typeof types === "object" ) {

                // ( types-object [, selector] )
                for ( type in types ) {
                    this.off( type, selector, types[ type ] );
                }
                return this;
            }
            if ( selector === false || typeof selector === "function" ) {

                // ( types [, fn] )
                fn = selector;
                selector = undefined;
            }
            if ( fn === false ) {
                fn = returnFalse;
            }
            return this.each( function() {
                jQuery.event.remove( this, types, fn, selector );
            } );
        }
    } );


    var

        // Support: IE <=10 - 11, Edge 12 - 13 only
        // In IE/Edge using regex groups here causes severe slowdowns.
        // See https://connect.microsoft.com/IE/feedback/details/1736512/
        rnoInnerhtml = /<script|<style|<link/i,

        // checked="checked" or checked
        rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
        rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

    // Prefer a tbody over its parent table for containing new rows
    function manipulationTarget( elem, content ) {
        if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

            return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
        }

        return elem;
    }

    // Replace/restore the type attribute of script elements for safe DOM manipulation
    function disableScript( elem ) {
        elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
        return elem;
    }
    function restoreScript( elem ) {
        if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
            elem.type = elem.type.slice( 5 );
        } else {
            elem.removeAttribute( "type" );
        }

        return elem;
    }

    function cloneCopyEvent( src, dest ) {
        var i, l, type, pdataOld, udataOld, udataCur, events;

        if ( dest.nodeType !== 1 ) {
            return;
        }

        // 1. Copy private data: events, handlers, etc.
        if ( dataPriv.hasData( src ) ) {
            pdataOld = dataPriv.get( src );
            events = pdataOld.events;

            if ( events ) {
                dataPriv.remove( dest, "handle events" );

                for ( type in events ) {
                    for ( i = 0, l = events[ type ].length; i < l; i++ ) {
                        jQuery.event.add( dest, type, events[ type ][ i ] );
                    }
                }
            }
        }

        // 2. Copy user data
        if ( dataUser.hasData( src ) ) {
            udataOld = dataUser.access( src );
            udataCur = jQuery.extend( {}, udataOld );

            dataUser.set( dest, udataCur );
        }
    }

    // Fix IE bugs, see support tests
    function fixInput( src, dest ) {
        var nodeName = dest.nodeName.toLowerCase();

        // Fails to persist the checked state of a cloned checkbox or radio button.
        if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
            dest.checked = src.checked;

            // Fails to return the selected option to the default selected state when cloning options
        } else if ( nodeName === "input" || nodeName === "textarea" ) {
            dest.defaultValue = src.defaultValue;
        }
    }

    function domManip( collection, args, callback, ignored ) {

        // Flatten any nested arrays
        args = flat( args );

        var fragment, first, scripts, hasScripts, node, doc,
            i = 0,
            l = collection.length,
            iNoClone = l - 1,
            value = args[ 0 ],
            valueIsFunction = isFunction( value );

        // We can't cloneNode fragments that contain checked, in WebKit
        if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
            return collection.each( function( index ) {
                var self = collection.eq( index );
                if ( valueIsFunction ) {
                    args[ 0 ] = value.call( this, index, self.html() );
                }
                domManip( self, args, callback, ignored );
            } );
        }

        if ( l ) {
            fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
            first = fragment.firstChild;

            if ( fragment.childNodes.length === 1 ) {
                fragment = first;
            }

            // Require either new content or an interest in ignored elements to invoke the callback
            if ( first || ignored ) {
                scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
                hasScripts = scripts.length;

                // Use the original fragment for the last item
                // instead of the first because it can end up
                // being emptied incorrectly in certain situations (#8070).
                for ( ; i < l; i++ ) {
                    node = fragment;

                    if ( i !== iNoClone ) {
                        node = jQuery.clone( node, true, true );

                        // Keep references to cloned scripts for later restoration
                        if ( hasScripts ) {

                            // Support: Android <=4.0 only, PhantomJS 1 only
                            // push.apply(_, arraylike) throws on ancient WebKit
                            jQuery.merge( scripts, getAll( node, "script" ) );
                        }
                    }

                    callback.call( collection[ i ], node, i );
                }

                if ( hasScripts ) {
                    doc = scripts[ scripts.length - 1 ].ownerDocument;

                    // Reenable scripts
                    jQuery.map( scripts, restoreScript );

                    // Evaluate executable scripts on first document insertion
                    for ( i = 0; i < hasScripts; i++ ) {
                        node = scripts[ i ];
                        if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

                            if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

                                // Optional AJAX dependency, but won't run scripts if not present
                                if ( jQuery._evalUrl && !node.noModule ) {
                                    jQuery._evalUrl( node.src, {
                                        nonce: node.nonce || node.getAttribute( "nonce" )
                                    }, doc );
                                }
                            } else {
                                DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
                            }
                        }
                    }
                }
            }
        }

        return collection;
    }

    function remove( elem, selector, keepData ) {
        var node,
            nodes = selector ? jQuery.filter( selector, elem ) : elem,
            i = 0;

        for ( ; ( node = nodes[ i ] ) != null; i++ ) {
            if ( !keepData && node.nodeType === 1 ) {
                jQuery.cleanData( getAll( node ) );
            }

            if ( node.parentNode ) {
                if ( keepData && isAttached( node ) ) {
                    setGlobalEval( getAll( node, "script" ) );
                }
                node.parentNode.removeChild( node );
            }
        }

        return elem;
    }

    jQuery.extend( {
        htmlPrefilter: function( html ) {
            return html;
        },

        clone: function( elem, dataAndEvents, deepDataAndEvents ) {
            var i, l, srcElements, destElements,
                clone = elem.cloneNode( true ),
                inPage = isAttached( elem );

            // Fix IE cloning issues
            if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

                // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
                destElements = getAll( clone );
                srcElements = getAll( elem );

                for ( i = 0, l = srcElements.length; i < l; i++ ) {
                    fixInput( srcElements[ i ], destElements[ i ] );
                }
            }

            // Copy the events from the original to the clone
            if ( dataAndEvents ) {
                if ( deepDataAndEvents ) {
                    srcElements = srcElements || getAll( elem );
                    destElements = destElements || getAll( clone );

                    for ( i = 0, l = srcElements.length; i < l; i++ ) {
                        cloneCopyEvent( srcElements[ i ], destElements[ i ] );
                    }
                } else {
                    cloneCopyEvent( elem, clone );
                }
            }

            // Preserve script evaluation history
            destElements = getAll( clone, "script" );
            if ( destElements.length > 0 ) {
                setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
            }

            // Return the cloned set
            return clone;
        },

        cleanData: function( elems ) {
            var data, elem, type,
                special = jQuery.event.special,
                i = 0;

            for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
                if ( acceptData( elem ) ) {
                    if ( ( data = elem[ dataPriv.expando ] ) ) {
                        if ( data.events ) {
                            for ( type in data.events ) {
                                if ( special[ type ] ) {
                                    jQuery.event.remove( elem, type );

                                    // This is a shortcut to avoid jQuery.event.remove's overhead
                                } else {
                                    jQuery.removeEvent( elem, type, data.handle );
                                }
                            }
                        }

                        // Support: Chrome <=35 - 45+
                        // Assign undefined instead of using delete, see Data#remove
                        elem[ dataPriv.expando ] = undefined;
                    }
                    if ( elem[ dataUser.expando ] ) {

                        // Support: Chrome <=35 - 45+
                        // Assign undefined instead of using delete, see Data#remove
                        elem[ dataUser.expando ] = undefined;
                    }
                }
            }
        }
    } );

    jQuery.fn.extend( {
        detach: function( selector ) {
            return remove( this, selector, true );
        },

        remove: function( selector ) {
            return remove( this, selector );
        },

        text: function( value ) {
            return access( this, function( value ) {
                return value === undefined ?
                    jQuery.text( this ) :
                    this.empty().each( function() {
                        if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                            this.textContent = value;
                        }
                    } );
            }, null, value, arguments.length );
        },

        append: function() {
            return domManip( this, arguments, function( elem ) {
                if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                    var target = manipulationTarget( this, elem );
                    target.appendChild( elem );
                }
            } );
        },

        prepend: function() {
            return domManip( this, arguments, function( elem ) {
                if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                    var target = manipulationTarget( this, elem );
                    target.insertBefore( elem, target.firstChild );
                }
            } );
        },

        before: function() {
            return domManip( this, arguments, function( elem ) {
                if ( this.parentNode ) {
                    this.parentNode.insertBefore( elem, this );
                }
            } );
        },

        after: function() {
            return domManip( this, arguments, function( elem ) {
                if ( this.parentNode ) {
                    this.parentNode.insertBefore( elem, this.nextSibling );
                }
            } );
        },

        empty: function() {
            var elem,
                i = 0;

            for ( ; ( elem = this[ i ] ) != null; i++ ) {
                if ( elem.nodeType === 1 ) {

                    // Prevent memory leaks
                    jQuery.cleanData( getAll( elem, false ) );

                    // Remove any remaining nodes
                    elem.textContent = "";
                }
            }

            return this;
        },

        clone: function( dataAndEvents, deepDataAndEvents ) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

            return this.map( function() {
                return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
            } );
        },

        html: function( value ) {
            return access( this, function( value ) {
                var elem = this[ 0 ] || {},
                    i = 0,
                    l = this.length;

                if ( value === undefined && elem.nodeType === 1 ) {
                    return elem.innerHTML;
                }

                // See if we can take a shortcut and just use innerHTML
                if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

                    value = jQuery.htmlPrefilter( value );

                    try {
                        for ( ; i < l; i++ ) {
                            elem = this[ i ] || {};

                            // Remove element nodes and prevent memory leaks
                            if ( elem.nodeType === 1 ) {
                                jQuery.cleanData( getAll( elem, false ) );
                                elem.innerHTML = value;
                            }
                        }

                        elem = 0;

                        // If using innerHTML throws an exception, use the fallback method
                    } catch ( e ) {}
                }

                if ( elem ) {
                    this.empty().append( value );
                }
            }, null, value, arguments.length );
        },

        replaceWith: function() {
            var ignored = [];

            // Make the changes, replacing each non-ignored context element with the new content
            return domManip( this, arguments, function( elem ) {
                var parent = this.parentNode;

                if ( jQuery.inArray( this, ignored ) < 0 ) {
                    jQuery.cleanData( getAll( this ) );
                    if ( parent ) {
                        parent.replaceChild( elem, this );
                    }
                }

                // Force callback invocation
            }, ignored );
        }
    } );

    jQuery.each( {
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function( name, original ) {
        jQuery.fn[ name ] = function( selector ) {
            var elems,
                ret = [],
                insert = jQuery( selector ),
                last = insert.length - 1,
                i = 0;

            for ( ; i <= last; i++ ) {
                elems = i === last ? this : this.clone( true );
                jQuery( insert[ i ] )[ original ]( elems );

                // Support: Android <=4.0 only, PhantomJS 1 only
                // .get() because push.apply(_, arraylike) throws on ancient WebKit
                push.apply( ret, elems.get() );
            }

            return this.pushStack( ret );
        };
    } );
    var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

    var getStyles = function( elem ) {

        // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
        // IE throws on elements created in popups
        // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
        var view = elem.ownerDocument.defaultView;

        if ( !view || !view.opener ) {
            view = window;
        }

        return view.getComputedStyle( elem );
    };

    var swap = function( elem, options, callback ) {
        var ret, name,
            old = {};

        // Remember the old values, and insert the new ones
        for ( name in options ) {
            old[ name ] = elem.style[ name ];
            elem.style[ name ] = options[ name ];
        }

        ret = callback.call( elem );

        // Revert the old values
        for ( name in options ) {
            elem.style[ name ] = old[ name ];
        }

        return ret;
    };


    var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



    ( function() {

        // Executing both pixelPosition & boxSizingReliable tests require only one layout
        // so they're executed at the same time to save the second computation.
        function computeStyleTests() {

            // This is a singleton, we need to execute it only once
            if ( !div ) {
                return;
            }

            container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
            div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
            documentElement.appendChild( container ).appendChild( div );

            var divStyle = window.getComputedStyle( div );
            pixelPositionVal = divStyle.top !== "1%";

            // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
            reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

            // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
            // Some styles come back with percentage values, even though they shouldn't
            div.style.right = "60%";
            pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

            // Support: IE 9 - 11 only
            // Detect misreporting of content dimensions for box-sizing:border-box elements
            boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

            // Support: IE 9 only
            // Detect overflow:scroll screwiness (gh-3699)
            // Support: Chrome <=64
            // Don't get tricked when zoom affects offsetWidth (gh-4029)
            div.style.position = "absolute";
            scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

            documentElement.removeChild( container );

            // Nullify the div so it wouldn't be stored in the memory and
            // it will also be a sign that checks already performed
            div = null;
        }

        function roundPixelMeasures( measure ) {
            return Math.round( parseFloat( measure ) );
        }

        var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
            reliableTrDimensionsVal, reliableMarginLeftVal,
            container = document.createElement( "div" ),
            div = document.createElement( "div" );

        // Finish early in limited (non-browser) environments
        if ( !div.style ) {
            return;
        }

        // Support: IE <=9 - 11 only
        // Style of cloned element affects source element cloned (#8908)
        div.style.backgroundClip = "content-box";
        div.cloneNode( true ).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";

        jQuery.extend( support, {
            boxSizingReliable: function() {
                computeStyleTests();
                return boxSizingReliableVal;
            },
            pixelBoxStyles: function() {
                computeStyleTests();
                return pixelBoxStylesVal;
            },
            pixelPosition: function() {
                computeStyleTests();
                return pixelPositionVal;
            },
            reliableMarginLeft: function() {
                computeStyleTests();
                return reliableMarginLeftVal;
            },
            scrollboxSize: function() {
                computeStyleTests();
                return scrollboxSizeVal;
            },

            // Support: IE 9 - 11+, Edge 15 - 18+
            // IE/Edge misreport `getComputedStyle` of table rows with width/height
            // set in CSS while `offset*` properties report correct values.
            // Behavior in IE 9 is more subtle than in newer versions & it passes
            // some versions of this test; make sure not to make it pass there!
            reliableTrDimensions: function() {
                var table, tr, trChild, trStyle;
                if ( reliableTrDimensionsVal == null ) {
                    table = document.createElement( "table" );
                    tr = document.createElement( "tr" );
                    trChild = document.createElement( "div" );

                    table.style.cssText = "position:absolute;left:-11111px";
                    tr.style.height = "1px";
                    trChild.style.height = "9px";

                    documentElement
                        .appendChild( table )
                        .appendChild( tr )
                        .appendChild( trChild );

                    trStyle = window.getComputedStyle( tr );
                    reliableTrDimensionsVal = parseInt( trStyle.height ) > 3;

                    documentElement.removeChild( table );
                }
                return reliableTrDimensionsVal;
            }
        } );
    } )();


    function curCSS( elem, name, computed ) {
        var width, minWidth, maxWidth, ret,

            // Support: Firefox 51+
            // Retrieving style before computed somehow
            // fixes an issue with getting wrong values
            // on detached elements
            style = elem.style;

        computed = computed || getStyles( elem );

        // getPropertyValue is needed for:
        //   .css('filter') (IE 9 only, #12537)
        //   .css('--customProperty) (#3144)
        if ( computed ) {
            ret = computed.getPropertyValue( name ) || computed[ name ];

            if ( ret === "" && !isAttached( elem ) ) {
                ret = jQuery.style( elem, name );
            }

            // A tribute to the "awesome hack by Dean Edwards"
            // Android Browser returns percentage for some values,
            // but width seems to be reliably pixels.
            // This is against the CSSOM draft spec:
            // https://drafts.csswg.org/cssom/#resolved-values
            if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

                // Remember the original values
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;

                // Put in the new values to get a computed value out
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;

                // Revert the changed values
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }

        return ret !== undefined ?

        // Support: IE <=9 - 11 only
        // IE returns zIndex value as an integer.
            ret + "" :
            ret;
    }


    function addGetHookIf( conditionFn, hookFn ) {

        // Define the hook, we'll check on the first run if it's really needed.
        return {
            get: function() {
                if ( conditionFn() ) {

                    // Hook not needed (or it's not possible to use it due
                    // to missing dependency), remove it.
                    delete this.get;
                    return;
                }

                // Hook needed; redefine it so that the support test is not executed again.
                return ( this.get = hookFn ).apply( this, arguments );
            }
        };
    }


    var cssPrefixes = [ "Webkit", "Moz", "ms" ],
        emptyStyle = document.createElement( "div" ).style,
        vendorProps = {};

    // Return a vendor-prefixed property or undefined
    function vendorPropName( name ) {

        // Check for vendor prefixed names
        var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
            i = cssPrefixes.length;

        while ( i-- ) {
            name = cssPrefixes[ i ] + capName;
            if ( name in emptyStyle ) {
                return name;
            }
        }
    }

    // Return a potentially-mapped jQuery.cssProps or vendor prefixed property
    function finalPropName( name ) {
        var final = jQuery.cssProps[ name ] || vendorProps[ name ];

        if ( final ) {
            return final;
        }
        if ( name in emptyStyle ) {
            return name;
        }
        return vendorProps[ name ] = vendorPropName( name ) || name;
    }


    var

        // Swappable if display is none or starts with table
        // except "table", "table-cell", or "table-caption"
        // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
        rdisplayswap = /^(none|table(?!-c[ea]).+)/,
        rcustomProp = /^--/,
        cssShow = { position: "absolute", visibility: "hidden", display: "block" },
        cssNormalTransform = {
            letterSpacing: "0",
            fontWeight: "400"
        };

    function setPositiveNumber( _elem, value, subtract ) {

        // Any relative (+/-) values have already been
        // normalized at this point
        var matches = rcssNum.exec( value );
        return matches ?

        // Guard against undefined "subtract", e.g., when used as in cssHooks
            Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
            value;
    }

    function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
        var i = dimension === "width" ? 1 : 0,
            extra = 0,
            delta = 0;

        // Adjustment may not be necessary
        if ( box === ( isBorderBox ? "border" : "content" ) ) {
            return 0;
        }

        for ( ; i < 4; i += 2 ) {

            // Both box models exclude margin
            if ( box === "margin" ) {
                delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
            }

            // If we get here with a content-box, we're seeking "padding" or "border" or "margin"
            if ( !isBorderBox ) {

                // Add padding
                delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

                // For "border" or "margin", add border
                if ( box !== "padding" ) {
                    delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

                    // But still keep track of it otherwise
                } else {
                    extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
                }

                // If we get here with a border-box (content + padding + border), we're seeking "content" or
                // "padding" or "margin"
            } else {

                // For "content", subtract padding
                if ( box === "content" ) {
                    delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
                }

                // For "content" or "padding", subtract border
                if ( box !== "margin" ) {
                    delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
                }
            }
        }

        // Account for positive content-box scroll gutter when requested by providing computedVal
        if ( !isBorderBox && computedVal >= 0 ) {

            // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
            // Assuming integer scroll gutter, subtract the rest and round down
            delta += Math.max( 0, Math.ceil(
                elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

                // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
                // Use an explicit zero to avoid NaN (gh-3964)
            ) ) || 0;
        }

        return delta;
    }

    function getWidthOrHeight( elem, dimension, extra ) {

        // Start with computed style
        var styles = getStyles( elem ),

            // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
            // Fake content-box until we know it's needed to know the true value.
            boxSizingNeeded = !support.boxSizingReliable() || extra,
            isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
            valueIsBorderBox = isBorderBox,

            val = curCSS( elem, dimension, styles ),
            offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

        // Support: Firefox <=54
        // Return a confounding non-pixel value or feign ignorance, as appropriate.
        if ( rnumnonpx.test( val ) ) {
            if ( !extra ) {
                return val;
            }
            val = "auto";
        }


        // Support: IE 9 - 11 only
        // Use offsetWidth/offsetHeight for when box sizing is unreliable.
        // In those cases, the computed value can be trusted to be border-box.
        if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

            isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

            // Where available, offsetWidth/offsetHeight approximate border box dimensions.
            // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
            // retrieved value as a content box dimension.
            valueIsBorderBox = offsetProp in elem;
            if ( valueIsBorderBox ) {
                val = elem[ offsetProp ];
            }
        }

        // Normalize "" and auto
        val = parseFloat( val ) || 0;

        // Adjust for the element's box model
        return ( val +
		boxModelAdjustment(
		    elem,
		    dimension,
		    extra || ( isBorderBox ? "border" : "content" ),
		    valueIsBorderBox,
		    styles,

		    // Provide the current computed size to request scroll gutter calculation (gh-3589)
		    val
		)
        ) + "px";
    }

    jQuery.extend( {

        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function( elem, computed ) {
                    if ( computed ) {

                        // We should always get a number back from opacity
                        var ret = curCSS( elem, "opacity" );
                        return ret === "" ? "1" : ret;
                    }
                }
            }
        },

        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
            "animationIterationCount": true,
            "columnCount": true,
            "fillOpacity": true,
            "flexGrow": true,
            "flexShrink": true,
            "fontWeight": true,
            "gridArea": true,
            "gridColumn": true,
            "gridColumnEnd": true,
            "gridColumnStart": true,
            "gridRow": true,
            "gridRowEnd": true,
            "gridRowStart": true,
            "lineHeight": true,
            "opacity": true,
            "order": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
        },

        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {},

        // Get and set the style property on a DOM Node
        style: function( elem, name, value, extra ) {

            // Don't set styles on text and comment nodes
            if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
                return;
            }

            // Make sure that we're working with the right name
            var ret, type, hooks,
                origName = camelCase( name ),
                isCustomProp = rcustomProp.test( name ),
                style = elem.style;

            // Make sure that we're working with the right name. We don't
            // want to query the value if it is a CSS custom property
            // since they are user-defined.
            if ( !isCustomProp ) {
                name = finalPropName( origName );
            }

            // Gets hook for the prefixed version, then unprefixed version
            hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

            // Check if we're setting a value
            if ( value !== undefined ) {
                type = typeof value;

                // Convert "+=" or "-=" to relative numbers (#7345)
                if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
                    value = adjustCSS( elem, name, ret );

                    // Fixes bug #9237
                    type = "number";
                }

                // Make sure that null and NaN values aren't set (#7116)
                if ( value == null || value !== value ) {
                    return;
                }

                // If a number was passed in, add the unit (except for certain CSS properties)
                // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
                // "px" to a few hardcoded values.
                if ( type === "number" && !isCustomProp ) {
                    value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
                }

                // background-* props affect original clone's values
                if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
                    style[ name ] = "inherit";
                }

                // If a hook was provided, use that value, otherwise just set the specified value
                if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

                    if ( isCustomProp ) {
                        style.setProperty( name, value );
                    } else {
                        style[ name ] = value;
                    }
                }

            } else {

                // If a hook was provided get the non-computed value from there
                if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

                    return ret;
                }

                // Otherwise just get the value from the style object
                return style[ name ];
            }
        },

        css: function( elem, name, extra, styles ) {
            var val, num, hooks,
                origName = camelCase( name ),
                isCustomProp = rcustomProp.test( name );

            // Make sure that we're working with the right name. We don't
            // want to modify the value if it is a CSS custom property
            // since they are user-defined.
            if ( !isCustomProp ) {
                name = finalPropName( origName );
            }

            // Try prefixed name followed by the unprefixed name
            hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

            // If a hook was provided get the computed value from there
            if ( hooks && "get" in hooks ) {
                val = hooks.get( elem, true, extra );
            }

            // Otherwise, if a way to get the computed value exists, use that
            if ( val === undefined ) {
                val = curCSS( elem, name, styles );
            }

            // Convert "normal" to computed value
            if ( val === "normal" && name in cssNormalTransform ) {
                val = cssNormalTransform[ name ];
            }

            // Make numeric if forced or a qualifier was provided and val looks numeric
            if ( extra === "" || extra ) {
                num = parseFloat( val );
                return extra === true || isFinite( num ) ? num || 0 : val;
            }

            return val;
        }
    } );

    jQuery.each( [ "height", "width" ], function( _i, dimension ) {
        jQuery.cssHooks[ dimension ] = {
            get: function( elem, computed, extra ) {
                if ( computed ) {

                    // Certain elements can have dimension info if we invisibly show them
                    // but it must have a current display style that would benefit
                    return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
                        swap( elem, cssShow, function() {
                            return getWidthOrHeight( elem, dimension, extra );
                        } ) :
                        getWidthOrHeight( elem, dimension, extra );
                }
            },

            set: function( elem, value, extra ) {
                var matches,
                    styles = getStyles( elem ),

                    // Only read styles.position if the test has a chance to fail
                    // to avoid forcing a reflow.
                    scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

                    // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
                    boxSizingNeeded = scrollboxSizeBuggy || extra,
                    isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
                    subtract = extra ?
                        boxModelAdjustment(
                            elem,
                            dimension,
                            extra,
                            isBorderBox,
                            styles
                        ) :
                        0;

                // Account for unreliable border-box dimensions by comparing offset* to computed and
                // faking a content-box to get border and padding (gh-3699)
                if ( isBorderBox && scrollboxSizeBuggy ) {
                    subtract -= Math.ceil(
                        elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
                    );
                }

                // Convert to pixels if value adjustment is needed
                if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

                    elem.style[ dimension ] = value;
                    value = jQuery.css( elem, dimension );
                }

                return setPositiveNumber( elem, value, subtract );
            }
        };
    } );

    jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
        function( elem, computed ) {
            if ( computed ) {
                return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
					    return elem.getBoundingClientRect().left;
					} )
                ) + "px";
            }
        }
    );

    // These hooks are used by animate to expand properties
    jQuery.each( {
        margin: "",
        padding: "",
        border: "Width"
    }, function( prefix, suffix ) {
        jQuery.cssHooks[ prefix + suffix ] = {
            expand: function( value ) {
                var i = 0,
                    expanded = {},

                    // Assumes a single number if not a string
                    parts = typeof value === "string" ? value.split( " " ) : [ value ];

                for ( ; i < 4; i++ ) {
                    expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
                }

                return expanded;
            }
        };

        if ( prefix !== "margin" ) {
            jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
        }
    } );

    jQuery.fn.extend( {
        css: function( name, value ) {
            return access( this, function( elem, name, value ) {
                var styles, len,
                    map = {},
                    i = 0;

                if ( Array.isArray( name ) ) {
                    styles = getStyles( elem );
                    len = name.length;

                    for ( ; i < len; i++ ) {
                        map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
                    }

                    return map;
                }

                return value !== undefined ?
                    jQuery.style( elem, name, value ) :
                    jQuery.css( elem, name );
            }, name, value, arguments.length > 1 );
        }
    } );


    function Tween( elem, options, prop, end, easing ) {
        return new Tween.prototype.init( elem, options, prop, end, easing );
    }
    jQuery.Tween = Tween;

    Tween.prototype = {
        constructor: Tween,
        init: function( elem, options, prop, end, easing, unit ) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery.easing._default;
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
        },
        cur: function() {
            var hooks = Tween.propHooks[ this.prop ];

            return hooks && hooks.get ?
                hooks.get( this ) :
                Tween.propHooks._default.get( this );
        },
        run: function( percent ) {
            var eased,
                hooks = Tween.propHooks[ this.prop ];

            if ( this.options.duration ) {
                this.pos = eased = jQuery.easing[ this.easing ](
                    percent, this.options.duration * percent, 0, 1, this.options.duration
                );
            } else {
                this.pos = eased = percent;
            }
            this.now = ( this.end - this.start ) * eased + this.start;

            if ( this.options.step ) {
                this.options.step.call( this.elem, this.now, this );
            }

            if ( hooks && hooks.set ) {
                hooks.set( this );
            } else {
                Tween.propHooks._default.set( this );
            }
            return this;
        }
    };

    Tween.prototype.init.prototype = Tween.prototype;

    Tween.propHooks = {
        _default: {
            get: function( tween ) {
                var result;

                // Use a property on the element directly when it is not a DOM element,
                // or when there is no matching style property that exists.
                if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
                    return tween.elem[ tween.prop ];
                }

                // Passing an empty string as a 3rd parameter to .css will automatically
                // attempt a parseFloat and fallback to a string if the parse fails.
                // Simple values such as "10px" are parsed to Float;
                // complex values such as "rotate(1rad)" are returned as-is.
                result = jQuery.css( tween.elem, tween.prop, "" );

                // Empty strings, null, undefined and "auto" are converted to 0.
                return !result || result === "auto" ? 0 : result;
            },
            set: function( tween ) {

                // Use step hook for back compat.
                // Use cssHook if its there.
                // Use .style if available and use plain properties where available.
                if ( jQuery.fx.step[ tween.prop ] ) {
                    jQuery.fx.step[ tween.prop ]( tween );
                } else if ( tween.elem.nodeType === 1 && (
                    jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
                    jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
                } else {
                    tween.elem[ tween.prop ] = tween.now;
                }
            }
        }
    };

    // Support: IE <=9 only
    // Panic based approach to setting things on disconnected nodes
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function( tween ) {
            if ( tween.elem.nodeType && tween.elem.parentNode ) {
                tween.elem[ tween.prop ] = tween.now;
            }
        }
    };

    jQuery.easing = {
        linear: function( p ) {
            return p;
        },
        swing: function( p ) {
            return 0.5 - Math.cos( p * Math.PI ) / 2;
        },
        _default: "swing"
    };

    jQuery.fx = Tween.prototype.init;

    // Back compat <1.8 extension point
    jQuery.fx.step = {};




    var
        fxNow, inProgress,
        rfxtypes = /^(?:toggle|show|hide)$/,
        rrun = /queueHooks$/;

    function schedule() {
        if ( inProgress ) {
            if ( document.hidden === false && window.requestAnimationFrame ) {
                window.requestAnimationFrame( schedule );
            } else {
                window.setTimeout( schedule, jQuery.fx.interval );
            }

            jQuery.fx.tick();
        }
    }

    // Animations created synchronously will run synchronously
    function createFxNow() {
        window.setTimeout( function() {
            fxNow = undefined;
        } );
        return ( fxNow = Date.now() );
    }

    // Generate parameters to create a standard animation
    function genFx( type, includeWidth ) {
        var which,
            i = 0,
            attrs = { height: type };

        // If we include width, step value is 1 to do all cssExpand values,
        // otherwise step value is 2 to skip over Left and Right
        includeWidth = includeWidth ? 1 : 0;
        for ( ; i < 4; i += 2 - includeWidth ) {
            which = cssExpand[ i ];
            attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
        }

        if ( includeWidth ) {
            attrs.opacity = attrs.width = type;
        }

        return attrs;
    }

    function createTween( value, prop, animation ) {
        var tween,
            collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
            index = 0,
            length = collection.length;
        for ( ; index < length; index++ ) {
            if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

                // We're done with this property
                return tween;
            }
        }
    }

    function defaultPrefilter( elem, props, opts ) {
        var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
            isBox = "width" in props || "height" in props,
            anim = this,
            orig = {},
            style = elem.style,
            hidden = elem.nodeType && isHiddenWithinTree( elem ),
            dataShow = dataPriv.get( elem, "fxshow" );

        // Queue-skipping animations hijack the fx hooks
        if ( !opts.queue ) {
            hooks = jQuery._queueHooks( elem, "fx" );
            if ( hooks.unqueued == null ) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function() {
                    if ( !hooks.unqueued ) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;

            anim.always( function() {

                // Ensure the complete handler is called before this completes
                anim.always( function() {
                    hooks.unqueued--;
                    if ( !jQuery.queue( elem, "fx" ).length ) {
                        hooks.empty.fire();
                    }
                } );
            } );
        }

        // Detect show/hide animations
        for ( prop in props ) {
            value = props[ prop ];
            if ( rfxtypes.test( value ) ) {
                delete props[ prop ];
                toggle = toggle || value === "toggle";
                if ( value === ( hidden ? "hide" : "show" ) ) {

                    // Pretend to be hidden if this is a "show" and
                    // there is still data from a stopped show/hide
                    if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
                        hidden = true;

                        // Ignore all other no-op show/hide data
                    } else {
                        continue;
                    }
                }
                orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
            }
        }

        // Bail out if this is a no-op like .hide().hide()
        propTween = !jQuery.isEmptyObject( props );
        if ( !propTween && jQuery.isEmptyObject( orig ) ) {
            return;
        }

        // Restrict "overflow" and "display" styles during box animations
        if ( isBox && elem.nodeType === 1 ) {

            // Support: IE <=9 - 11, Edge 12 - 15
            // Record all 3 overflow attributes because IE does not infer the shorthand
            // from identically-valued overflowX and overflowY and Edge just mirrors
            // the overflowX value there.
            opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

            // Identify a display type, preferring old show/hide data over the CSS cascade
            restoreDisplay = dataShow && dataShow.display;
            if ( restoreDisplay == null ) {
                restoreDisplay = dataPriv.get( elem, "display" );
            }
            display = jQuery.css( elem, "display" );
            if ( display === "none" ) {
                if ( restoreDisplay ) {
                    display = restoreDisplay;
                } else {

                    // Get nonempty value(s) by temporarily forcing visibility
                    showHide( [ elem ], true );
                    restoreDisplay = elem.style.display || restoreDisplay;
                    display = jQuery.css( elem, "display" );
                    showHide( [ elem ] );
                }
            }

            // Animate inline elements as inline-block
            if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
                if ( jQuery.css( elem, "float" ) === "none" ) {

                    // Restore the original display value at the end of pure show/hide animations
                    if ( !propTween ) {
                        anim.done( function() {
                            style.display = restoreDisplay;
                        } );
                        if ( restoreDisplay == null ) {
                            display = style.display;
                            restoreDisplay = display === "none" ? "" : display;
                        }
                    }
                    style.display = "inline-block";
                }
            }
        }

        if ( opts.overflow ) {
            style.overflow = "hidden";
            anim.always( function() {
                style.overflow = opts.overflow[ 0 ];
                style.overflowX = opts.overflow[ 1 ];
                style.overflowY = opts.overflow[ 2 ];
            } );
        }

        // Implement show/hide animations
        propTween = false;
        for ( prop in orig ) {

            // General show/hide setup for this element animation
            if ( !propTween ) {
                if ( dataShow ) {
                    if ( "hidden" in dataShow ) {
                        hidden = dataShow.hidden;
                    }
                } else {
                    dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
                }

                // Store hidden/visible for toggle so `.stop().toggle()` "reverses"
                if ( toggle ) {
                    dataShow.hidden = !hidden;
                }

                // Show elements before animating them
                if ( hidden ) {
                    showHide( [ elem ], true );
                }

                /* eslint-disable no-loop-func */

                anim.done( function() {

                    /* eslint-enable no-loop-func */

                    // The final step of a "hide" animation is actually hiding the element
                    if ( !hidden ) {
                        showHide( [ elem ] );
                    }
                    dataPriv.remove( elem, "fxshow" );
                    for ( prop in orig ) {
                        jQuery.style( elem, prop, orig[ prop ] );
                    }
                } );
            }

            // Per-property setup
            propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
            if ( !( prop in dataShow ) ) {
                dataShow[ prop ] = propTween.start;
                if ( hidden ) {
                    propTween.end = propTween.start;
                    propTween.start = 0;
                }
            }
        }
    }

    function propFilter( props, specialEasing ) {
        var index, name, easing, value, hooks;

        // camelCase, specialEasing and expand cssHook pass
        for ( index in props ) {
            name = camelCase( index );
            easing = specialEasing[ name ];
            value = props[ index ];
            if ( Array.isArray( value ) ) {
                easing = value[ 1 ];
                value = props[ index ] = value[ 0 ];
            }

            if ( index !== name ) {
                props[ name ] = value;
                delete props[ index ];
            }

            hooks = jQuery.cssHooks[ name ];
            if ( hooks && "expand" in hooks ) {
                value = hooks.expand( value );
                delete props[ name ];

                // Not quite $.extend, this won't overwrite existing keys.
                // Reusing 'index' because we have the correct "name"
                for ( index in value ) {
                    if ( !( index in props ) ) {
                        props[ index ] = value[ index ];
                        specialEasing[ index ] = easing;
                    }
                }
            } else {
                specialEasing[ name ] = easing;
            }
        }
    }

    function Animation( elem, properties, options ) {
        var result,
            stopped,
            index = 0,
            length = Animation.prefilters.length,
            deferred = jQuery.Deferred().always( function() {

                // Don't match elem in the :animated selector
                delete tick.elem;
            } ),
            tick = function() {
                if ( stopped ) {
                    return false;
                }
                var currentTime = fxNow || createFxNow(),
                    remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

                    // Support: Android 2.3 only
                    // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
                    temp = remaining / animation.duration || 0,
                    percent = 1 - temp,
                    index = 0,
                    length = animation.tweens.length;

                for ( ; index < length; index++ ) {
                    animation.tweens[ index ].run( percent );
                }

                deferred.notifyWith( elem, [ animation, percent, remaining ] );

                // If there's more to do, yield
                if ( percent < 1 && length ) {
                    return remaining;
                }

                // If this was an empty animation, synthesize a final progress notification
                if ( !length ) {
                    deferred.notifyWith( elem, [ animation, 1, 0 ] );
                }

                // Resolve the animation and report its conclusion
                deferred.resolveWith( elem, [ animation ] );
                return false;
            },
            animation = deferred.promise( {
                elem: elem,
                props: jQuery.extend( {}, properties ),
                opts: jQuery.extend( true, {
                    specialEasing: {},
                    easing: jQuery.easing._default
                }, options ),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function( prop, end ) {
                    var tween = jQuery.Tween( elem, animation.opts, prop, end,
                        animation.opts.specialEasing[ prop ] || animation.opts.easing );
                    animation.tweens.push( tween );
                    return tween;
                },
                stop: function( gotoEnd ) {
                    var index = 0,

                        // If we are going to the end, we want to run all the tweens
                        // otherwise we skip this part
                        length = gotoEnd ? animation.tweens.length : 0;
                    if ( stopped ) {
                        return this;
                    }
                    stopped = true;
                    for ( ; index < length; index++ ) {
                        animation.tweens[ index ].run( 1 );
                    }

                    // Resolve when we played the last frame; otherwise, reject
                    if ( gotoEnd ) {
                        deferred.notifyWith( elem, [ animation, 1, 0 ] );
                        deferred.resolveWith( elem, [ animation, gotoEnd ] );
                    } else {
                        deferred.rejectWith( elem, [ animation, gotoEnd ] );
                    }
                    return this;
                }
            } ),
            props = animation.props;

        propFilter( props, animation.opts.specialEasing );

        for ( ; index < length; index++ ) {
            result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
            if ( result ) {
                if ( isFunction( result.stop ) ) {
                    jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
                }
                return result;
            }
        }

        jQuery.map( props, createTween, animation );

        if ( isFunction( animation.opts.start ) ) {
            animation.opts.start.call( elem, animation );
        }

        // Attach callbacks from options
        animation
            .progress( animation.opts.progress )
            .done( animation.opts.done, animation.opts.complete )
            .fail( animation.opts.fail )
            .always( animation.opts.always );

        jQuery.fx.timer(
            jQuery.extend( tick, {
                elem: elem,
                anim: animation,
                queue: animation.opts.queue
            } )
        );

        return animation;
    }

    jQuery.Animation = jQuery.extend( Animation, {

        tweeners: {
            "*": [ function( prop, value ) {
                var tween = this.createTween( prop, value );
                adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
                return tween;
            } ]
        },

        tweener: function( props, callback ) {
            if ( isFunction( props ) ) {
                callback = props;
                props = [ "*" ];
            } else {
                props = props.match( rnothtmlwhite );
            }

            var prop,
                index = 0,
                length = props.length;

            for ( ; index < length; index++ ) {
                prop = props[ index ];
                Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
                Animation.tweeners[ prop ].unshift( callback );
            }
        },

        prefilters: [ defaultPrefilter ],

        prefilter: function( callback, prepend ) {
            if ( prepend ) {
                Animation.prefilters.unshift( callback );
            } else {
                Animation.prefilters.push( callback );
            }
        }
    } );

    jQuery.speed = function( speed, easing, fn ) {
        var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
            complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
            duration: speed,
            easing: fn && easing || easing && !isFunction( easing ) && easing
        };

        // Go to the end state if fx are off
        if ( jQuery.fx.off ) {
            opt.duration = 0;

        } else {
            if ( typeof opt.duration !== "number" ) {
                if ( opt.duration in jQuery.fx.speeds ) {
                    opt.duration = jQuery.fx.speeds[ opt.duration ];

                } else {
                    opt.duration = jQuery.fx.speeds._default;
                }
            }
        }

        // Normalize opt.queue - true/undefined/null -> "fx"
        if ( opt.queue == null || opt.queue === true ) {
            opt.queue = "fx";
        }

        // Queueing
        opt.old = opt.complete;

        opt.complete = function() {
            if ( isFunction( opt.old ) ) {
                opt.old.call( this );
            }

            if ( opt.queue ) {
                jQuery.dequeue( this, opt.queue );
            }
        };

        return opt;
    };

    jQuery.fn.extend( {
        fadeTo: function( speed, to, easing, callback ) {

            // Show any hidden elements after setting opacity to 0
            return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

            // Animate to the value specified
                .end().animate( { opacity: to }, speed, easing, callback );
        },
        animate: function( prop, speed, easing, callback ) {
            var empty = jQuery.isEmptyObject( prop ),
                optall = jQuery.speed( speed, easing, callback ),
                doAnimation = function() {

                    // Operate on a copy of prop so per-property easing won't be lost
                    var anim = Animation( this, jQuery.extend( {}, prop ), optall );

                    // Empty animations, or finishing resolves immediately
                    if ( empty || dataPriv.get( this, "finish" ) ) {
                        anim.stop( true );
                    }
                };
            doAnimation.finish = doAnimation;

            return empty || optall.queue === false ?
                this.each( doAnimation ) :
                this.queue( optall.queue, doAnimation );
        },
        stop: function( type, clearQueue, gotoEnd ) {
            var stopQueue = function( hooks ) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop( gotoEnd );
            };

            if ( typeof type !== "string" ) {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if ( clearQueue ) {
                this.queue( type || "fx", [] );
            }

            return this.each( function() {
                var dequeue = true,
                    index = type != null && type + "queueHooks",
                    timers = jQuery.timers,
                    data = dataPriv.get( this );

                if ( index ) {
                    if ( data[ index ] && data[ index ].stop ) {
                        stopQueue( data[ index ] );
                    }
                } else {
                    for ( index in data ) {
                        if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
                            stopQueue( data[ index ] );
                        }
                    }
                }

                for ( index = timers.length; index--; ) {
                    if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

                        timers[ index ].anim.stop( gotoEnd );
                        dequeue = false;
                        timers.splice( index, 1 );
                    }
                }

                // Start the next in the queue if the last step wasn't forced.
                // Timers currently will call their complete callbacks, which
                // will dequeue but only if they were gotoEnd.
                if ( dequeue || !gotoEnd ) {
                    jQuery.dequeue( this, type );
                }
            } );
        },
        finish: function( type ) {
            if ( type !== false ) {
                type = type || "fx";
            }
            return this.each( function() {
                var index,
                    data = dataPriv.get( this ),
                    queue = data[ type + "queue" ],
                    hooks = data[ type + "queueHooks" ],
                    timers = jQuery.timers,
                    length = queue ? queue.length : 0;

                // Enable finishing flag on private data
                data.finish = true;

                // Empty the queue first
                jQuery.queue( this, type, [] );

                if ( hooks && hooks.stop ) {
                    hooks.stop.call( this, true );
                }

                // Look for any active animations, and finish them
                for ( index = timers.length; index--; ) {
                    if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
                        timers[ index ].anim.stop( true );
                        timers.splice( index, 1 );
                    }
                }

                // Look for any animations in the old queue and finish them
                for ( index = 0; index < length; index++ ) {
                    if ( queue[ index ] && queue[ index ].finish ) {
                        queue[ index ].finish.call( this );
                    }
                }

                // Turn off finishing flag
                delete data.finish;
            } );
        }
    } );

    jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
        var cssFn = jQuery.fn[ name ];
        jQuery.fn[ name ] = function( speed, easing, callback ) {
            return speed == null || typeof speed === "boolean" ?
                cssFn.apply( this, arguments ) :
                this.animate( genFx( name, true ), speed, easing, callback );
        };
    } );

    // Generate shortcuts for custom animations
    jQuery.each( {
        slideDown: genFx( "show" ),
        slideUp: genFx( "hide" ),
        slideToggle: genFx( "toggle" ),
        fadeIn: { opacity: "show" },
        fadeOut: { opacity: "hide" },
        fadeToggle: { opacity: "toggle" }
    }, function( name, props ) {
        jQuery.fn[ name ] = function( speed, easing, callback ) {
            return this.animate( props, speed, easing, callback );
        };
    } );

    jQuery.timers = [];
    jQuery.fx.tick = function() {
        var timer,
            i = 0,
            timers = jQuery.timers;

        fxNow = Date.now();

        for ( ; i < timers.length; i++ ) {
            timer = timers[ i ];

            // Run the timer and safely remove it when done (allowing for external removal)
            if ( !timer() && timers[ i ] === timer ) {
                timers.splice( i--, 1 );
            }
        }

        if ( !timers.length ) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };

    jQuery.fx.timer = function( timer ) {
        jQuery.timers.push( timer );
        jQuery.fx.start();
    };

    jQuery.fx.interval = 13;
    jQuery.fx.start = function() {
        if ( inProgress ) {
            return;
        }

        inProgress = true;
        schedule();
    };

    jQuery.fx.stop = function() {
        inProgress = null;
    };

    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,

        // Default speed
        _default: 400
    };


    // Based off of the plugin by Clint Helfers, with permission.
    // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
    jQuery.fn.delay = function( time, type ) {
        time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
        type = type || "fx";

        return this.queue( type, function( next, hooks ) {
            var timeout = window.setTimeout( next, time );
            hooks.stop = function() {
                window.clearTimeout( timeout );
            };
        } );
    };


    ( function() {
        var input = document.createElement( "input" ),
            select = document.createElement( "select" ),
            opt = select.appendChild( document.createElement( "option" ) );

        input.type = "checkbox";

        // Support: Android <=4.3 only
        // Default value for a checkbox should be "on"
        support.checkOn = input.value !== "";

        // Support: IE <=11 only
        // Must access selectedIndex to make default options select
        support.optSelected = opt.selected;

        // Support: IE <=11 only
        // An input loses its value after becoming a radio
        input = document.createElement( "input" );
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
    } )();


    var boolHook,
        attrHandle = jQuery.expr.attrHandle;

    jQuery.fn.extend( {
        attr: function( name, value ) {
            return access( this, jQuery.attr, name, value, arguments.length > 1 );
        },

        removeAttr: function( name ) {
            return this.each( function() {
                jQuery.removeAttr( this, name );
            } );
        }
    } );

    jQuery.extend( {
        attr: function( elem, name, value ) {
            var ret, hooks,
                nType = elem.nodeType;

            // Don't get/set attributes on text, comment and attribute nodes
            if ( nType === 3 || nType === 8 || nType === 2 ) {
                return;
            }

            // Fallback to prop when attributes are not supported
            if ( typeof elem.getAttribute === "undefined" ) {
                return jQuery.prop( elem, name, value );
            }

            // Attribute hooks are determined by the lowercase version
            // Grab necessary hook if one is defined
            if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
                hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
            }

            if ( value !== undefined ) {
                if ( value === null ) {
                    jQuery.removeAttr( elem, name );
                    return;
                }

                if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
                    return ret;
                }

                elem.setAttribute( name, value + "" );
                return value;
            }

            if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
                return ret;
            }

            ret = jQuery.find.attr( elem, name );

            // Non-existent attributes return null, we normalize to undefined
            return ret == null ? undefined : ret;
        },

        attrHooks: {
            type: {
                set: function( elem, value ) {
                    if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
                        var val = elem.value;
                        elem.setAttribute( "type", value );
                        if ( val ) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        },

        removeAttr: function( elem, value ) {
            var name,
                i = 0,

                // Attribute names can contain non-HTML whitespace characters
                // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
                attrNames = value && value.match( rnothtmlwhite );

            if ( attrNames && elem.nodeType === 1 ) {
                while ( ( name = attrNames[ i++ ] ) ) {
                    elem.removeAttribute( name );
                }
            }
        }
    } );

    // Hooks for boolean attributes
    boolHook = {
        set: function( elem, value, name ) {
            if ( value === false ) {

                // Remove boolean attributes when set to false
                jQuery.removeAttr( elem, name );
            } else {
                elem.setAttribute( name, name );
            }
            return name;
        }
    };

    jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
        var getter = attrHandle[ name ] || jQuery.find.attr;

        attrHandle[ name ] = function( elem, name, isXML ) {
            var ret, handle,
                lowercaseName = name.toLowerCase();

            if ( !isXML ) {

                // Avoid an infinite loop by temporarily removing this function from the getter
                handle = attrHandle[ lowercaseName ];
                attrHandle[ lowercaseName ] = ret;
                ret = getter( elem, name, isXML ) != null ?
                    lowercaseName :
                    null;
                attrHandle[ lowercaseName ] = handle;
            }
            return ret;
        };
    } );




    var rfocusable = /^(?:input|select|textarea|button)$/i,
        rclickable = /^(?:a|area)$/i;

    jQuery.fn.extend( {
        prop: function( name, value ) {
            return access( this, jQuery.prop, name, value, arguments.length > 1 );
        },

        removeProp: function( name ) {
            return this.each( function() {
                delete this[ jQuery.propFix[ name ] || name ];
            } );
        }
    } );

    jQuery.extend( {
        prop: function( elem, name, value ) {
            var ret, hooks,
                nType = elem.nodeType;

            // Don't get/set properties on text, comment and attribute nodes
            if ( nType === 3 || nType === 8 || nType === 2 ) {
                return;
            }

            if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

                // Fix name and attach hooks
                name = jQuery.propFix[ name ] || name;
                hooks = jQuery.propHooks[ name ];
            }

            if ( value !== undefined ) {
                if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
                    return ret;
                }

                return ( elem[ name ] = value );
            }

            if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
                return ret;
            }

            return elem[ name ];
        },

        propHooks: {
            tabIndex: {
                get: function( elem ) {

                    // Support: IE <=9 - 11 only
                    // elem.tabIndex doesn't always return the
                    // correct value when it hasn't been explicitly set
                    // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                    // Use proper attribute retrieval(#12072)
                    var tabindex = jQuery.find.attr( elem, "tabindex" );

                    if ( tabindex ) {
                        return parseInt( tabindex, 10 );
                    }

                    if (
                        rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
                    ) {
                        return 0;
                    }

                    return -1;
                }
            }
        },

        propFix: {
            "for": "htmlFor",
            "class": "className"
        }
    } );

    // Support: IE <=11 only
    // Accessing the selectedIndex property
    // forces the browser to respect setting selected
    // on the option
    // The getter ensures a default option is selected
    // when in an optgroup
    // eslint rule "no-unused-expressions" is disabled for this code
    // since it considers such accessions noop
    if ( !support.optSelected ) {
        jQuery.propHooks.selected = {
            get: function( elem ) {

                /* eslint no-unused-expressions: "off" */

                var parent = elem.parentNode;
                if ( parent && parent.parentNode ) {
                    parent.parentNode.selectedIndex;
                }
                return null;
            },
            set: function( elem ) {

                /* eslint no-unused-expressions: "off" */

                var parent = elem.parentNode;
                if ( parent ) {
                    parent.selectedIndex;

                    if ( parent.parentNode ) {
                        parent.parentNode.selectedIndex;
                    }
                }
            }
        };
    }

    jQuery.each( [
        "tabIndex",
        "readOnly",
        "maxLength",
        "cellSpacing",
        "cellPadding",
        "rowSpan",
        "colSpan",
        "useMap",
        "frameBorder",
        "contentEditable"
    ], function() {
        jQuery.propFix[ this.toLowerCase() ] = this;
    } );




    // Strip and collapse whitespace according to HTML spec
    // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
    function stripAndCollapse( value ) {
        var tokens = value.match( rnothtmlwhite ) || [];
        return tokens.join( " " );
    }


    function getClass( elem ) {
        return elem.getAttribute && elem.getAttribute( "class" ) || "";
    }

    function classesToArray( value ) {
        if ( Array.isArray( value ) ) {
            return value;
        }
        if ( typeof value === "string" ) {
            return value.match( rnothtmlwhite ) || [];
        }
        return [];
    }

    jQuery.fn.extend( {
        addClass: function( value ) {
            var classes, elem, cur, curValue, clazz, j, finalValue,
                i = 0;

            if ( isFunction( value ) ) {
                return this.each( function( j ) {
                    jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
                } );
            }

            classes = classesToArray( value );

            if ( classes.length ) {
                while ( ( elem = this[ i++ ] ) ) {
                    curValue = getClass( elem );
                    cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

                    if ( cur ) {
                        j = 0;
                        while ( ( clazz = classes[ j++ ] ) ) {
                            if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
                                cur += clazz + " ";
                            }
                        }

                        // Only assign if different to avoid unneeded rendering.
                        finalValue = stripAndCollapse( cur );
                        if ( curValue !== finalValue ) {
                            elem.setAttribute( "class", finalValue );
                        }
                    }
                }
            }

            return this;
        },

        removeClass: function( value ) {
            var classes, elem, cur, curValue, clazz, j, finalValue,
                i = 0;

            if ( isFunction( value ) ) {
                return this.each( function( j ) {
                    jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
                } );
            }

            if ( !arguments.length ) {
                return this.attr( "class", "" );
            }

            classes = classesToArray( value );

            if ( classes.length ) {
                while ( ( elem = this[ i++ ] ) ) {
                    curValue = getClass( elem );

                    // This expression is here for better compressibility (see addClass)
                    cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

                    if ( cur ) {
                        j = 0;
                        while ( ( clazz = classes[ j++ ] ) ) {

                            // Remove *all* instances
                            while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
                                cur = cur.replace( " " + clazz + " ", " " );
                            }
                        }

                        // Only assign if different to avoid unneeded rendering.
                        finalValue = stripAndCollapse( cur );
                        if ( curValue !== finalValue ) {
                            elem.setAttribute( "class", finalValue );
                        }
                    }
                }
            }

            return this;
        },

        toggleClass: function( value, stateVal ) {
            var type = typeof value,
                isValidValue = type === "string" || Array.isArray( value );

            if ( typeof stateVal === "boolean" && isValidValue ) {
                return stateVal ? this.addClass( value ) : this.removeClass( value );
            }

            if ( isFunction( value ) ) {
                return this.each( function( i ) {
                    jQuery( this ).toggleClass(
                        value.call( this, i, getClass( this ), stateVal ),
                        stateVal
                    );
                } );
            }

            return this.each( function() {
                var className, i, self, classNames;

                if ( isValidValue ) {

                    // Toggle individual class names
                    i = 0;
                    self = jQuery( this );
                    classNames = classesToArray( value );

                    while ( ( className = classNames[ i++ ] ) ) {

                        // Check each className given, space separated list
                        if ( self.hasClass( className ) ) {
                            self.removeClass( className );
                        } else {
                            self.addClass( className );
                        }
                    }

                    // Toggle whole class name
                } else if ( value === undefined || type === "boolean" ) {
                    className = getClass( this );
                    if ( className ) {

                        // Store className if set
                        dataPriv.set( this, "__className__", className );
                    }

                    // If the element has a class name or if we're passed `false`,
                    // then remove the whole classname (if there was one, the above saved it).
                    // Otherwise bring back whatever was previously saved (if anything),
                    // falling back to the empty string if nothing was stored.
                    if ( this.setAttribute ) {
                        this.setAttribute( "class",
                            className || value === false ?
                                "" :
                                dataPriv.get( this, "__className__" ) || ""
                        );
                    }
                }
            } );
        },

        hasClass: function( selector ) {
            var className, elem,
                i = 0;

            className = " " + selector + " ";
            while ( ( elem = this[ i++ ] ) ) {
                if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
                    return true;
                }
            }

            return false;
        }
    } );




    var rreturn = /\r/g;

    jQuery.fn.extend( {
        val: function( value ) {
            var hooks, ret, valueIsFunction,
                elem = this[ 0 ];

            if ( !arguments.length ) {
                if ( elem ) {
                    hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

                    if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
                    ) {
                        return ret;
                    }

                    ret = elem.value;

                    // Handle most common string cases
                    if ( typeof ret === "string" ) {
                        return ret.replace( rreturn, "" );
                    }

                    // Handle cases where value is null/undef or number
                    return ret == null ? "" : ret;
                }

                return;
            }

            valueIsFunction = isFunction( value );

            return this.each( function( i ) {
                var val;

                if ( this.nodeType !== 1 ) {
                    return;
                }

                if ( valueIsFunction ) {
                    val = value.call( this, i, jQuery( this ).val() );
                } else {
                    val = value;
                }

                // Treat null/undefined as ""; convert numbers to string
                if ( val == null ) {
                    val = "";

                } else if ( typeof val === "number" ) {
                    val += "";

                } else if ( Array.isArray( val ) ) {
                    val = jQuery.map( val, function( value ) {
                        return value == null ? "" : value + "";
                    } );
                }

                hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

                // If set returns undefined, fall back to normal setting
                if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
                    this.value = val;
                }
            } );
        }
    } );

    jQuery.extend( {
        valHooks: {
            option: {
                get: function( elem ) {

                    var val = jQuery.find.attr( elem, "value" );
                    return val != null ?
                        val :

                    // Support: IE <=10 - 11 only
                    // option.text throws exceptions (#14686, #14858)
                    // Strip and collapse whitespace
                    // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                        stripAndCollapse( jQuery.text( elem ) );
                }
            },
            select: {
                get: function( elem ) {
                    var value, option, i,
                        options = elem.options,
                        index = elem.selectedIndex,
                        one = elem.type === "select-one",
                        values = one ? null : [],
                        max = one ? index + 1 : options.length;

                    if ( index < 0 ) {
                        i = max;

                    } else {
                        i = one ? index : 0;
                    }

                    // Loop through all the selected options
                    for ( ; i < max; i++ ) {
                        option = options[ i ];

                        // Support: IE <=9 only
                        // IE8-9 doesn't update selected after form reset (#2551)
                        if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

                            // Get the specific value for the option
                            value = jQuery( option ).val();

                            // We don't need an array for one selects
                            if ( one ) {
                                return value;
                            }

                            // Multi-Selects return an array
                            values.push( value );
                        }
                    }

                    return values;
                },

                set: function( elem, value ) {
                    var optionSet, option,
                        options = elem.options,
                        values = jQuery.makeArray( value ),
                        i = options.length;

                    while ( i-- ) {
                        option = options[ i ];

                        /* eslint-disable no-cond-assign */

                        if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
                        ) {
                            optionSet = true;
                        }

                        /* eslint-enable no-cond-assign */
                    }

                    // Force browsers to behave consistently when non-matching value is set
                    if ( !optionSet ) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        }
    } );

    // Radios and checkboxes getter/setter
    jQuery.each( [ "radio", "checkbox" ], function() {
        jQuery.valHooks[ this ] = {
            set: function( elem, value ) {
                if ( Array.isArray( value ) ) {
                    return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
                }
            }
        };
        if ( !support.checkOn ) {
            jQuery.valHooks[ this ].get = function( elem ) {
                return elem.getAttribute( "value" ) === null ? "on" : elem.value;
            };
        }
    } );




    // Return jQuery for attributes-only inclusion


    support.focusin = "onfocusin" in window;


    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
        stopPropagationCallback = function( e ) {
            e.stopPropagation();
        };

    jQuery.extend( jQuery.event, {

        trigger: function( event, data, elem, onlyHandlers ) {

            var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
                eventPath = [ elem || document ],
                type = hasOwn.call( event, "type" ) ? event.type : event,
                namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

            cur = lastElement = tmp = elem = elem || document;

            // Don't do events on text and comment nodes
            if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
                return;
            }

            // focus/blur morphs to focusin/out; ensure we're not firing them right now
            if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
                return;
            }

            if ( type.indexOf( "." ) > -1 ) {

                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split( "." );
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf( ":" ) < 0 && "on" + type;

            // Caller can pass in a jQuery.Event object, Object, or just an event type string
            event = event[ jQuery.expando ] ?
                event :
                new jQuery.Event( type, typeof event === "object" && event );

            // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join( "." );
            event.rnamespace = event.namespace ?
                new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
                null;

            // Clean up the event in case it is being reused
            event.result = undefined;
            if ( !event.target ) {
                event.target = elem;
            }

            // Clone any incoming data and prepend the event, creating the handler arg list
            data = data == null ?
                [ event ] :
                jQuery.makeArray( data, [ event ] );

            // Allow special events to draw outside the lines
            special = jQuery.event.special[ type ] || {};
            if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
                return;
            }

            // Determine event propagation path in advance, per W3C events spec (#9951)
            // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
            if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

                bubbleType = special.delegateType || type;
                if ( !rfocusMorph.test( bubbleType + type ) ) {
                    cur = cur.parentNode;
                }
                for ( ; cur; cur = cur.parentNode ) {
                    eventPath.push( cur );
                    tmp = cur;
                }

                // Only add window if we got to document (e.g., not plain obj or detached DOM)
                if ( tmp === ( elem.ownerDocument || document ) ) {
                    eventPath.push( tmp.defaultView || tmp.parentWindow || window );
                }
            }

            // Fire handlers on the event path
            i = 0;
            while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
                lastElement = cur;
                event.type = i > 1 ?
                    bubbleType :
                    special.bindType || type;

                // jQuery handler
                handle = (
                    dataPriv.get( cur, "events" ) || Object.create( null )
                )[ event.type ] &&
				dataPriv.get( cur, "handle" );
                if ( handle ) {
                    handle.apply( cur, data );
                }

                // Native handler
                handle = ontype && cur[ ontype ];
                if ( handle && handle.apply && acceptData( cur ) ) {
                    event.result = handle.apply( cur, data );
                    if ( event.result === false ) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;

            // If nobody prevented the default action, do it now
            if ( !onlyHandlers && !event.isDefaultPrevented() ) {

                if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

                    // Call a native DOM method on the target with the same name as the event.
                    // Don't do default actions on window, that's where global variables be (#6170)
                    if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

                        // Don't re-trigger an onFOO event when we call its FOO() method
                        tmp = elem[ ontype ];

                        if ( tmp ) {
                            elem[ ontype ] = null;
                        }

                        // Prevent re-triggering of the same event, since we already bubbled it above
                        jQuery.event.triggered = type;

                        if ( event.isPropagationStopped() ) {
                            lastElement.addEventListener( type, stopPropagationCallback );
                        }

                        elem[ type ]();

                        if ( event.isPropagationStopped() ) {
                            lastElement.removeEventListener( type, stopPropagationCallback );
                        }

                        jQuery.event.triggered = undefined;

                        if ( tmp ) {
                            elem[ ontype ] = tmp;
                        }
                    }
                }
            }

            return event.result;
        },

        // Piggyback on a donor event to simulate a different one
        // Used only for `focus(in | out)` events
        simulate: function( type, elem, event ) {
            var e = jQuery.extend(
                new jQuery.Event(),
                event,
                {
                    type: type,
                    isSimulated: true
                }
            );

            jQuery.event.trigger( e, null, elem );
        }

    } );

    jQuery.fn.extend( {

        trigger: function( type, data ) {
            return this.each( function() {
                jQuery.event.trigger( type, data, this );
            } );
        },
        triggerHandler: function( type, data ) {
            var elem = this[ 0 ];
            if ( elem ) {
                return jQuery.event.trigger( type, data, elem, true );
            }
        }
    } );


    // Support: Firefox <=44
    // Firefox doesn't have focus(in | out) events
    // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
    //
    // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
    // focus(in | out) events fire after focus & blur events,
    // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
    // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
    if ( !support.focusin ) {
        jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

            // Attach a single capturing handler on the document while someone wants focusin/focusout
            var handler = function( event ) {
                jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
            };

            jQuery.event.special[ fix ] = {
                setup: function() {

                    // Handle: regular nodes (via `this.ownerDocument`), window
                    // (via `this.document`) & document (via `this`).
                    var doc = this.ownerDocument || this.document || this,
                        attaches = dataPriv.access( doc, fix );

                    if ( !attaches ) {
                        doc.addEventListener( orig, handler, true );
                    }
                    dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
                },
                teardown: function() {
                    var doc = this.ownerDocument || this.document || this,
                        attaches = dataPriv.access( doc, fix ) - 1;

                    if ( !attaches ) {
                        doc.removeEventListener( orig, handler, true );
                        dataPriv.remove( doc, fix );

                    } else {
                        dataPriv.access( doc, fix, attaches );
                    }
                }
            };
        } );
    }
    var location = window.location;

    var nonce = { guid: Date.now() };

    var rquery = ( /\?/ );



    // Cross-browser xml parsing
    jQuery.parseXML = function( data ) {
        var xml;
        if ( !data || typeof data !== "string" ) {
            return null;
        }

        // Support: IE 9 - 11 only
        // IE throws on parseFromString with invalid input.
        try {
            xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
        } catch ( e ) {
            xml = undefined;
        }

        if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
            jQuery.error( "Invalid XML: " + data );
        }
        return xml;
    };


    var
        rbracket = /\[\]$/,
        rCRLF = /\r?\n/g,
        rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
        rsubmittable = /^(?:input|select|textarea|keygen)/i;

    function buildParams( prefix, obj, traditional, add ) {
        var name;

        if ( Array.isArray( obj ) ) {

            // Serialize array item.
            jQuery.each( obj, function( i, v ) {
                if ( traditional || rbracket.test( prefix ) ) {

                    // Treat each array item as a scalar.
                    add( prefix, v );

                } else {

                    // Item is non-scalar (array or object), encode its numeric index.
                    buildParams(
                        prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
                        v,
                        traditional,
                        add
                    );
                }
            } );

        } else if ( !traditional && toType( obj ) === "object" ) {

            // Serialize object item.
            for ( name in obj ) {
                buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
            }

        } else {

            // Serialize scalar item.
            add( prefix, obj );
        }
    }

    // Serialize an array of form elements or a set of
    // key/values into a query string
    jQuery.param = function( a, traditional ) {
        var prefix,
            s = [],
            add = function( key, valueOrFunction ) {

                // If value is a function, invoke it and use its return value
                var value = isFunction( valueOrFunction ) ?
                    valueOrFunction() :
                    valueOrFunction;

                s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
            };

        if ( a == null ) {
            return "";
        }

        // If an array was passed in, assume that it is an array of form elements.
        if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

            // Serialize the form elements
            jQuery.each( a, function() {
                add( this.name, this.value );
            } );

        } else {

            // If traditional, encode the "old" way (the way 1.3.2 or older
            // did it), otherwise encode params recursively.
            for ( prefix in a ) {
                buildParams( prefix, a[ prefix ], traditional, add );
            }
        }

        // Return the resulting serialization
        return s.join( "&" );
    };

    jQuery.fn.extend( {
        serialize: function() {
            return jQuery.param( this.serializeArray() );
        },
        serializeArray: function() {
            return this.map( function() {

                // Can add propHook for "elements" to filter or add form elements
                var elements = jQuery.prop( this, "elements" );
                return elements ? jQuery.makeArray( elements ) : this;
            } )
                .filter( function() {
                    var type = this.type;

                    // Use .is( ":disabled" ) so that fieldset[disabled] works
                    return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
                } )
                .map( function( _i, elem ) {
                    var val = jQuery( this ).val();

                    if ( val == null ) {
                        return null;
                    }

                    if ( Array.isArray( val ) ) {
                        return jQuery.map( val, function( val ) {
                            return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                        } );
                    }

                    return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                } ).get();
        }
    } );


    var
        r20 = /%20/g,
        rhash = /#.*$/,
        rantiCache = /([?&])_=[^&]*/,
        rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

        // #7653, #8125, #8152: local protocol detection
        rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
        rnoContent = /^(?:GET|HEAD)$/,
        rprotocol = /^\/\//,

        /* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
        prefilters = {},

        /* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
        transports = {},

        // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
        allTypes = "*/".concat( "*" ),

        // Anchor tag for parsing the document origin
        originAnchor = document.createElement( "a" );
    originAnchor.href = location.href;

    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports( structure ) {

        // dataTypeExpression is optional and defaults to "*"
        return function( dataTypeExpression, func ) {

            if ( typeof dataTypeExpression !== "string" ) {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }

            var dataType,
                i = 0,
                dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

            if ( isFunction( func ) ) {

                // For each dataType in the dataTypeExpression
                while ( ( dataType = dataTypes[ i++ ] ) ) {

                    // Prepend if requested
                    if ( dataType[ 0 ] === "+" ) {
                        dataType = dataType.slice( 1 ) || "*";
                        ( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

                        // Otherwise append
                    } else {
                        ( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
                    }
                }
            }
        };
    }

    // Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

        var inspected = {},
            seekingTransport = ( structure === transports );

        function inspect( dataType ) {
            var selected;
            inspected[ dataType ] = true;
            jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
                var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
                if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

                    options.dataTypes.unshift( dataTypeOrTransport );
                    inspect( dataTypeOrTransport );
                    return false;
                } else if ( seekingTransport ) {
                    return !( selected = dataTypeOrTransport );
                }
            } );
            return selected;
        }

        return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
    }

    // A special extend for ajax options
    // that takes "flat" options (not to be deep extended)
    // Fixes #9887
    function ajaxExtend( target, src ) {
        var key, deep,
            flatOptions = jQuery.ajaxSettings.flatOptions || {};

        for ( key in src ) {
            if ( src[ key ] !== undefined ) {
                ( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
            }
        }
        if ( deep ) {
            jQuery.extend( true, target, deep );
        }

        return target;
    }

    /* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
    function ajaxHandleResponses( s, jqXHR, responses ) {

        var ct, type, finalDataType, firstDataType,
            contents = s.contents,
            dataTypes = s.dataTypes;

        // Remove auto dataType and get content-type in the process
        while ( dataTypes[ 0 ] === "*" ) {
            dataTypes.shift();
            if ( ct === undefined ) {
                ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
            }
        }

        // Check if we're dealing with a known content-type
        if ( ct ) {
            for ( type in contents ) {
                if ( contents[ type ] && contents[ type ].test( ct ) ) {
                    dataTypes.unshift( type );
                    break;
                }
            }
        }

        // Check to see if we have a response for the expected dataType
        if ( dataTypes[ 0 ] in responses ) {
            finalDataType = dataTypes[ 0 ];
        } else {

            // Try convertible dataTypes
            for ( type in responses ) {
                if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
                    finalDataType = type;
                    break;
                }
                if ( !firstDataType ) {
                    firstDataType = type;
                }
            }

            // Or just use first one
            finalDataType = finalDataType || firstDataType;
        }

        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        if ( finalDataType ) {
            if ( finalDataType !== dataTypes[ 0 ] ) {
                dataTypes.unshift( finalDataType );
            }
            return responses[ finalDataType ];
        }
    }

    /* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
    function ajaxConvert( s, response, jqXHR, isSuccess ) {
        var conv2, current, conv, tmp, prev,
            converters = {},

            // Work with a copy of dataTypes in case we need to modify it for conversion
            dataTypes = s.dataTypes.slice();

        // Create converters map with lowercased keys
        if ( dataTypes[ 1 ] ) {
            for ( conv in s.converters ) {
                converters[ conv.toLowerCase() ] = s.converters[ conv ];
            }
        }

        current = dataTypes.shift();

        // Convert to each sequential dataType
        while ( current ) {

            if ( s.responseFields[ current ] ) {
                jqXHR[ s.responseFields[ current ] ] = response;
            }

            // Apply the dataFilter if provided
            if ( !prev && isSuccess && s.dataFilter ) {
                response = s.dataFilter( response, s.dataType );
            }

            prev = current;
            current = dataTypes.shift();

            if ( current ) {

                // There's only work to do if current dataType is non-auto
                if ( current === "*" ) {

                    current = prev;

                    // Convert response if prev dataType is non-auto and differs from current
                } else if ( prev !== "*" && prev !== current ) {

                    // Seek a direct converter
                    conv = converters[ prev + " " + current ] || converters[ "* " + current ];

                    // If none found, seek a pair
                    if ( !conv ) {
                        for ( conv2 in converters ) {

                            // If conv2 outputs current
                            tmp = conv2.split( " " );
                            if ( tmp[ 1 ] === current ) {

                                // If prev can be converted to accepted input
                                conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
                                if ( conv ) {

                                    // Condense equivalence converters
                                    if ( conv === true ) {
                                        conv = converters[ conv2 ];

                                        // Otherwise, insert the intermediate dataType
                                    } else if ( converters[ conv2 ] !== true ) {
                                        current = tmp[ 0 ];
                                        dataTypes.unshift( tmp[ 1 ] );
                                    }
                                    break;
                                }
                            }
                        }
                    }

                    // Apply converter (if not an equivalence)
                    if ( conv !== true ) {

                        // Unless errors are allowed to bubble, catch and return them
                        if ( conv && s.throws ) {
                            response = conv( response );
                        } else {
                            try {
                                response = conv( response );
                            } catch ( e ) {
                                return {
                                    state: "parsererror",
                                    error: conv ? e : "No conversion from " + prev + " to " + current
                                };
                            }
                        }
                    }
                }
            }
        }

        return { state: "success", data: response };
    }

    jQuery.extend( {

        // Counter for holding the number of active queries
        active: 0,

        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},

        ajaxSettings: {
            url: location.href,
            type: "GET",
            isLocal: rlocalProtocol.test( location.protocol ),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",

            /*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

            accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },

            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },

            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },

            // Data converters
            // Keys separate source (or catchall "*") and destination types with a single space
            converters: {

                // Convert anything to text
                "* text": String,

                // Text to html (true = no transformation)
                "text html": true,

                // Evaluate text as a json expression
                "text json": JSON.parse,

                // Parse text as xml
                "text xml": jQuery.parseXML
            },

            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
                url: true,
                context: true
            }
        },

        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function( target, settings ) {
            return settings ?

            // Building a settings object
                ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

            // Extending ajaxSettings
                ajaxExtend( jQuery.ajaxSettings, target );
        },

        ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
        ajaxTransport: addToPrefiltersOrTransports( transports ),

        // Main method
        ajax: function( url, options ) {

            // If url is an object, simulate pre-1.5 signature
            if ( typeof url === "object" ) {
                options = url;
                url = undefined;
            }

            // Force options to be an object
            options = options || {};

            var transport,

                // URL without anti-cache param
                cacheURL,

                // Response headers
                responseHeadersString,
                responseHeaders,

                // timeout handle
                timeoutTimer,

                // Url cleanup var
                urlAnchor,

                // Request state (becomes false upon send and true upon completion)
                completed,

                // To know if global events are to be dispatched
                fireGlobals,

                // Loop variable
                i,

                // uncached part of the url
                uncached,

                // Create the final options object
                s = jQuery.ajaxSetup( {}, options ),

                // Callbacks context
                callbackContext = s.context || s,

                // Context for global events is callbackContext if it is a DOM node or jQuery collection
                globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
                    jQuery( callbackContext ) :
                    jQuery.event,

                // Deferreds
                deferred = jQuery.Deferred(),
                completeDeferred = jQuery.Callbacks( "once memory" ),

                // Status-dependent callbacks
                statusCode = s.statusCode || {},

                // Headers (they are sent all at once)
                requestHeaders = {},
                requestHeadersNames = {},

                // Default abort message
                strAbort = "canceled",

                // Fake xhr
                jqXHR = {
                    readyState: 0,

                    // Builds headers hashtable if needed
                    getResponseHeader: function( key ) {
                        var match;
                        if ( completed ) {
                            if ( !responseHeaders ) {
                                responseHeaders = {};
                                while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
                                    responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
									    .concat( match[ 2 ] );
                                }
                            }
                            match = responseHeaders[ key.toLowerCase() + " " ];
                        }
                        return match == null ? null : match.join( ", " );
                    },

                    // Raw string
                    getAllResponseHeaders: function() {
                        return completed ? responseHeadersString : null;
                    },

                    // Caches the header
                    setRequestHeader: function( name, value ) {
                        if ( completed == null ) {
                            name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
                            requestHeaders[ name ] = value;
                        }
                        return this;
                    },

                    // Overrides response content-type header
                    overrideMimeType: function( type ) {
                        if ( completed == null ) {
                            s.mimeType = type;
                        }
                        return this;
                    },

                    // Status-dependent callbacks
                    statusCode: function( map ) {
                        var code;
                        if ( map ) {
                            if ( completed ) {

                                // Execute the appropriate callbacks
                                jqXHR.always( map[ jqXHR.status ] );
                            } else {

                                // Lazy-add the new callbacks in a way that preserves old ones
                                for ( code in map ) {
                                    statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
                                }
                            }
                        }
                        return this;
                    },

                    // Cancel the request
                    abort: function( statusText ) {
                        var finalText = statusText || strAbort;
                        if ( transport ) {
                            transport.abort( finalText );
                        }
                        done( 0, finalText );
                        return this;
                    }
                };

            // Attach deferreds
            deferred.promise( jqXHR );

            // Add protocol if not provided (prefilters might expect it)
            // Handle falsy url in the settings object (#10093: consistency with old signature)
            // We also use the url parameter if available
            s.url = ( ( url || s.url || location.href ) + "" )
                .replace( rprotocol, location.protocol + "//" );

            // Alias method option to type as per ticket #12004
            s.type = options.method || options.type || s.method || s.type;

            // Extract dataTypes list
            s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

            // A cross-domain request is in order when the origin doesn't match the current origin.
            if ( s.crossDomain == null ) {
                urlAnchor = document.createElement( "a" );

                // Support: IE <=8 - 11, Edge 12 - 15
                // IE throws exception on accessing the href property if url is malformed,
                // e.g. http://example.com:80x/
                try {
                    urlAnchor.href = s.url;

                    // Support: IE <=8 - 11 only
                    // Anchor's host property isn't correctly set when s.url is relative
                    urlAnchor.href = urlAnchor.href;
                    s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
                } catch ( e ) {

                    // If there is an error parsing the URL, assume it is crossDomain,
                    // it can be rejected by the transport if it is invalid
                    s.crossDomain = true;
                }
            }

            // Convert data if not already a string
            if ( s.data && s.processData && typeof s.data !== "string" ) {
                s.data = jQuery.param( s.data, s.traditional );
            }

            // Apply prefilters
            inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

            // If request was aborted inside a prefilter, stop there
            if ( completed ) {
                return jqXHR;
            }

            // We can fire global events as of now if asked to
            // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
            fireGlobals = jQuery.event && s.global;

            // Watch for a new set of requests
            if ( fireGlobals && jQuery.active++ === 0 ) {
                jQuery.event.trigger( "ajaxStart" );
            }

            // Uppercase the type
            s.type = s.type.toUpperCase();

            // Determine if request has content
            s.hasContent = !rnoContent.test( s.type );

            // Save the URL in case we're toying with the If-Modified-Since
            // and/or If-None-Match header later on
            // Remove hash to simplify url manipulation
            cacheURL = s.url.replace( rhash, "" );

            // More options handling for requests with no content
            if ( !s.hasContent ) {

                // Remember the hash so we can put it back
                uncached = s.url.slice( cacheURL.length );

                // If data is available and should be processed, append data to url
                if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
                    cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

                    // #9682: remove data so that it's not used in an eventual retry
                    delete s.data;
                }

                // Add or update anti-cache param if needed
                if ( s.cache === false ) {
                    cacheURL = cacheURL.replace( rantiCache, "$1" );
                    uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
                }

                // Put hash and anti-cache on the URL that will be requested (gh-1732)
                s.url = cacheURL + uncached;

                // Change '%20' to '+' if this is encoded form body content (gh-2658)
            } else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
                s.data = s.data.replace( r20, "+" );
            }

            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if ( s.ifModified ) {
                if ( jQuery.lastModified[ cacheURL ] ) {
                    jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
                }
                if ( jQuery.etag[ cacheURL ] ) {
                    jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
                }
            }

            // Set the correct header, if data is being sent
            if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
                jqXHR.setRequestHeader( "Content-Type", s.contentType );
            }

            // Set the Accepts header for the server, depending on the dataType
            jqXHR.setRequestHeader(
                "Accept",
                s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
                    s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
                    s.accepts[ "*" ]
            );

            // Check for headers option
            for ( i in s.headers ) {
                jqXHR.setRequestHeader( i, s.headers[ i ] );
            }

            // Allow custom headers/mimetypes and early abort
            if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

                // Abort if not done already and return
                return jqXHR.abort();
            }

            // Aborting is no longer a cancellation
            strAbort = "abort";

            // Install callbacks on deferreds
            completeDeferred.add( s.complete );
            jqXHR.done( s.success );
            jqXHR.fail( s.error );

            // Get transport
            transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

            // If no transport, we auto-abort
            if ( !transport ) {
                done( -1, "No Transport" );
            } else {
                jqXHR.readyState = 1;

                // Send global event
                if ( fireGlobals ) {
                    globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
                }

                // If request was aborted inside ajaxSend, stop there
                if ( completed ) {
                    return jqXHR;
                }

                // Timeout
                if ( s.async && s.timeout > 0 ) {
                    timeoutTimer = window.setTimeout( function() {
                        jqXHR.abort( "timeout" );
                    }, s.timeout );
                }

                try {
                    completed = false;
                    transport.send( requestHeaders, done );
                } catch ( e ) {

                    // Rethrow post-completion exceptions
                    if ( completed ) {
                        throw e;
                    }

                    // Propagate others as results
                    done( -1, e );
                }
            }

            // Callback for when everything is done
            function done( status, nativeStatusText, responses, headers ) {
                var isSuccess, success, error, response, modified,
                    statusText = nativeStatusText;

                // Ignore repeat invocations
                if ( completed ) {
                    return;
                }

                completed = true;

                // Clear timeout if it exists
                if ( timeoutTimer ) {
                    window.clearTimeout( timeoutTimer );
                }

                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined;

                // Cache response headers
                responseHeadersString = headers || "";

                // Set readyState
                jqXHR.readyState = status > 0 ? 4 : 0;

                // Determine if successful
                isSuccess = status >= 200 && status < 300 || status === 304;

                // Get response data
                if ( responses ) {
                    response = ajaxHandleResponses( s, jqXHR, responses );
                }

                // Use a noop converter for missing script
                if ( !isSuccess && jQuery.inArray( "script", s.dataTypes ) > -1 ) {
                    s.converters[ "text script" ] = function() {};
                }

                // Convert no matter what (that way responseXXX fields are always set)
                response = ajaxConvert( s, response, jqXHR, isSuccess );

                // If successful, handle type chaining
                if ( isSuccess ) {

                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if ( s.ifModified ) {
                        modified = jqXHR.getResponseHeader( "Last-Modified" );
                        if ( modified ) {
                            jQuery.lastModified[ cacheURL ] = modified;
                        }
                        modified = jqXHR.getResponseHeader( "etag" );
                        if ( modified ) {
                            jQuery.etag[ cacheURL ] = modified;
                        }
                    }

                    // if no content
                    if ( status === 204 || s.type === "HEAD" ) {
                        statusText = "nocontent";

                        // if not modified
                    } else if ( status === 304 ) {
                        statusText = "notmodified";

                        // If we have data, let's convert it
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {

                    // Extract error from statusText and normalize for non-aborts
                    error = statusText;
                    if ( status || !statusText ) {
                        statusText = "error";
                        if ( status < 0 ) {
                            status = 0;
                        }
                    }
                }

                // Set data for the fake xhr object
                jqXHR.status = status;
                jqXHR.statusText = ( nativeStatusText || statusText ) + "";

                // Success/Error
                if ( isSuccess ) {
                    deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
                } else {
                    deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
                }

                // Status-dependent callbacks
                jqXHR.statusCode( statusCode );
                statusCode = undefined;

                if ( fireGlobals ) {
                    globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
                        [ jqXHR, s, isSuccess ? success : error ] );
                }

                // Complete
                completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

                if ( fireGlobals ) {
                    globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

                    // Handle the global AJAX counter
                    if ( !( --jQuery.active ) ) {
                        jQuery.event.trigger( "ajaxStop" );
                    }
                }
            }

            return jqXHR;
        },

        getJSON: function( url, data, callback ) {
            return jQuery.get( url, data, callback, "json" );
        },

        getScript: function( url, callback ) {
            return jQuery.get( url, undefined, callback, "script" );
        }
    } );

    jQuery.each( [ "get", "post" ], function( _i, method ) {
        jQuery[ method ] = function( url, data, callback, type ) {

            // Shift arguments if data argument was omitted
            if ( isFunction( data ) ) {
                type = type || callback;
                callback = data;
                data = undefined;
            }

            // The url can be an options object (which then must have .url)
            return jQuery.ajax( jQuery.extend( {
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            }, jQuery.isPlainObject( url ) && url ) );
        };
    } );

    jQuery.ajaxPrefilter( function( s ) {
        var i;
        for ( i in s.headers ) {
            if ( i.toLowerCase() === "content-type" ) {
                s.contentType = s.headers[ i ] || "";
            }
        }
    } );


    jQuery._evalUrl = function( url, options, doc ) {
        return jQuery.ajax( {
            url: url,

            // Make this explicit, since user can override this through ajaxSetup (#11264)
            type: "GET",
            dataType: "script",
            cache: true,
            async: false,
            global: false,

            // Only evaluate the response if it is successful (gh-4126)
            // dataFilter is not invoked for failure responses, so using it instead
            // of the default converter is kludgy but it works.
            converters: {
                "text script": function() {}
            },
            dataFilter: function( response ) {
                jQuery.globalEval( response, options, doc );
            }
        } );
    };


    jQuery.fn.extend( {
        wrapAll: function( html ) {
            var wrap;

            if ( this[ 0 ] ) {
                if ( isFunction( html ) ) {
                    html = html.call( this[ 0 ] );
                }

                // The elements to wrap the target around
                wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

                if ( this[ 0 ].parentNode ) {
                    wrap.insertBefore( this[ 0 ] );
                }

                wrap.map( function() {
                    var elem = this;

                    while ( elem.firstElementChild ) {
                        elem = elem.firstElementChild;
                    }

                    return elem;
                } ).append( this );
            }

            return this;
        },

        wrapInner: function( html ) {
            if ( isFunction( html ) ) {
                return this.each( function( i ) {
                    jQuery( this ).wrapInner( html.call( this, i ) );
                } );
            }

            return this.each( function() {
                var self = jQuery( this ),
                    contents = self.contents();

                if ( contents.length ) {
                    contents.wrapAll( html );

                } else {
                    self.append( html );
                }
            } );
        },

        wrap: function( html ) {
            var htmlIsFunction = isFunction( html );

            return this.each( function( i ) {
                jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
            } );
        },

        unwrap: function( selector ) {
            this.parent( selector ).not( "body" ).each( function() {
                jQuery( this ).replaceWith( this.childNodes );
            } );
            return this;
        }
    } );


    jQuery.expr.pseudos.hidden = function( elem ) {
        return !jQuery.expr.pseudos.visible( elem );
    };
    jQuery.expr.pseudos.visible = function( elem ) {
        return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
    };




    jQuery.ajaxSettings.xhr = function() {
        try {
            return new window.XMLHttpRequest();
        } catch ( e ) {}
    };

    var xhrSuccessStatus = {

            // File protocol always yields status code 0, assume 200
            0: 200,

            // Support: IE <=9 only
            // #1450: sometimes IE returns 1223 when it should be 204
            1223: 204
        },
        xhrSupported = jQuery.ajaxSettings.xhr();

    support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
    support.ajax = xhrSupported = !!xhrSupported;

    jQuery.ajaxTransport( function( options ) {
        var callback, errorCallback;

        // Cross domain only allowed if supported through XMLHttpRequest
        if ( support.cors || xhrSupported && !options.crossDomain ) {
            return {
                send: function( headers, complete ) {
                    var i,
                        xhr = options.xhr();

                    xhr.open(
                        options.type,
                        options.url,
                        options.async,
                        options.username,
                        options.password
                    );

                    // Apply custom fields if provided
                    if ( options.xhrFields ) {
                        for ( i in options.xhrFields ) {
                            xhr[ i ] = options.xhrFields[ i ];
                        }
                    }

                    // Override mime type if needed
                    if ( options.mimeType && xhr.overrideMimeType ) {
                        xhr.overrideMimeType( options.mimeType );
                    }

                    // X-Requested-With header
                    // For cross-domain requests, seeing as conditions for a preflight are
                    // akin to a jigsaw puzzle, we simply never set it to be sure.
                    // (it can always be set on a per-request basis or even using ajaxSetup)
                    // For same-domain requests, won't change header if already provided.
                    if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
                        headers[ "X-Requested-With" ] = "XMLHttpRequest";
                    }

                    // Set headers
                    for ( i in headers ) {
                        xhr.setRequestHeader( i, headers[ i ] );
                    }

                    // Callback
                    callback = function( type ) {
                        return function() {
                            if ( callback ) {
                                callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

                                if ( type === "abort" ) {
                                    xhr.abort();
                                } else if ( type === "error" ) {

                                    // Support: IE <=9 only
                                    // On a manual native abort, IE9 throws
                                    // errors on any property access that is not readyState
                                    if ( typeof xhr.status !== "number" ) {
                                        complete( 0, "error" );
                                    } else {
                                        complete(

                                            // File: protocol always yields status 0; see #8605, #14207
                                            xhr.status,
                                            xhr.statusText
                                        );
                                    }
                                } else {
                                    complete(
                                        xhrSuccessStatus[ xhr.status ] || xhr.status,
                                        xhr.statusText,

                                        // Support: IE <=9 only
                                        // IE9 has no XHR2 but throws on binary (trac-11426)
                                        // For XHR2 non-text, let the caller handle it (gh-2498)
                                        ( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
                                            { binary: xhr.response } :
                                            { text: xhr.responseText },
                                        xhr.getAllResponseHeaders()
                                    );
                                }
                            }
                        };
                    };

                    // Listen to events
                    xhr.onload = callback();
                    errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

                    // Support: IE 9 only
                    // Use onreadystatechange to replace onabort
                    // to handle uncaught aborts
                    if ( xhr.onabort !== undefined ) {
                        xhr.onabort = errorCallback;
                    } else {
                        xhr.onreadystatechange = function() {

                            // Check readyState before timeout as it changes
                            if ( xhr.readyState === 4 ) {

                                // Allow onerror to be called first,
                                // but that will not handle a native abort
                                // Also, save errorCallback to a variable
                                // as xhr.onerror cannot be accessed
                                window.setTimeout( function() {
                                    if ( callback ) {
                                        errorCallback();
                                    }
                                } );
                            }
                        };
                    }

                    // Create the abort callback
                    callback = callback( "abort" );

                    try {

                        // Do send the request (this may raise an exception)
                        xhr.send( options.hasContent && options.data || null );
                    } catch ( e ) {

                        // #14683: Only rethrow if this hasn't been notified as an error yet
                        if ( callback ) {
                            throw e;
                        }
                    }
                },

                abort: function() {
                    if ( callback ) {
                        callback();
                    }
                }
            };
        }
    } );




    // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
    jQuery.ajaxPrefilter( function( s ) {
        if ( s.crossDomain ) {
            s.contents.script = false;
        }
    } );

    // Install script dataType
    jQuery.ajaxSetup( {
        accepts: {
            script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /\b(?:java|ecma)script\b/
        },
        converters: {
            "text script": function( text ) {
                jQuery.globalEval( text );
                return text;
            }
        }
    } );

    // Handle cache's special case and crossDomain
    jQuery.ajaxPrefilter( "script", function( s ) {
        if ( s.cache === undefined ) {
            s.cache = false;
        }
        if ( s.crossDomain ) {
            s.type = "GET";
        }
    } );

    // Bind script tag hack transport
    jQuery.ajaxTransport( "script", function( s ) {

        // This transport only deals with cross domain or forced-by-attrs requests
        if ( s.crossDomain || s.scriptAttrs ) {
            var script, callback;
            return {
                send: function( _, complete ) {
                    script = jQuery( "<script>" )
                        .attr( s.scriptAttrs || {} )
                        .prop( { charset: s.scriptCharset, src: s.url } )
                        .on( "load error", callback = function( evt ) {
                            script.remove();
                            callback = null;
                            if ( evt ) {
                                complete( evt.type === "error" ? 404 : 200, evt.type );
                            }
                        } );

                    // Use native DOM manipulation to avoid our domManip AJAX trickery
                    document.head.appendChild( script[ 0 ] );
                },
                abort: function() {
                    if ( callback ) {
                        callback();
                    }
                }
            };
        }
    } );




    var oldCallbacks = [],
        rjsonp = /(=)\?(?=&|$)|\?\?/;

    // Default jsonp settings
    jQuery.ajaxSetup( {
        jsonp: "callback",
        jsonpCallback: function() {
            var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
            this[ callback ] = true;
            return callback;
        }
    } );

    // Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

        var callbackName, overwritten, responseContainer,
            jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
                "url" :
                typeof s.data === "string" &&
				( s.contentType || "" )
				    .indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
            );

        // Handle iff the expected data type is "jsonp" or we have a parameter to set
        if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

            // Get callback name, remembering preexisting value associated with it
            callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
                s.jsonpCallback() :
                s.jsonpCallback;

            // Insert callback into url or form data
            if ( jsonProp ) {
                s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
            } else if ( s.jsonp !== false ) {
                s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
            }

            // Use data converter to retrieve json after script execution
            s.converters[ "script json" ] = function() {
                if ( !responseContainer ) {
                    jQuery.error( callbackName + " was not called" );
                }
                return responseContainer[ 0 ];
            };

            // Force json dataType
            s.dataTypes[ 0 ] = "json";

            // Install callback
            overwritten = window[ callbackName ];
            window[ callbackName ] = function() {
                responseContainer = arguments;
            };

            // Clean-up function (fires after converters)
            jqXHR.always( function() {

                // If previous value didn't exist - remove it
                if ( overwritten === undefined ) {
                    jQuery( window ).removeProp( callbackName );

                    // Otherwise restore preexisting value
                } else {
                    window[ callbackName ] = overwritten;
                }

                // Save back as free
                if ( s[ callbackName ] ) {

                    // Make sure that re-using the options doesn't screw things around
                    s.jsonpCallback = originalSettings.jsonpCallback;

                    // Save the callback name for future use
                    oldCallbacks.push( callbackName );
                }

                // Call if it was a function and we have a response
                if ( responseContainer && isFunction( overwritten ) ) {
                    overwritten( responseContainer[ 0 ] );
                }

                responseContainer = overwritten = undefined;
            } );

            // Delegate to script
            return "script";
        }
    } );




    // Support: Safari 8 only
    // In Safari 8 documents created via document.implementation.createHTMLDocument
    // collapse sibling forms: the second one becomes a child of the first one.
    // Because of that, this security measure has to be disabled in Safari 8.
    // https://bugs.webkit.org/show_bug.cgi?id=137337
    support.createHTMLDocument = ( function() {
        var body = document.implementation.createHTMLDocument( "" ).body;
        body.innerHTML = "<form></form><form></form>";
        return body.childNodes.length === 2;
    } )();


    // Argument "data" should be string of html
    // context (optional): If specified, the fragment will be created in this context,
    // defaults to document
    // keepScripts (optional): If true, will include scripts passed in the html string
    jQuery.parseHTML = function( data, context, keepScripts ) {
        if ( typeof data !== "string" ) {
            return [];
        }
        if ( typeof context === "boolean" ) {
            keepScripts = context;
            context = false;
        }

        var base, parsed, scripts;

        if ( !context ) {

            // Stop scripts or inline event handlers from being executed immediately
            // by using document.implementation
            if ( support.createHTMLDocument ) {
                context = document.implementation.createHTMLDocument( "" );

                // Set the base href for the created document
                // so any parsed elements with URLs
                // are based on the document's URL (gh-2965)
                base = context.createElement( "base" );
                base.href = document.location.href;
                context.head.appendChild( base );
            } else {
                context = document;
            }
        }

        parsed = rsingleTag.exec( data );
        scripts = !keepScripts && [];

        // Single tag
        if ( parsed ) {
            return [ context.createElement( parsed[ 1 ] ) ];
        }

        parsed = buildFragment( [ data ], context, scripts );

        if ( scripts && scripts.length ) {
            jQuery( scripts ).remove();
        }

        return jQuery.merge( [], parsed.childNodes );
    };


    /**
 * Load a url into a page
 */
    jQuery.fn.load = function( url, params, callback ) {
        var selector, type, response,
            self = this,
            off = url.indexOf( " " );

        if ( off > -1 ) {
            selector = stripAndCollapse( url.slice( off ) );
            url = url.slice( 0, off );
        }

        // If it's a function
        if ( isFunction( params ) ) {

            // We assume that it's the callback
            callback = params;
            params = undefined;

            // Otherwise, build a param string
        } else if ( params && typeof params === "object" ) {
            type = "POST";
        }

        // If we have elements to modify, make the request
        if ( self.length > 0 ) {
            jQuery.ajax( {
                url: url,

                // If "type" variable is undefined, then "GET" method will be used.
                // Make value of this field explicit since
                // user can override it through ajaxSetup method
                type: type || "GET",
                dataType: "html",
                data: params
            } ).done( function( responseText ) {

                // Save response for use in complete callback
                response = arguments;

                self.html( selector ?

                // If a selector was specified, locate the right elements in a dummy div
                // Exclude scripts to avoid IE 'Permission Denied' errors
                    jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

                // Otherwise use the full result
                    responseText );

                // If the request succeeds, this function gets "data", "status", "jqXHR"
                // but they are ignored because response was set above.
                // If it fails, this function gets "jqXHR", "status", "error"
            } ).always( callback && function( jqXHR, status ) {
                self.each( function() {
                    callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
                } );
            } );
        }

        return this;
    };




    jQuery.expr.pseudos.animated = function( elem ) {
        return jQuery.grep( jQuery.timers, function( fn ) {
            return elem === fn.elem;
        } ).length;
    };




    jQuery.offset = {
        setOffset: function( elem, options, i ) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
                position = jQuery.css( elem, "position" ),
                curElem = jQuery( elem ),
                props = {};

            // Set position first, in-case top/left are set even on static elem
            if ( position === "static" ) {
                elem.style.position = "relative";
            }

            curOffset = curElem.offset();
            curCSSTop = jQuery.css( elem, "top" );
            curCSSLeft = jQuery.css( elem, "left" );
            calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

            // Need to be able to calculate position if either
            // top or left is auto and position is either absolute or fixed
            if ( calculatePosition ) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;

            } else {
                curTop = parseFloat( curCSSTop ) || 0;
                curLeft = parseFloat( curCSSLeft ) || 0;
            }

            if ( isFunction( options ) ) {

                // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
                options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
            }

            if ( options.top != null ) {
                props.top = ( options.top - curOffset.top ) + curTop;
            }
            if ( options.left != null ) {
                props.left = ( options.left - curOffset.left ) + curLeft;
            }

            if ( "using" in options ) {
                options.using.call( elem, props );

            } else {
                if ( typeof props.top === "number" ) {
                    props.top += "px";
                }
                if ( typeof props.left === "number" ) {
                    props.left += "px";
                }
                curElem.css( props );
            }
        }
    };

    jQuery.fn.extend( {

        // offset() relates an element's border box to the document origin
        offset: function( options ) {

            // Preserve chaining for setter
            if ( arguments.length ) {
                return options === undefined ?
                    this :
                    this.each( function( i ) {
                        jQuery.offset.setOffset( this, options, i );
                    } );
            }

            var rect, win,
                elem = this[ 0 ];

            if ( !elem ) {
                return;
            }

            // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
            // Support: IE <=11 only
            // Running getBoundingClientRect on a
            // disconnected node in IE throws an error
            if ( !elem.getClientRects().length ) {
                return { top: 0, left: 0 };
            }

            // Get document-relative position by adding viewport scroll to viewport-relative gBCR
            rect = elem.getBoundingClientRect();
            win = elem.ownerDocument.defaultView;
            return {
                top: rect.top + win.pageYOffset,
                left: rect.left + win.pageXOffset
            };
        },

        // position() relates an element's margin box to its offset parent's padding box
        // This corresponds to the behavior of CSS absolute positioning
        position: function() {
            if ( !this[ 0 ] ) {
                return;
            }

            var offsetParent, offset, doc,
                elem = this[ 0 ],
                parentOffset = { top: 0, left: 0 };

            // position:fixed elements are offset from the viewport, which itself always has zero offset
            if ( jQuery.css( elem, "position" ) === "fixed" ) {

                // Assume position:fixed implies availability of getBoundingClientRect
                offset = elem.getBoundingClientRect();

            } else {
                offset = this.offset();

                // Account for the *real* offset parent, which can be the document or its root element
                // when a statically positioned element is identified
                doc = elem.ownerDocument;
                offsetParent = elem.offsetParent || doc.documentElement;
                while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

                    offsetParent = offsetParent.parentNode;
                }
                if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

                    // Incorporate borders into its offset, since they are outside its content origin
                    parentOffset = jQuery( offsetParent ).offset();
                    parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
                    parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
                }
            }

            // Subtract parent offsets and element margins
            return {
                top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
                left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
            };
        },

        // This method will return documentElement in the following cases:
        // 1) For the element inside the iframe without offsetParent, this method will return
        //    documentElement of the parent window
        // 2) For the hidden or detached element
        // 3) For body or html element, i.e. in case of the html node - it will return itself
        //
        // but those exceptions were never presented as a real life use-cases
        // and might be considered as more preferable results.
        //
        // This logic, however, is not guaranteed and can change at any point in the future
        offsetParent: function() {
            return this.map( function() {
                var offsetParent = this.offsetParent;

                while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
                    offsetParent = offsetParent.offsetParent;
                }

                return offsetParent || documentElement;
            } );
        }
    } );

    // Create scrollLeft and scrollTop methods
    jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
        var top = "pageYOffset" === prop;

        jQuery.fn[ method ] = function( val ) {
            return access( this, function( elem, method, val ) {

                // Coalesce documents and windows
                var win;
                if ( isWindow( elem ) ) {
                    win = elem;
                } else if ( elem.nodeType === 9 ) {
                    win = elem.defaultView;
                }

                if ( val === undefined ) {
                    return win ? win[ prop ] : elem[ method ];
                }

                if ( win ) {
                    win.scrollTo(
                        !top ? val : win.pageXOffset,
                        top ? val : win.pageYOffset
                    );

                } else {
                    elem[ method ] = val;
                }
            }, method, val, arguments.length );
        };
    } );

    // Support: Safari <=7 - 9.1, Chrome <=37 - 49
    // Add the top/left cssHooks using jQuery.fn.position
    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
    // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
    // getComputedStyle returns percent when specified for top/left/bottom/right;
    // rather than make the css module depend on the offset module, just check for it here
    jQuery.each( [ "top", "left" ], function( _i, prop ) {
        jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
            function( elem, computed ) {
                if ( computed ) {
                    computed = curCSS( elem, prop );

                    // If curCSS returns percentage, fallback to offset
                    return rnumnonpx.test( computed ) ?
                        jQuery( elem ).position()[ prop ] + "px" :
                        computed;
                }
            }
        );
    } );


    // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
    jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
        jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
            function( defaultExtra, funcName ) {

                // Margin is only for outerHeight, outerWidth
                jQuery.fn[ funcName ] = function( margin, value ) {
                    var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
                        extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

                    return access( this, function( elem, type, value ) {
                        var doc;

                        if ( isWindow( elem ) ) {

                            // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
                            return funcName.indexOf( "outer" ) === 0 ?
                                elem[ "inner" + name ] :
                                elem.document.documentElement[ "client" + name ];
                        }

                        // Get document width or height
                        if ( elem.nodeType === 9 ) {
                            doc = elem.documentElement;

                            // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                            // whichever is greatest
                            return Math.max(
                                elem.body[ "scroll" + name ], doc[ "scroll" + name ],
                                elem.body[ "offset" + name ], doc[ "offset" + name ],
                                doc[ "client" + name ]
                            );
                        }

                        return value === undefined ?

                        // Get width or height on the element, requesting but not forcing parseFloat
                            jQuery.css( elem, type, extra ) :

                        // Set width or height on the element
                            jQuery.style( elem, type, value, extra );
                    }, type, chainable ? margin : undefined, chainable );
                };
            } );
    } );


    jQuery.each( [
        "ajaxStart",
        "ajaxStop",
        "ajaxComplete",
        "ajaxError",
        "ajaxSuccess",
        "ajaxSend"
    ], function( _i, type ) {
        jQuery.fn[ type ] = function( fn ) {
            return this.on( type, fn );
        };
    } );




    jQuery.fn.extend( {

        bind: function( types, data, fn ) {
            return this.on( types, null, data, fn );
        },
        unbind: function( types, fn ) {
            return this.off( types, null, fn );
        },

        delegate: function( selector, types, data, fn ) {
            return this.on( types, selector, data, fn );
        },
        undelegate: function( selector, types, fn ) {

            // ( namespace ) or ( selector, types [, fn] )
            return arguments.length === 1 ?
                this.off( selector, "**" ) :
                this.off( types, selector || "**", fn );
        },

        hover: function( fnOver, fnOut ) {
            return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
        }
    } );

    jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
    function( _i, name ) {

        // Handle event binding
        jQuery.fn[ name ] = function( data, fn ) {
            return arguments.length > 0 ?
                this.on( name, null, data, fn ) :
                this.trigger( name );
        };
    } );




    // Support: Android <=4.0 only
    // Make sure we trim BOM and NBSP
    var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

    // Bind a function to a context, optionally partially applying any
    // arguments.
    // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
    // However, it is not slated for removal any time soon
    jQuery.proxy = function( fn, context ) {
        var tmp, args, proxy;

        if ( typeof context === "string" ) {
            tmp = fn[ context ];
            context = fn;
            fn = tmp;
        }

        // Quick check to determine if target is callable, in the spec
        // this throws a TypeError, but we will just return undefined.
        if ( !isFunction( fn ) ) {
            return undefined;
        }

        // Simulated bind
        args = slice.call( arguments, 2 );
        proxy = function() {
            return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
        };

        // Set the guid of unique handler to the same of original handler, so it can be removed
        proxy.guid = fn.guid = fn.guid || jQuery.guid++;

        return proxy;
    };

    jQuery.holdReady = function( hold ) {
        if ( hold ) {
            jQuery.readyWait++;
        } else {
            jQuery.ready( true );
        }
    };
    jQuery.isArray = Array.isArray;
    jQuery.parseJSON = JSON.parse;
    jQuery.nodeName = nodeName;
    jQuery.isFunction = isFunction;
    jQuery.isWindow = isWindow;
    jQuery.camelCase = camelCase;
    jQuery.type = toType;

    jQuery.now = Date.now;

    jQuery.isNumeric = function( obj ) {

        // As of jQuery 3.0, isNumeric is limited to
        // strings and numbers (primitives or objects)
        // that can be coerced to finite numbers (gh-2662)
        var type = jQuery.type( obj );
        return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
    };

    jQuery.trim = function( text ) {
        return text == null ?
            "" :
            ( text + "" ).replace( rtrim, "" );
    };



    // Register as a named AMD module, since jQuery can be concatenated with other
    // files that may use define, but not via a proper concatenation script that
    // understands anonymous AMD modules. A named AMD is safest and most robust
    // way to register. Lowercase jquery is used because AMD module names are
    // derived from file names, and jQuery is normally delivered in a lowercase
    // file name. Do this after creating the global so that if an AMD module wants
    // to call noConflict to hide this version of jQuery, it will work.

    // Note that for maximum portability, libraries that are not jQuery should
    // declare themselves as anonymous modules, and avoid setting a global if an
    // AMD loader is present. jQuery is a special case. For more information, see
    // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

    if ( typeof define === "function" && define.amd ) {
        define( "czq", [], function() {
            return jQuery;
        } );
    }

    jQuery.noConflict = function( deep ) {};


    return jQuery;
} );


/***/ }),

/***/ "./src/img/close_popup.png":
/*!*********************************!*\
  !*** ./src/img/close_popup.png ***!
  \*********************************/
/***/ (function(module) {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAAH60AAB+tAEJr8JXAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAotJREFUeNrsmz9LHUEUxY8bwUoweYhFitf6CSSFiI2V1toF0sWvkcpv8DoRVDApUuZVRwTBzj9p1SpuYxMQ7HywNnfg8XDd2fXOuH9ucao3Ozvnt29n5965AwKIoD6BFQLfCAwI7OZoIG1W5JrgYwvZ+TSBNQI/CBwTuCUwIpAVaCRtj+XaL9JXYwAsE9gjcO9h1lf30udynQFsEjhXNJ2nc7lXbQBsRTL+Eoit9wSwSGD4DsYnNZSxRAXw3XNCi6URga8xACQEftbI+KQOZIxBAHwgcFVj805XMlZVAElDzI9DSLQAJAQuG2Te6dIHgg+AJpofhzD1FgC/G2ze6VdVANstMO+0WRZAv0XmnfplAJy1EMCZL4CNFpp32vABcN1iANdFANaVb/hUkz7Gtf4agBvFG10Q+Ezg6A19HEkfF4rjuskDsBRwFTasGOaGWo0uvQRgP/A6PC3RRxo4HtmfBJAQeFT61ORFYj1PCKm0zYtINT7Rj+4haf79HzziiiIIr5kf14PWa+A63FHKyhx6DP5TDoRUfiu6/lApG7XjACwQoOIEc+rxFCf/CT5P/iOBP4rjJIEFEFglcKf8rU09IfwT+bTVHuMdgdWQUZ8PhKmieL3E5FlF25D9uCwgBJ/3uux8oaUBJJOaBYbQq2C+F9h8RuAAsiubRYAwX8L8fATzGYHdWAAyAv8JzHqYn5W2mQFoEYBavwKdnwQ7/xns/EKoKUvhNNRSWDsY+hsoGOpJoKUeDHU+HLaEiKXEwidF5yokRWdiJkVDp8WrlNGdxE6Ld35jxLbGbHPUtsetQMJKZKxIysrkrFDSSmWtWNrK5e3AhB2ZsUNTdmzODk7a0Vk7PN2B4/PPAwCf6Ytzs73kxgAAAABJRU5ErkJggg==";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/App.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=churnzero.js.map